function _readOnlyError(name) {throw new Error("\"" + name + "\" is read-only");}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _newArrowCheck(innerThis, boundThis) {if (innerThis !== boundThis) {throw new TypeError("Cannot instantiate an arrow function");}}define('core/js/wait', [], function () {

  var Wait = Backbone.Controller.extend({

    initialize: function initialize() {
      _.bindAll(this, 'begin', 'end');
    },

    _waitCount: 0,
    _callbackHandle: null,
    _timeoutHandlerId: null,
    _timeoutInSeconds: 7,

    /**
                             * Returns true if there are items in the waiting count.
                             *
                             * @return {Boolean}
                             */
    isWaiting: function isWaiting() {
      return this._waitCount !== 0;
    },

    /**
          * Starts or re-starts a timer to ensure that pending calls to end()
          * are actually executed after a timeout period.
          */
    startTimer: function startTimer() {
      this.stopTimer();

      this._timeoutHandlerId = setInterval(function () {
        // Flush Adapt.wait due to timeout
        while (this._waitCount > 0) {
          // Trigger an end() for anything waiting.
          this.end();
        }

        if (this._waitCount === 0) {
          this.stopTimer();
        }
      }.bind(this), this._timeoutInSeconds * 1000);
    },

    /**
          * Clears the timer.
          */
    stopTimer: function stopTimer() {
      if (this._timeoutHandlerId) {
        clearInterval(this._timeoutHandlerId);
      }
    },

    /**
          * Add one item to the waiting count.
          *
          * @return {Object}
          */
    begin: function begin() {

      if (!this.isWaiting()) {
        this.trigger('wait');
      }

      this._waitCount++;

      if (this._callbackHandle) {
        clearTimeout(this._callbackHandle);
        this._callbackHandle = null;
      }

      this.startTimer();

      return this;

    },

    /**
          * Remove an item from the waiting count and trigger ready asynchronously if no more items are waiting.
          *
          * @return {Object}
          */
    end: function end() {

      if (!this.isWaiting()) {
        return this;
      }

      this._waitCount--;

      if (this._waitCount === 0) {
        this.stopTimer();
      }

      if (this.isWaiting()) {
        return this;
      }

      if (this._callbackHandle) {
        return this;
      }

      this._callbackHandle = setTimeout(function () {

        this._callbackHandle = null;
        this.trigger('ready');

      }.bind(this), 0);

      return this;

    },

    /**
          * Queue this function until all open waits have been ended.
          *
          * @param  {Function} [callback]
          * @return {Object|Promise}
          */
    queue: function queue(callback) {var _this = this;

      if (!callback) {
        this.begin();
        return new Promise(function (resolve) {_newArrowCheck(this, _this);
          this.once('ready', resolve);
          this.end();
        }.bind(this));
      }

      this.begin();
      this.once('ready', callback);
      this.end();

      return this;

    },

    /**
          * Wait for this asynchronous function to execute before triggering ready event.
          *
          * @param  {Function} callback   [ Function to execute whilst holding queued callback. Once complete run first argument, done(). ]
          * @return {Object}
          */
    for: function _for(callback) {

      this.begin();
      _.defer(function () {
        callback(_.once(this.end));
      }.bind(this));

      return this;

    } });



  return Wait;

});

define('core/js/models/lockingModel', [], function () {

  var _set = Backbone.Model.prototype.set;

  Object.assign(Backbone.Model.prototype, {

    set: function set(attrName, attrVal) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var stopProcessing = _typeof(attrName) === 'object' || typeof attrVal !== 'boolean' || !this.isLocking(attrName);
      if (stopProcessing) return _set.apply(this, arguments);

      var isSettingValueForSpecificPlugin = options && options.pluginName;
      if (!isSettingValueForSpecificPlugin) {
        console.error('Must supply a pluginName to change a locked attribute');
        options.pluginName = 'compatibility';
      }

      var pluginName = options.pluginName;
      if (this.defaults[attrName] !== undefined) {
        this._lockedAttributes[attrName] = !this.defaults[attrName];
      }
      var lockingValue = this._lockedAttributes[attrName];
      var isAttemptingToLock = lockingValue === attrVal;

      if (isAttemptingToLock) {
        this.setLockState(attrName, true, { pluginName: pluginName, skipcheck: true });
        return _set.call(this, attrName, lockingValue);
      }

      this.setLockState(attrName, false, { pluginName: pluginName, skipcheck: true });

      var totalLockValue = this.getLockCount(attrName, { skipcheck: true });
      if (totalLockValue === 0) {
        return _set.call(this, attrName, !lockingValue);
      }

      return this;

    },

    setLocking: function setLocking(attrName, defaultLockValue) {
      if (this.isLocking(attrName)) return;
      if (!this._lockedAttributes) this._lockedAttributes = {};
      this._lockedAttributes[attrName] = defaultLockValue;
    },

    unsetLocking: function unsetLocking(attrName) {
      if (!this.isLocking(attrName)) return;
      if (!this._lockedAttributes) return;
      delete this._lockedAttributes[attrName];
      delete this._lockedAttributesValues[attrName];
      if (Object.keys(this._lockedAttributes).length === 0) {
        delete this._lockedAttributes;
        delete this._lockedAttributesValues;
      }
    },

    isLocking: function isLocking(attrName) {
      var isCheckingGeneralLockingState = attrName === undefined;
      var isUsingLockedAttributes = Boolean(this.lockedAttributes || this._lockedAttributes);

      if (isCheckingGeneralLockingState) {
        return isUsingLockedAttributes;
      }

      if (!isUsingLockedAttributes) return false;

      if (!this._lockedAttributes) {
        this._lockedAttributes = _.result(this, 'lockedAttributes');
      }

      var isAttributeALockingAttribute = this._lockedAttributes.hasOwnProperty(attrName);
      if (!isAttributeALockingAttribute) return false;

      if (!this._lockedAttributesValues) {
        this._lockedAttributesValues = {};
      }

      if (!this._lockedAttributesValues[attrName]) {
        this._lockedAttributesValues[attrName] = {};
      }

      return true;
    },

    isLocked: function isLocked(attrName, options) {
      var shouldSkipCheck = options && options.skipcheck;
      if (!shouldSkipCheck) {
        var stopProcessing = !this.isLocking(attrName);
        if (stopProcessing) return;
      }

      return this.getLockCount(attrName) > 0;
    },

    getLockCount: function getLockCount(attrName, options) {var _this2 = this;
      var shouldSkipCheck = options && options.skipcheck;
      if (!shouldSkipCheck) {
        var stopProcessing = !this.isLocking(attrName);
        if (stopProcessing) return;
      }

      var isGettingValueForSpecificPlugin = options && options.pluginName;
      if (isGettingValueForSpecificPlugin) {
        return this._lockedAttributesValues[attrName][options.pluginName] ? 1 : 0;
      }

      var lockingAttributeValues = Object.values(this._lockedAttributesValues[attrName]);
      var lockingAttributeValuesSum = lockingAttributeValues.reduce(function (sum, value) {_newArrowCheck(this, _this2);return sum + (value ? 1 : 0);}.bind(this), 0);

      return lockingAttributeValuesSum;
    },

    setLockState: function setLockState(attrName, value, options) {
      var shouldSkipCheck = options && options.skipcheck;
      if (!shouldSkipCheck) {
        var stopProcessing = !this.isLocking(attrName);
        if (stopProcessing) return this;
      }

      var isSettingValueForSpecificPlugin = options && options.pluginName;
      if (!isSettingValueForSpecificPlugin) {
        console.error('Must supply a pluginName to set a locked attribute lock value');
        options.pluginName = 'compatibility';
      }

      if (value) {
        this._lockedAttributesValues[attrName][options.pluginName] = value;
      } else {
        delete this._lockedAttributesValues[attrName][options.pluginName];
      }

      return this;

    } });



});

define('core/js/adapt', [
'core/js/wait',
'core/js/models/lockingModel'],
function (Wait) {var

  Adapt = /*#__PURE__*/function (_Backbone$Model) {"use strict";_inherits(Adapt, _Backbone$Model);var _super = _createSuper(Adapt);function Adapt() {_classCallCheck(this, Adapt);return _super.apply(this, arguments);}_createClass(Adapt, [{ key: "initialize", value: function initialize()

      {
        this.loadScript = window.__loadScript;
        this.location = {};
        this.store = {};
        this.setupWait();
      } }, { key: "defaults", value: function defaults()

      {
        return {
          _canScroll: true, // to stop scrollTo behaviour,
          _outstandingCompletionChecks: 0,
          _pluginWaitCount: 0,
          _isStarted: false,
          _shouldDestroyContentObjects: true };

      } }, { key: "lockedAttributes", value: function lockedAttributes()

      {
        return {
          _canScroll: false };

      }

      /**
         * @deprecated since v6.0.0 - please use `Adapt.store` instead
         */ }, { key: "init", value: function init()





      {var _this3 = this;
        this.addDirection();
        this.disableAnimation();
        this.trigger('adapt:preInitialize');

        // wait until no more completion checking
        this.deferUntilCompletionChecked(function () {_newArrowCheck(this, _this3);

          // start adapt in a full restored state
          this.trigger('adapt:start');

          if (!Backbone.History.started) {
            Backbone.history.start();
          }

          this.set('_isStarted', true);

          this.trigger('adapt:initialize');

        }.bind(this));
      }

      /**
         * call when entering an asynchronous completion check
         */ }, { key: "checkingCompletion", value: function checkingCompletion()
      {
        var outstandingChecks = this.get('_outstandingCompletionChecks');
        this.set('_outstandingCompletionChecks', outstandingChecks + 1);
      }

      /**
         * call when exiting an asynchronous completion check
         */ }, { key: "checkedCompletion", value: function checkedCompletion()
      {
        var outstandingChecks = this.get('_outstandingCompletionChecks');
        this.set('_outstandingCompletionChecks', outstandingChecks - 1);
      }

      /**
         * wait until there are no outstanding completion checks
         * @param {Function} callback Function to be called after all completion checks have been completed
         */ }, { key: "deferUntilCompletionChecked", value: function deferUntilCompletionChecked(
      callback) {var _this4 = this;
        if (this.get('_outstandingCompletionChecks') === 0) return callback();

        var _checkIfAnyChecksOutstanding = function checkIfAnyChecksOutstanding(model, outstandingChecks) {_newArrowCheck(this, _this4);
          if (outstandingChecks !== 0) return;
          this.off('change:_outstandingCompletionChecks', _checkIfAnyChecksOutstanding);
          callback();
        }.bind(this);

        this.on('change:_outstandingCompletionChecks', _checkIfAnyChecksOutstanding);

      } }, { key: "setupWait", value: function setupWait()

      {var _this5 = this;

        this.wait = new Wait();

        // Setup legacy events and handlers
        var beginWait = function beginWait() {_newArrowCheck(this, _this5);
          this.log.deprecated("Use Adapt.wait.begin() as Adapt.trigger('plugin:beginWait') may be removed in the future");
          this.wait.begin();
        }.bind(this);

        var endWait = function endWait() {_newArrowCheck(this, _this5);
          this.log.deprecated("Use Adapt.wait.end() as Adapt.trigger('plugin:endWait') may be removed in the future");
          this.wait.end();
        }.bind(this);

        var ready = function ready() {_newArrowCheck(this, _this5);
          if (this.wait.isWaiting()) {
            return;
          }
          var isEventListening = this._events['plugins:ready'];
          if (!isEventListening) {
            return;
          }
          this.log.deprecated("Use Adapt.wait.queue(callback) as Adapt.on('plugins:ready', callback) may be removed in the future");
          this.trigger('plugins:ready');
        }.bind(this);

        this.listenTo(this.wait, 'ready', ready);
        this.listenTo(this, {
          'plugin:beginWait': beginWait,
          'plugin:endWait': endWait });


      } }, { key: "isWaitingForPlugins", value: function isWaitingForPlugins()

      {
        this.log.deprecated('Use Adapt.wait.isWaiting() as Adapt.isWaitingForPlugins() may be removed in the future');
        return this.wait.isWaiting();
      } }, { key: "checkPluginsReady", value: function checkPluginsReady()

      {
        this.log.deprecated('Use Adapt.wait.isWaiting() as Adapt.checkPluginsReady() may be removed in the future');
        if (this.isWaitingForPlugins()) {
          return;
        }
        this.trigger('plugins:ready');
      }

      /**
         * Allows a selector or id to be passed in and Adapt will navigate to this element. Resolves
         * asynchronously when the element has been navigated to.
         * @param {string} selector CSS selector or id of the Adapt element you want to navigate to e.g. `".co-05"` or `"co-05"`
         * @param {Object} [settings] The settings for the `$.scrollTo` function (See https://github.com/flesler/jquery.scrollTo#settings).
         * @param {Object} [settings.replace=false] Set to `true` if you want to update the URL without creating an entry in the browser's history.
         */ }, { key: "navigateToElement", value: function () {var _navigateToElement = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:case "end":return _context.stop();}}}, _callee);}));function navigateToElement() {return _navigateToElement.apply(this, arguments);}return navigateToElement;}()


      /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Allows a selector to be passed in and Adapt will scroll to this element. Resolves
                                                                                                                                                                                                                                                                                                                                                                                                                                                            * asynchronously when the element has been navigated/scrolled to.
                                                                                                                                                                                                                                                                                                                                                                                                                                                            * @param {string} selector CSS selector of the Adapt element you want to navigate to e.g. `".co-05"`
                                                                                                                                                                                                                                                                                                                                                                                                                                                            * @param {Object} [settings={}] The settings for the `$.scrollTo` function (See https://github.com/flesler/jquery.scrollTo#settings).
                                                                                                                                                                                                                                                                                                                                                                                                                                                            * @param {Object} [settings.replace=false] Set to `true` if you want to update the URL without creating an entry in the browser's history.
                                                                                                                                                                                                                                                                                                                                                                                                                                                            */ }, { key: "scrollTo", value: function () {var _scrollTo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:case "end":return _context2.stop();}}}, _callee2);}));function scrollTo() {return _scrollTo.apply(this, arguments);}return scrollTo;}()


      /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Used to register models and views with `Adapt.store`
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {string|Array} name The name(s) of the model/view to be registered
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * @param {object} object Object containing properties `model` and `view` or (legacy) an object representing the view
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         */ }, { key: "register", value: function register(
      name, object) {var _this6 = this;
        if (Array.isArray(name)) {
          // if an array is passed, iterate by recursive call
          name.forEach(function (name) {_newArrowCheck(this, _this6);return this.register(name, object);}.bind(this));
          return object;
        }

        if (name.split(' ').length > 1) {
          // if name with spaces is passed, split and pass as array
          this.register(name.split(' '), object);
          return object;
        }

        if (!object.view && !object.model || object instanceof Backbone.View) {
          this.log && this.log.deprecated('View-only registrations are no longer supported');
          object = { view: object };
        }

        if (object.view && !object.view.template) {
          object.view.template = name;
        }

        var isModelSetAndInvalid = object.model &&
        !(object.model.prototype instanceof Backbone.Model) &&
        !(object.model instanceof Function);
        if (isModelSetAndInvalid) {
          throw new Error('The registered model is not a Backbone.Model or Function');
        }

        var isViewSetAndInvalid = object.view &&
        !(object.view.prototype instanceof Backbone.View) &&
        !(object.view instanceof Function);
        if (isViewSetAndInvalid) {
          throw new Error('The registered view is not a Backbone.View or Function');
        }

        this.store[name] = Object.assign({}, this.store[name], object);

        return object;
      }

      /**
         * Parses a view class name.
         * @param {string|Backbone.Model|Backbone.View|object} nameModelViewOrData The name of the view class you want to fetch e.g. `"hotgraphic"` or its model or its json data
         */ }, { key: "getViewName", value: function getViewName(
      nameModelViewOrData) {var _this7 = this;
        if (typeof nameModelViewOrData === 'string') {
          return nameModelViewOrData;
        }
        if (nameModelViewOrData instanceof Backbone.Model) {
          nameModelViewOrData = nameModelViewOrData.toJSON();
        }
        if (nameModelViewOrData instanceof Backbone.View) {
          var foundName;
          _.find(this.store, function (entry, name) {_newArrowCheck(this, _this7);
            if (!entry || !entry.view) return;
            if (!(nameModelViewOrData instanceof entry.view)) return;
            foundName = name;
            return true;
          }.bind(this));
          return foundName;
        }
        if (nameModelViewOrData instanceof Object) {
          var names = [
          typeof nameModelViewOrData._view === 'string' && nameModelViewOrData._view,
          typeof nameModelViewOrData._component === 'string' && nameModelViewOrData._component,
          typeof nameModelViewOrData._type === 'string' && nameModelViewOrData._type].
          filter(Boolean);
          if (names.length) {
            // find first fitting view name
            var name = names.find(function (name) {_newArrowCheck(this, _this7);return this.store[name] && this.store[name].view;}.bind(this));
            return name || names.pop(); // return last available if none found
          }
        }
        throw new Error('Cannot derive view class name from input');
      }

      /**
         * Fetches a view class from the store. For a usage example, see either HotGraphic or Narrative
         * @param {string|Backbone.Model|Backbone.View|object} nameModelViewOrData The name of the view class you want to fetch e.g. `"hotgraphic"` or its model or its json data
         * @returns {Backbone.View} Reference to the view class
         */ }, { key: "getViewClass", value: function getViewClass(
      nameModelViewOrData) {
        var name = this.getViewName(nameModelViewOrData);
        var object = this.store[name];
        if (!object) {
          this.log.warnOnce("A view for '".concat(name, "' isn't registered in your project"));
          return;
        }
        var isBackboneView = object.view && object.view.prototype instanceof Backbone.View;
        if (!isBackboneView && object.view instanceof Function) {
          return object.view();
        }
        return object.view;
      }

      /**
         * Parses a model class name.
         * @param {string|Backbone.Model|object} name The name of the model you want to fetch e.g. `"hotgraphic"`, the model to process or its json data
         */ }, { key: "getModelName", value: function getModelName(
      nameModelOrData) {var _this8 = this;
        if (typeof nameModelOrData === 'string') {
          return nameModelOrData;
        }
        if (nameModelOrData instanceof Backbone.Model) {
          nameModelOrData = nameModelOrData.toJSON();
        }
        if (nameModelOrData instanceof Object) {
          var name = nameModelOrData._component;
          var entry = this.store[name];
          var isViewOnlyQuestion = entry && !entry.model && entry.view && entry.view._isQuestionType;
          if (isViewOnlyQuestion) {
            // Use question model by default
            this.log && this.log.deprecated("Assuming a question model for a view-only question: ".concat(name));
            return 'question';
          }
          var names = [
          typeof nameModelOrData._model === 'string' && nameModelOrData._model,
          typeof nameModelOrData._component === 'string' && nameModelOrData._component,
          typeof nameModelOrData._type === 'string' && nameModelOrData._type].
          filter(Boolean);
          if (names.length) {
            // find first fitting model name
            var _name = names.find(function (name) {_newArrowCheck(this, _this8);return this.store[name] && this.store[name].model;}.bind(this));
            return _name || names.pop(); // return last available if none found
          }
        }
        throw new Error('Cannot derive model class name from input');
      }

      /**
         * Fetches a model class from the store. For a usage example, see either HotGraphic or Narrative
         * @param {string|Backbone.Model|object} name The name of the model you want to fetch e.g. `"hotgraphic"` or its json data
         * @returns {Backbone.Model} Reference to the view class
         */ }, { key: "getModelClass", value: function getModelClass(
      nameModelOrData) {
        var name = this.getModelName(nameModelOrData);
        var object = this.store[name];
        if (!object) {
          this.log.warnOnce("A model for '".concat(name, "' isn't registered in your project"));
          return;
        }
        var isBackboneModel = object.model && object.model.prototype instanceof Backbone.Model;
        if (!isBackboneModel && object.model instanceof Function) {
          return object.model();
        }
        return object.model;
      }

      /**
         * Looks up which collection a model belongs to
         * @param {string} id The id of the item you want to look up e.g. `"co-05"`
         * @return {string} One of the following (or `undefined` if not found):
         * - "course"
         * - "contentObjects"
         * - "blocks"
         * - "articles"
         * - "components"
         */ }, { key: "mapById", value: function mapById(
      id) {
        return this.data.mapById(id);
      }

      /**
         * Looks up a model by its `_id` property
         * @param {string} id The id of the item e.g. "co-05"
         * @return {Backbone.Model}
         */ }, { key: "findById", value: function findById(
      id) {
        return this.data.findById(id);
      } }, { key: "findViewByModelId", value: function findViewByModelId(

      id) {var _this9 = this;
        var model = this.data.findById(id);
        if (!model) return;

        if (model === this.parentView.model) return this.parentView;

        var idPathToView = [id];
        var currentLocationId = this.location._currentId;
        var currentLocationModel = model.getAncestorModels().find(function (model) {_newArrowCheck(this, _this9);
          var modelId = model.get('_id');
          if (modelId === currentLocationId) return true;
          idPathToView.unshift(modelId);
        }.bind(this));

        if (!currentLocationModel) {
          return console.warn("Adapt.findViewByModelId() unable to find view for model id: ".concat(id));
        }

        var foundView = idPathToView.reduce(function (view, currentId) {var _this10 = this;_newArrowCheck(this, _this9);
          if (!view) return;
          var childViews = view.getChildViews();
          return childViews && childViews.find(function (view) {_newArrowCheck(this, _this10);return view.model.get('_id') === currentId;}.bind(this));
        }.bind(this), this.parentView);

        return foundView;
      }

      /**
         * Relative strings describe the number and type of hops in the model hierarchy
         * @param {string} relativeString "@component +1" means to move one component forward from the current model
         * This function would return the following:
         * {
         *     type: "component",
         *     offset: 1
         * }
         * Trickle uses this function to determine where it should scrollTo after it unlocks
         */ }, { key: "parseRelativeString", value: function parseRelativeString(
      relativeString) {
        var splitIndex = relativeString.search(/[ +\-\d]{1}/);
        var type = relativeString.slice(0, splitIndex).replace(/^@/, '');
        var offset = parseInt(relativeString.slice(splitIndex).trim() || 0);
        return {
          type: type,
          offset: offset };

      } }, { key: "addDirection", value: function addDirection()

      {
        var defaultDirection = this.config.get('_defaultDirection');

        $('html').
        addClass('dir-' + defaultDirection).
        attr('dir', defaultDirection);
      } }, { key: "disableAnimation", value: function disableAnimation()

      {
        var disableAnimationArray = this.config.get('_disableAnimationFor');
        var disableAnimation = this.config.get('_disableAnimation');

        // Check if animations should be disabled
        if (disableAnimationArray) {
          for (var i = 0, l = disableAnimationArray.length; i < l; i++) {
            if (!$('html').is(disableAnimationArray[i])) continue;
            this.config.set('_disableAnimation', true);
            $('html').addClass('disable-animation');
            console.log('Animation disabled.');
          }
          return;
        }

        $('html').toggleClass('disable-animation', disableAnimation === true);
      } }, { key: "remove", value: function () {var _remove = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {var currentView;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:


                  currentView = this.parentView;
                  if (currentView) {
                    currentView.model.setOnChildren({
                      '_isReady': false,
                      '_isRendered': false });

                  }
                  this.trigger('preRemove', currentView);_context3.next = 5;return (
                    this.wait.queue());case 5:
                  // Facilitate contentObject transitions
                  if (currentView && this.get('_shouldDestroyContentObjects')) {
                    currentView.destroy();
                  }
                  this.trigger('remove', currentView);
                  _.defer(this.trigger.bind(this), 'postRemove', currentView);case 8:case "end":return _context3.stop();}}}, _callee3, this);}));function remove() {return _remove.apply(this, arguments);}return remove;}() }, { key: "componentStore", get: function get() {this.log && this.log.deprecated('Adapt.componentStore, please use Adapt.store instead');return this.store;} }]);return Adapt;}(Backbone.Model);




  return new Adapt();
});

define('core/js/templateRenderEvent', [], function () {var

  TemplateRenderEvent = /*#__PURE__*/function (_Backbone$Controller) {"use strict";_inherits(TemplateRenderEvent, _Backbone$Controller);var _super2 = _createSuper(TemplateRenderEvent);function TemplateRenderEvent() {_classCallCheck(this, TemplateRenderEvent);return _super2.apply(this, arguments);}_createClass(TemplateRenderEvent, [{ key: "initialize",

      /**
                                                                                                                                                                                                                                                                                                                                                                   * Template render event
                                                                                                                                                                                                                                                                                                                                                                   * @param {string} type Event type
                                                                                                                                                                                                                                                                                                                                                                   * @param {string} name Template name
                                                                                                                                                                                                                                                                                                                                                                   * @param {string} mode "template" / "partial"
                                                                                                                                                                                                                                                                                                                                                                   * @param {string} value Rendered template string
                                                                                                                                                                                                                                                                                                                                                                   * @param {[*]} args Arguments passed to template for render
                                                                                                                                                                                                                                                                                                                                                                   */value: function initialize(
      type, name, mode, value, args) {
        /** @type {string} Event type */
        this.type = type;
        /** @type {string} Template name */
        this.name = name;
        /** @type {string} "template" / "partial" */
        this.mode = mode;
        /** @type {string} Rendered template string */
        this.value = value;
        /** @type {[*]} Arguments passed to template for render */
        this.args = args;
      } }]);return TemplateRenderEvent;}(Backbone.Controller);



  return TemplateRenderEvent;

});

define('core/js/templates', [
'core/js/adapt',
'handlebars',
'./templateRenderEvent'],
function (Adapt, Handlebars, TemplateRenderEvent) {

  /**
                                                    * Adds template and partial, preRender and postRender events to Adapt
                                                    */

  function onRender(cb) {var _this11 = this;
    var intercept = function intercept(object, name, mode, cb) {_newArrowCheck(this, _this11);
      return object[name] = cb.bind(object, object[name], name, mode);
    }.bind(this);
    Object.keys(Handlebars.templates).forEach(function (name) {_newArrowCheck(this, _this11);
      intercept(Handlebars.templates, name, 'template', cb);
    }.bind(this));
    Object.keys(Handlebars.partials).forEach(function (name) {_newArrowCheck(this, _this11);
      intercept(Handlebars.partials, name, 'partial', cb);
    }.bind(this));
  }

  onRender(function (template, name, mode) {for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {args[_key - 3] = arguments[_key];}
    // Send preRender event to allow modification of args
    var preRenderEvent = new TemplateRenderEvent("".concat(mode, ":preRender"), name, mode, null, args);
    Adapt.trigger(preRenderEvent.type, preRenderEvent);

    // Execute template
    var value = template.apply(void 0, _toConsumableArray(preRenderEvent.args));

    // Send postRender event to allow modification of rendered template
    var postRenderEvent = new TemplateRenderEvent("".concat(mode, ":postRender"), name, mode, value, preRenderEvent.args);
    Adapt.trigger(postRenderEvent.type, postRenderEvent);

    // Return rendered, modified template
    return postRenderEvent.value;
  });

});

define('core/js/fixes/img.lazyload', [
'core/js/adapt',
'../templates'],
function (Adapt) {

  /**
                   * 27 April 2020 https://github.com/adaptlearning/adapt_framework/issues/2734
                   * Chrome on Android defers load events on images when lite mode is enabled
                   * and as part of a data saving technique.
                   *
                   * Add a loading="eager" attribute to all template and partial img tags where
                   * the loading attribute is missing.
                   */
  Adapt.on('app:dataReady', function () {
    var config = Adapt.config.get('_fixes');
    if (config && config._imgLazyLoad === false) return;
    applyImgLoadingFix();
  });

  function applyImgLoadingFix() {
    var findImgTag = /<img([^>]*)>/gi;
    var hasLoadingAttr = / loading=/gi;
    Adapt.on('template:postRender partial:postRender', function (event) {var _this12 = this;
      var imgTagsFound = event.value.match(findImgTag);
      if (!imgTagsFound) {
        return;
      }
      event.value = imgTagsFound.reduce(function (value, img) {_newArrowCheck(this, _this12);
        if (hasLoadingAttr.test(img)) {
          return value;
        }
        // Add loading="eager" by default
        return value.replace(img, img.replace(findImgTag, '<img loading="eager"$1>'));
      }.bind(this), event.value);
    });
  }

});

define('core/js/fixes', [
'./fixes/img.lazyload'],
function () {});

define('core/js/a11y/browserFocus', [
'core/js/adapt'],
function (Adapt) {

  /**
                   * Browser modifications to focus handling.
                   * @class
                   */
  var BrowserFocus = Backbone.Controller.extend({

    initialize: function initialize() {
      _.bindAll(this, '_onBlur', '_onClick');
      this.$body = $('body');
      this.listenTo(Adapt, {
        'accessibility:ready': this._attachEventListeners });

    },

    _attachEventListeners: function _attachEventListeners() {
      this.$body.
      on('blur', '*', this._onBlur).
      on('blur', this._onBlur);
      // 'Capture' event attachment for click
      this.$body[0].addEventListener('click', this._onClick, true);
    },

    /**
        * When any element in the document receives a blur event,
        * check to see if it needs the `data-a11y-force-focus` attribute removing
        * and check to see if it was blurred because a disabled attribute was added.
        * If a disabled attribute was added, the focus will be moved forward.
        *
        * @param {JQuery.Event} event
        */
    _onBlur: function _onBlur(event) {
      var config = Adapt.a11y.config;
      if (!config._isEnabled || !config._options._isFocusNextOnDisabled) {
        return;
      }
      var $element = $(event.target);
      if ($element.is('[data-a11y-force-focus]')) {
        _.defer(function () {
          $element.removeAttr('tabindex data-a11y-force-focus');
        });
      }
      // From here, only check source elements
      if (event.target !== event.currentTarget) {
        return;
      }
      // Check if element losing focus is losing focus
      // due to the addition of a disabled class
      if (!$element.is('[disabled]')) {
        return;
      }
      // Move focus to next readable element
      Adapt.a11y.focusNext($element);
    },

    /**
        * Force focus when clicked on a tabbable element,
        * making sure `document.activeElement` is updated.
        *
        * @param {JQuery.Event} event
        */
    _onClick: function _onClick(event) {
      var config = Adapt.a11y.config;
      if (!config._isEnabled || !config._options._isFocusOnClickEnabled) {
        return;
      }
      var $element = $(event.target);
      var $stack = $().add($element).add($element.parents());
      var $focusable = $stack.filter(config._options._tabbableElements);
      if (!$focusable.length) {
        return;
      }
      // Force focus for screen reader enter / space press
      $focusable[0].focus();
    } });



  return BrowserFocus;

});

define('core/js/a11y/focusOptions', [], function () {

  /**
                                                      * Options parser for focus functions.
                                                      * @class
                                                      */
  var FocusOptions = function FocusOptions(options) {
    _.defaults(this, options, {

      /**
                                 * Stops the browser from scrolling to the focused point.
                                 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus
                                 *
                                 * @type {boolean}
                                 */
      preventScroll: true,

      /**
                            * Add a defer to the focus call, allowing for user interface settling.
                            *
                            * @type {boolean}
                            */
      defer: false });


  };

  return FocusOptions;

});

define('core/js/a11y/keyboardFocusOutline', [
'core/js/adapt'],
function (Adapt) {

  /**
                   * Manages whether or not the focus outline should be entirely removed
                   * or removed until a key is pressed on a tabbable element.
                   * @class
                   */
  var KeyboardFocusOutline = Backbone.Controller.extend({

    initialize: function initialize() {
      _.bindAll(this, '_onKeyDown');
      this.$html = $('html');
      this.showOnKeys = {
        9: true, // tab
        13: true, // enter
        32: true, // space
        37: true, // arrow left
        38: true, // arrow up
        39: true, // arrow right
        40: true // arrow down
      };
      this.listenTo(Adapt, {
        'accessibility:ready': this._attachEventListeners });

    },

    _attachEventListeners: function _attachEventListeners() {
      document.addEventListener('keydown', this._onKeyDown);
      this._start();
    },

    /**
        * Add styling classes if required.
        */
    _start: function _start() {
      var config = Adapt.a11y.config;
      if (config._options._isFocusOutlineDisabled) {
        this.$html.addClass('a11y-disable-focusoutline');
        return;
      }
      if (!config._isEnabled || !config._options._isFocusOutlineKeyboardOnlyEnabled) {
        return;
      }
      this.$html.addClass('a11y-disable-focusoutline');
    },

    /**
        * Handle key down events for on a tabbable element.
        *
        * @param {JQuery.Event} event
        */
    _onKeyDown: function _onKeyDown(event) {
      var config = Adapt.a11y.config;
      if (config._options._isFocusOutlineDisabled) {
        this.$html.addClass('a11y-disable-focusoutline');
        return;
      }
      if (!config._isEnabled || !config._options._isFocusOutlineKeyboardOnlyEnabled || !this.showOnKeys[event.keyCode]) {
        return;
      }
      var $element = $(event.target);
      if (!$element.is(config._options._tabbableElements) || $element.is(config._options._focusOutlineKeyboardOnlyIgnore)) {
        return;
      }
      this.$html.removeClass('a11y-disable-focusoutline');
    } });



  return KeyboardFocusOutline;

});

define('core/js/a11y/log', [
'core/js/adapt'],
function (Adapt) {

  /**
                   * Controller for managing accessibilty logging, specifically used for
                   * controlling the display of removed or deprecated API warnings.
                   */var
  Log = /*#__PURE__*/function (_Backbone$Controller2) {"use strict";_inherits(Log, _Backbone$Controller2);var _super3 = _createSuper(Log);function Log() {_classCallCheck(this, Log);return _super3.apply(this, arguments);}_createClass(Log, [{ key: "initialize", value: function initialize()

      {
        this._warned = {};
      } }, { key: "_hasWarned", value: function _hasWarned(

      args) {
        var config = Adapt.a11y.config;
        if (!config._options._warnFirstOnly) {
          return false;
        }
        var hash = args.map(String).join(':');
        if (this._warned[hash]) {
          return true;
        }
        this._warned[hash] = true;
        return false;
      } }, { key: "_canWarn", value: function _canWarn()

      {
        var config = Adapt.a11y.config;
        return Boolean(config._options._warn);
      } }, { key: "removed", value: function removed()

      {var _Adapt$log;for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}
        if (!this._canWarn) {
          return;
        }
        args = ['A11Y'].concat(args);
        if (this._hasWarned(args)) {
          return;
        }
        (_Adapt$log = Adapt.log).removed.apply(_Adapt$log, _toConsumableArray(args));
        return this;
      } }, { key: "deprecated", value: function deprecated()

      {var _Adapt$log2;for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {args[_key3] = arguments[_key3];}
        if (!this._canWarn) {
          return;
        }
        args = ['A11Y'].concat(args);
        if (this._hasWarned(args)) {
          return;
        }
        (_Adapt$log2 = Adapt.log).deprecated.apply(_Adapt$log2, _toConsumableArray(args));
        return this;
      } }]);return Log;}(Backbone.Controller);



  return Log;

});

define('core/js/a11y/scroll', [], function () {

  /**
                                                * Controller for blocking scroll events on specified elements.
                                                * @class
                                                */
  var Scroll = Backbone.Controller.extend({

    initialize: function initialize() {
      _.bindAll(this, '_onTouchStart', '_onTouchEnd', '_onScrollEvent', '_onKeyDown');
      this._scrollDisabledElements = $([]);
      this.$window = $(window);
      this.$body = $('body');
      this._preventScrollOnKeys = {
        37: true, // left
        38: true, // up
        39: true, // right
        40: true // down
      };
      this._ignoreKeysOnElementsMatching = 'textarea, input, select';
      this._isRunning = false;
      this._touchStartEventObject = null;
    },

    /**
        * Block scrolling on the given elements.
        *
        * @param {Object|string|Array} $elements
        */
    disable: function disable($elements) {
      $elements = $($elements);
      this._scrollDisabledElements = this._scrollDisabledElements.add($elements);
      this._checkRunning();
      return this;
    },

    /**
        * Stop blocking scrolling on the given elements.
        *
        * @param {Object|string|Array} $items
        */
    enable: function enable($elements) {
      $elements = $($elements);
      if (!$elements || !$elements.length) {
        this.clear();
        return this;
      }
      this._scrollDisabledElements = this._scrollDisabledElements.not($elements);
      this._checkRunning();
      return this;
    },

    /**
        * Stop blocking all scrolling.
        */
    clear: function clear() {
      this._scrollDisabledElements = $([]);
      this._checkRunning();
      return this;
    },

    /**
        * Start or stop listening for events to block if and when needed.
        */
    _checkRunning: function _checkRunning() {
      if (!this._scrollDisabledElements.length) {
        this._stop();
        return;
      }
      this._start();
    },

    /**
        * Start listening for events to block.
        */
    _start: function _start() {
      if (this._isRunning) {
        return;
      }
      this._isRunning = true;
      window.addEventListener('touchstart', this._onTouchStart); // mobile
      window.addEventListener('touchend', this._onTouchEnd); // mobile
      window.addEventListener('touchmove', this._onScrollEvent, { passive: false }); // mobile
      window.addEventListener('wheel', this._onScrollEvent, { passive: false });
      document.addEventListener('wheel', this._onScrollEvent, { passive: false });
      document.addEventListener('keydown', this._onKeyDown);
    },

    /**
        * Capture the touchstart event object for deltaY calculations.
        *
        * @param {JQuery.Event} event
        */
    _onTouchStart: function _onTouchStart(event) {
      event = $.event.fix(event);
      this._touchStartEventObject = event;
      return true;
    },

    /**
        * Clear touchstart event object.
        */
    _onTouchEnd: function _onTouchEnd() {
      this._touchStartEventObject = null;
      return true;
    },

    /**
        * Process a native scroll event.
        *
        * @param {JQuery.Event} event
        */
    _onScrollEvent: function _onScrollEvent(event) {
      event = $.event.fix(event);
      return this._preventScroll(event);
    },

    /**
        * Process a native keydown event.
        *
        * @param {JQuery.Event} event
        */
    _onKeyDown: function _onKeyDown(event) {
      event = $.event.fix(event);
      if (!this._preventScrollOnKeys[event.keyCode]) {
        return;
      }
      var $target = $(event.target);
      if ($target.is(this._ignoreKeysOnElementsMatching)) {
        return;
      }
      return this._preventScroll(event);
    },

    /**
        * Process jquery event object.
        *
        * @param {JQuery.Event} event
        */
    _preventScroll: function _preventScroll(event) {
      var isGesture = event.touches && event.touches.length > 1;
      if (isGesture) {
        // allow multiple finger gestures through
        // this will unfortunately allow two finger background scrolling on mobile devices
        // one finger background scrolling will still be disabled
        return;
      }
      var $target = $(event.target);
      if (this._scrollDisabledElements.length) {
        var scrollingParent = this._getScrollingParent(event, $target);
        if (scrollingParent.filter(this._scrollDisabledElements).length === 0) {
          this.$window.scroll();
          return;
        }
      }
      event.preventDefault();
      return false;
    },

    /**
        * Return the parent which will be scrolling from the current scroll event.
        *
        * @param {JQuery.Event} event
        * @param {Object} $target jQuery element object.
        */
    _getScrollingParent: function _getScrollingParent(event, $target) {
      var isTouchEvent = event.type === 'touchmove';
      var hasTouchStartEvent = this._touchStartEventObject && this._touchStartEventObject.originalEvent;
      if (isTouchEvent && !hasTouchStartEvent) {
        return $target;
      }
      var directionY = this._getScrollDirection(event);
      if (directionY === 'none') {
        return this.$body;
      }
      var parents = $target.parents();
      for (var i = 0, l = parents.length; i < l; i++) {
        var $parent = $(parents[i]);
        if ($parent.is('body')) {
          return this.$body;
        }
        if (!this._isScrollable($parent)) {
          continue;
        }
        if (!this._isScrolling($parent, directionY)) {
          continue;
        }
        return $parent;
      }
      return this.$body;
    },

    /**
        * Returns true if the specified target is scrollable.
        *
        * @param {Object} $target jQuery element object.
        * @returns {boolean}
        */
    _isScrollable: function _isScrollable($target) {
      var scrollType = $target.css('overflow-y');
      if (scrollType !== 'auto' && scrollType !== 'scroll') {
        return false;
      }
      var pointerEvents = $target.css('pointer-events');
      if (pointerEvents === 'none') {
        return false;
      }
      return true;
    },

    /**
        * Returns true if the specified target is the scrolling target.
        *
        * @param {Object} $target jQuery element object.
        * @param {string} directionY 'none' | 'up' | 'down'
        *
        * @returns {boolean}
        */
    _isScrolling: function _isScrolling($target, directionY) {
      var scrollTop = Math.ceil($target.scrollTop());
      var innerHeight = $target.outerHeight();
      var scrollHeight = $target[0].scrollHeight;
      var hasScrollingSpace = false;
      switch (directionY) {
        case 'down':
          hasScrollingSpace = scrollTop + innerHeight < scrollHeight;
          if (hasScrollingSpace) {
            return true;
          }
          break;
        case 'up':
          hasScrollingSpace = scrollTop > 0;
          if (hasScrollingSpace) {
            return true;
          }
          break;}

      return false;
    },

    /**
        * Returns the vertical direction of scroll.
        *
        * @param {JQuery.Event} event
        * @returns {string} 'none' | 'up' | 'down'
        */
    _getScrollDirection: function _getScrollDirection(event) {
      var deltaY = this._getScrollDelta(event);
      if (deltaY === 0) {
        return 'none';
      }
      return deltaY > 0 ? 'up' : 'down';
    },

    /**
        * Returns the number of pixels which is intended to be scrolled.
        *
        * @param {JQuery.Event} event
        * @returns {number}
        */
    _getScrollDelta: function _getScrollDelta(event) {
      var deltaY = 0;
      var isTouchEvent = event.type === 'touchmove';
      var originalEvent = event.originalEvent;
      if (isTouchEvent) {
        // Touch events
        // iOS previous + current scroll pos
        var startOriginalEvent = this._touchStartEventObject.originalEvent;
        var currentY = originalEvent.pageY;
        var previousY = startOriginalEvent.pageY;
        if (currentY === 0 || currentY === previousY) {
          // Android chrome current scroll pos
          currentY = originalEvent.touches[0].pageY;
          previousY = startOriginalEvent.touches[0].pageY;
        }
        // Touch: delta calculated from touchstart pos vs touchmove pos
        deltaY = currentY - previousY;
      } else {
        // Mouse events
        var hasDeltaY = originalEvent.wheelDeltaY || originalEvent.deltaY !== undefined;
        if (hasDeltaY) {
          // Desktop: Firefox & IE delta inverted
          deltaY = -originalEvent.deltaY;
        } else {
          // Desktop: Chrome & Safari wheel delta
          deltaY = originalEvent.wheelDelta || 0;
        }
      }
      return deltaY;
    },

    /**
        * Stop listening for events to block.
        */
    _stop: function _stop() {
      if (!this._isRunning) {
        return;
      }
      this._isRunning = false;
      window.removeEventListener('touchstart', this._onTouchStart); // mobile
      window.removeEventListener('touchend', this._onTouchEnd); // mobile
      // shouldn't need to supply 3rd arg when removing, but IE11 won't remove the event listener if you don't - see https://github.com/adaptlearning/adapt_framework/issues/2466
      window.removeEventListener('touchmove', this._onScrollEvent, { passive: false }); // mobile
      window.removeEventListener('wheel', this._onScrollEvent, { passive: false });
      document.removeEventListener('wheel', this._onScrollEvent, { passive: false });
      document.removeEventListener('keydown', this._onKeyDown);
    } });



  return Scroll;

});

define('core/js/a11y/wrapFocus', [
'core/js/adapt'],
function (Adapt) {

  /**
                   * Controller for managing tab wrapping for popups.
                   * @class
                   */
  var WrapFocus = Backbone.Controller.extend({

    initialize: function initialize() {
      _.bindAll(this, '_onWrapAround');
      this.listenTo(Adapt, {
        'accessibility:ready': this._attachEventListeners });

    },

    _attachEventListeners: function _attachEventListeners() {
      var config = Adapt.a11y.config;
      $('body').on('click focus', config._options._focusguard, this._onWrapAround);
    },

    /**
        * If click or focus is received on any element with the focusguard class,
        * loop focus around to the top of the document.
        *
        * @param {JQuery.Event} event
        */
    _onWrapAround: function _onWrapAround(event) {
      var config = Adapt.a11y.config;
      if (!config._isEnabled || !config._options._isPopupWrapFocusEnabled) {
        return;
      }
      event.preventDefault();
      event.stopPropagation();
      Adapt.a11y.focusFirst('body', { defer: false });
    } });



  return WrapFocus;

});

define('core/js/a11y/popup', [
'core/js/adapt'],
function (Adapt) {

  /**
                   * Tabindex and aria-hidden manager for popups.
                   * @class
                   */
  var Popup = Backbone.Controller.extend({

    /**
                                            * List of elements which form the base at which elements are generally tabbale
                                            * and aria-hidden='false'.
                                            *
                                            * @type {Array<Object>}
                                            */
    _floorStack: [$('body')],
    /**
                               * List of elements to return the focus to once leaving each stack.
                               *
                               * @type {Array<Object>}
                               */
    _focusStack: [],
    /**
                      * Hash of tabindex states for each tabbable element in the popup stack.
                      *
                      * @type {Object}
                      */
    _tabIndexes: {},
    /**
                      * Hash of aria-hidden states for each tabbable element in the popup stack.
                      *
                      * @type {Object}
                      */
    _ariaHiddens: {},
    /**
                       * Incremented unique ids for elements belonging to a popup stack with saved
                       * states,
                       */
    _elementUIDIndex: 0,

    initialize: function initialize() {
      this.listenTo(Adapt, {
        'popup:opened': function popupOpened($element, ignoreInternalTrigger) {
          if (ignoreInternalTrigger) {
            return;
          }
          Adapt.a11y.log.deprecated('Adapt.trigger("popup:opened", $element) is replaced with Adapt.a11y.popupOpened($element);');
          this.opened($element, true);
        },
        'popup:closed': function popupClosed($target, ignoreInternalTrigger) {
          if (ignoreInternalTrigger) {
            return;
          }
          Adapt.a11y.log.deprecated('Adapt.trigger("popup:closed", $target) is replaced with Adapt.a11y.popupClosed($target);');
          this.closed($target, true);
        } });

    },

    /**
        * Reorganise the tabindex and aria-hidden attributes in the document to
        * restrict user interaction to the element specified.
        *
        * @param {Object} [$popupElement] Element encapulating the popup.
        * @returns {Object} Returns `Adapt.a11y._popup`.
        */
    opened: function opened($popupElement, silent) {
      // Capture currently active element or element specified
      $popupElement = $popupElement || $(document.activeElement);
      this._addPopupLayer($popupElement);
      if (!silent) {
        Adapt.trigger('popup:opened', $popupElement, true);
      }
      return this;
    },

    /**
        * Restrict tabbing and screen reader access to selected element only.
        *
        * @param {Object} $popupElement Element encapulating the popup.
        */
    _addPopupLayer: function _addPopupLayer($popupElement) {
      $popupElement = $($popupElement);
      var config = Adapt.a11y.config;
      if (!config._isEnabled || !config._options._isPopupManagementEnabled || $popupElement.length === 0) {
        return $popupElement;
      }
      this._floorStack.push($popupElement);
      this._focusStack.push($(document.activeElement));
      var $elements = $(config._options._tabbableElements).filter(config._options._tabbableElementsExcludes);
      var $branch = $popupElement.add($popupElement.parents());
      var $siblings = $branch.siblings().filter(config._options._tabbableElementsExcludes);
      $elements = $elements.add($siblings);
      $elements.each(function (index, item) {
        var $item = $(item);
        var elementUID;
        if (typeof item.a11y_uid === 'undefined') {
          item.a11y_uid = 'UID' + ++this._elementUIDIndex;
        }
        elementUID = item.a11y_uid;
        if (this._tabIndexes[elementUID] === undefined) {
          this._tabIndexes[elementUID] = [];
        }
        if (this._ariaHiddens[elementUID] === undefined) {
          this._ariaHiddens[elementUID] = [];
        }
        var tabindex = $item.attr('tabindex');
        var ariaHidden = $item.attr('aria-hidden');
        this._tabIndexes[elementUID].push(tabindex === undefined ? '' : tabindex);
        this._ariaHiddens[elementUID].push(ariaHidden === undefined ? '' : ariaHidden);
        if (config._options._isPopupTabIndexManagementEnabled) {
          $item.attr('tabindex', -1);
        }
        if (config._options._isPopupAriaHiddenManagementEnabled) {
          $item.attr('aria-hidden', true);
        }
      }.bind(this));
      var $items = $popupElement.find(config._options._tabbableElements).filter(config._options._tabbableElementsExcludes);
      if (config._options._isPopupTabIndexManagementEnabled) {
        $items.attr('tabindex', 0);
      }
      if (config._options._isPopupAriaHiddenManagementEnabled) {
        $items.
        removeAttr('aria-hidden').
        removeClass('aria-hidden').
        parents(config._options._ariaHiddenExcludes).
        removeAttr('aria-hidden').
        removeClass('aria-hidden');
      }
    },

    /**
        * Close the last popup on the stack, restoring tabindex and aria-hidden
        * attributes.
        *
        * @param {Object} [$focusElement] Element at which to move focus.
        * @returns {Object} Returns `Adapt.a11y._popup`.
        */
    closed: function closed($focusElement, silent) {
      var $previousFocusElement = this._removeLastPopupLayer();
      $focusElement = $focusElement || $previousFocusElement || $('body');
      if (!silent) {
        Adapt.trigger('popup:closed', $focusElement, true);
      }
      Adapt.a11y.focusFirst($($focusElement));
      return this;
    },

    /**
        * Restores tabbing and screen reader access to the state before the last
        * `_addPopupLayer` call.
        *
        * @returns {Object} Returns previously active element.
        */
    _removeLastPopupLayer: function _removeLastPopupLayer() {
      var config = Adapt.a11y.config;
      if (!config._isEnabled || !config._options._isPopupManagementEnabled) {
        return $(document.activeElement);
      }
      // the body layer is the first element and must always exist
      if (this._floorStack.length <= 1) {
        return;
      }
      this._floorStack.pop();
      $(config._options._tabbableElements).filter(config._options._tabbableElementsExcludes).each(function (index, item) {
        var $item = $(item);
        var previousTabIndex = '';
        var previousAriaHidden = '';
        var elementUID;
        if (typeof item.a11y_uid === 'undefined') {
          // assign element a unique id
          item.a11y_uid = 'UID' + ++this._elementUIDIndex;
        }
        elementUID = item.a11y_uid;
        if (this._tabIndexes[elementUID] !== undefined && this._tabIndexes[elementUID].length !== 0) {
          // get previous tabindex if saved
          previousTabIndex = this._tabIndexes[elementUID].pop();
          previousAriaHidden = this._ariaHiddens[elementUID].pop();
        }
        if (this._tabIndexes[elementUID] !== undefined && this._tabIndexes[elementUID].length === 0) {
          // delete element tabindex store if empty
          delete this._tabIndexes[elementUID];
          delete this._ariaHiddens[elementUID];
        }
        if (config._options._isPopupTabIndexManagementEnabled) {
          if (previousTabIndex === '') {
            $item.removeAttr('tabindex');
          } else {
            $item.attr({
              'tabindex': previousTabIndex });

          }
        }
        if (config._options._isPopupAriaHiddenManagementEnabled) {
          if (previousAriaHidden === '') {
            $item.removeAttr('aria-hidden');
          } else {
            $item.attr({
              'aria-hidden': previousAriaHidden });

          }
        }
      }.bind(this));
      return document.activeElement = this._focusStack.pop();
    },

    /**
        * When a popup is open, this function makes it possible to swap the element
        * that should receive focus on popup close.
        *
        * @param {Object} $focusElement Set a new element to focus on.
        * @returns {Object} Returns previously set focus element.
        */
    setCloseTo: function setCloseTo($focusElement) {
      var $original = this._focusStack.pop();
      this._focusStack.push($focusElement);
      return $original;
    } });



  return Popup;

});

define('core/js/a11y/deprecated', [
'core/js/adapt'],
function (Adapt) {

  /**
                   * The old API is rerouted to the new API with warnings.
                   */

  _.extend($.fn, {

    isFixedPostion: function isFixedPostion() {
      Adapt.a11y.log.removed('$("..").isFixedPostion was unneeded and has been removed, let us know if you need it back.');
      return false;
    },

    a11y_aria_label: function a11y_aria_label() {
      Adapt.a11y.log.removed('$("..").a11y_aria_label was incorrect behaviour.');
      return this;
    },

    limitedScrollTo: function limitedScrollTo() {
      Adapt.a11y.log.removed('$.limitedScrollTo had no impact on the screen reader cursor.');
      return this;
    },

    a11y_text: function a11y_text() {
      Adapt.a11y.log.removed('a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/');
      return this;
    },

    a11y_selected: function a11y_selected() {
      Adapt.a11y.log.removed('$("..").a11y_selected is removed. Please use aria-live instead.');
      return this;
    },

    a11y_on: function a11y_on(isOn) {
      Adapt.a11y.log.deprecated('$("..").a11y_on, use Adapt.a11y.findTabbable($element); and Adapt.a11y.toggleAccessible($elements, isAccessible); instead.');
      var $tabbable = Adapt.a11y.findTabbable(this);
      Adapt.a11y.toggleAccessible($tabbable, isOn);
      return this;
    },

    a11y_only: function a11y_only() {
      Adapt.a11y.log.removed('$("..").a11y_only, use Adapt.a11y.popupOpened($popupElement); instead.');
      return this;
    },

    scrollDisable: function scrollDisable() {
      if (Adapt.a11y.config._options._isScrollDisableEnabled === false) {
        return this;
      }
      Adapt.a11y.log.deprecated('$("..").scrollDisable, use Adapt.a11y.scrollDisable($elements); instead.');
      Adapt.a11y.scrollDisable(this);
      return this;
    },

    scrollEnable: function scrollEnable() {
      if (Adapt.a11y.config._options._isScrollDisableEnabled === false) {
        return this;
      }
      Adapt.a11y.log.deprecated('$("..").scrollEnable, use Adapt.a11y.scrollEnable($elements); instead.');
      Adapt.a11y.scrollEnable(this);
      return this;
    },

    a11y_popup: function a11y_popup() {
      Adapt.a11y.log.deprecated('$("..").a11y_popup, use Adapt.a11y.popupOpened($popupElement); instead.');
      return Adapt.a11y.popupOpened(this);
    },

    a11y_cntrl: function a11y_cntrl(isOn, withDisabled) {
      Adapt.a11y.log.deprecated('$("..").a11y_cntrl, use Adapt.a11y.toggleAccessible($elements, isAccessible); and if needed Adapt.a11y.toggleEnabled($elements, isEnabled); instead.');
      Adapt.a11y.toggleAccessible(this, isOn);
      if (withDisabled) Adapt.a11y.toggleEnabled(this, isOn);
      return this;
    },

    a11y_cntrl_enabled: function a11y_cntrl_enabled(isOn) {
      Adapt.a11y.log.deprecated('$("..").a11y_cntrl_enabled, use Adapt.a11y.toggleAccessibleEnabled($elements, isAccessibleEnabled); instead.');
      Adapt.a11y.toggleAccessibleEnabled(this, isOn);
      return this;
    },

    isReadable: function isReadable() {
      Adapt.a11y.log.deprecated('$("..").isReadable, use Adapt.a11y.isReadable($element); instead.');
      return Adapt.a11y.isReadable(this);
    },

    findForward: function findForward(selector) {
      Adapt.a11y.log.removed('$("..").findForward has been removed as the use cases are very small, let us know if you need it back.');
      return Adapt.a11y._findFirstForward(this, selector);
    },

    findWalk: function findWalk(selector) {
      Adapt.a11y.log.removed('$("..").findWalk has been removed as the use cases are very small, let us know if you need it back.');
      return Adapt.a11y._findFindForwardDescendant(this, selector);
    },

    focusNoScroll: function focusNoScroll() {
      Adapt.a11y.log.deprecated('$("..").focusNoScroll, use Adapt.a11y.focus($element); instead.');
      return Adapt.a11y.focus(this);
    },

    focusNext: function focusNext(returnOnly) {
      Adapt.a11y.log.deprecated('$("..").focusNext, use Adapt.a11y.focusNext($element); or if needed Adapt.a11y.findFirstReadable($element); instead.');
      if (returnOnly) {
        return Adapt.a11y.findFirstReadable(this);
      }
      return Adapt.a11y.focusNext(this);
    },

    focusOrNext: function focusOrNext(returnOnly) {
      Adapt.a11y.log.deprecated('$("..").focusOrNext, use Adapt.a11y.focusFirst($element); or if needed Adapt.a11y.findFirstReadable($element); or Adapt.a11y.isReadable($element); instead.');
      if (returnOnly) {
        if (Adapt.a11y.isReadable(this)) return this;
        return Adapt.a11y.findFirstReadable(this);
      }
      return Adapt.a11y.focusFirst(this);
    },

    a11y_focus: function a11y_focus(dontDefer) {
      Adapt.a11y.log.deprecated('$("..").a11y_focus, use Adapt.a11y.focusFirst($element, { defer: true }); instead.');
      Adapt.a11y.focusFirst(this, { defer: !dontDefer });
      return this;
    } });



  _.extend($, {

    a11y_alert: function a11y_alert() {
      Adapt.a11y.log.removed('$.a11y_alert is removed. Please use aria-live instead.');
      return this;
    },

    a11y_update: function a11y_update() {
      Adapt.a11y.log.removed('a11y_update is no longer required.');
      return this;
    },

    a11y_text: function a11y_text(text) {
      Adapt.a11y.log.removed('a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/');
      return text;
    },

    a11y_on: function a11y_on(isOn, selector) {
      Adapt.a11y.log.deprecated('$("..").a11y_on, use Adapt.a11y.toggleHidden($elements, isHidden); instead.');
      return Adapt.a11y.toggleHidden(selector, !isOn);
    },

    a11y_popdown: function a11y_popdown($focusTarget) {
      Adapt.a11y.log.removed('$.a11y_popdown, use Adapt.a11y.popupClosed($focusTarget); instead.');
      return Adapt.a11y.popupClosed($focusTarget);
    },

    a11y_focus: function a11y_focus(dontDefer) {
      Adapt.a11y.log.deprecated('$.a11y_focus, use Adapt.a11y.focusFirst("body", { defer: true }); instead.');
      Adapt.a11y.focusFirst('body', { defer: !dontDefer });
      return this;
    },

    a11y_normalize: function a11y_normalize(html) {
      Adapt.a11y.log.deprecated('$.a11y_normalize, use Adapt.a11y.normalize("html"); instead.');
      return Adapt.a11y.normalize(html);
    },

    a11y_remove_breaks: function a11y_remove_breaks(html) {
      Adapt.a11y.log.deprecated('$.a11y_remove_breaks, use Adapt.a11y.removeBreaks("html"); instead.');
      return Adapt.a11y.removeBreaks(html);
    } });



});

define('core/js/a11y', [
'core/js/adapt',
'./a11y/browserFocus',
'./a11y/focusOptions',
'./a11y/keyboardFocusOutline',
'./a11y/log',
'./a11y/scroll',
'./a11y/wrapFocus',
'./a11y/popup',
'./a11y/deprecated'],
function (Adapt, BrowserFocus, FocusOptions, KeyboardFocusOutline, Log, Scroll, WrapFocus, Popup) {

  var A11y = Backbone.Controller.extend({

    $html: $('html'),
    _htmlCharRegex: /&.*;/g,

    config: null,
    defaults: {

      _isFocusOutlineKeyboardOnlyEnabled: true,
      /**
                                                 * `_isFocusOutlineDisabled` ignores `_isEnabled` and can be used when all other
                                                 * accessibility features have been disabled.
                                                 */
      _isFocusOutlineDisabled: false,
      _isFocusAssignmentEnabled: true,
      _isFocusOnClickEnabled: true,
      _isFocusNextOnDisabled: true,
      _isScrollDisableEnabled: true,
      _isAriaHiddenManagementEnabled: true,
      _isPopupManagementEnabled: true,
      _isPopupWrapFocusEnabled: true,
      _isPopupAriaHiddenManagementEnabled: true,
      _isPopupTabIndexManagementEnabled: true,
      /**
                                                * Do not change aria-hidden on these elements.
                                                */
      _ariaHiddenExcludes: ':not(#wrapper):not(body)',
      _tabbableElements: 'a,button,input,select,textarea,[tabindex]:not([data-a11y-force-focus])',
      _focusOutlineKeyboardOnlyIgnore: 'input,textarea',
      /**
                                                          * Designate these elements as not tabbable.
                                                          */
      _tabbableElementsExcludes: ':not(.a11y-ignore):not([data-a11y-force-focus])',
      _focusableElements: 'a,button,input,select,textarea,[tabindex],label',
      _readableElements: '[role=heading],[aria-label],[aria-labelledby],[alt]',
      /**
                                                                                 * Selector for elements which cause tab wrapping.
                                                                                 */
      _focusguard: '.a11y-focusguard',
      /**
                                        * Specifies all stylistic elements.
                                        */
      _wrapStyleElements: 'b,i,abbr,strong,em,small,sub,sup,ins,del,mark,zw,nb',

      /**
                                                                                  * Logging settings
                                                                                  */
      _warnFirstOnly: true,
      _warn: true },



    _browserFocus: new BrowserFocus(),
    _keyboardFocusOutline: new KeyboardFocusOutline(),
    _wrapFocus: new WrapFocus(),
    _popup: new Popup(),
    _scroll: new Scroll(),

    log: new Log(),

    initialize: function initialize() {
      this._removeLegacyElements();
      this.listenToOnce(Adapt, {
        'app:dataLoaded': this._onDataLoaded,
        'navigationView:postRender': this._removeLegacyElements },
      this);
      Adapt.on('device:changed', this._setupNoSelect);
      this.listenTo(Adapt, {
        'router:location': this._onNavigationStart,
        'contentObjectView:ready router:plugin': this._onNavigationEnd });

    },

    _onDataLoaded: function _onDataLoaded() {
      this.config = Adapt.config.get('_accessibility');
      this.config._isActive = false;
      this.config._options = _.defaults(this.config._options || {}, this.defaults);
      Adapt.offlineStorage.set('a11y', false);
      this.$html.toggleClass('has-accessibility', this.isEnabled());
      this._setupNoSelect();
      this._addFocuserDiv();
      if (this._isReady) {
        return;
      }
      this._isReady = true;
      Adapt.trigger('accessibility:ready');
    },

    _setupNoSelect: function _setupNoSelect() {
      if (!this.config || !this.config._disableTextSelectOnClasses) {
        return;
      }
      var classes = this.config._disableTextSelectOnClasses.split(' ');
      var isMatch = false;
      for (var i = 0, item; item = classes[i++];) {
        if (this.$html.is(item)) {
          isMatch = true;
          break;
        }
      }
      this.$html.toggleClass('u-no-select', isMatch);
    },

    _addFocuserDiv: function _addFocuserDiv() {
      if ($('#a11y-focuser').length) {
        return;
      }
      $('body').append($('<div id="a11y-focuser" class="a11y-ignore" tabindex="-1" role="presentation">&nbsp;</div>'));
    },

    _removeLegacyElements: function _removeLegacyElements() {
      var $legacyElements = $('body').children('#accessibility-toggle, #accessibility-instructions');
      var $navigationElements = $('.nav').find('#accessibility-toggle, #accessibility-instructions');
      if (!$legacyElements.length && !$navigationElements.length) {
        return;
      }
      Adapt.log.warn('REMOVED: #accessibility-toggle and #accessibility-instructions have been removed. Please remove them from all of your .html files.');
      $legacyElements.remove();
      $navigationElements.remove();
    },

    _onNavigationStart: function _onNavigationStart() {
      if (!this.isEnabled()) {
        return;
      }
      // Stop document reading
      _.defer(function () {
        Adapt.a11y.toggleHidden('.contentobject', true);
      });
    },

    _onNavigationEnd: function _onNavigationEnd(view) {
      // Prevent sub-menu items provoking behaviour
      if (view && view.model && view.model.get('_id') !== Adapt.location._currentId || !this.isEnabled()) {
        return;
      }
      // Allow document to be read
      Adapt.a11y.toggleHidden('.contentobject', false);
    },

    isActive: function isActive() {
      this.log.removed('Accessibility is now always active when enabled. Please unify your user experiences.');
      return false;
    },

    isEnabled: function isEnabled() {
      return this.config && this.config._isEnabled;
    },

    /**
        * Adds or removes `aria-hidden` attribute to elements.
        *
        * @param {Object|string|Array} $elements
        * @param {boolean} [isHidden=true]
        * @returns {Object} Returns `Adapt.a11y`
        */
    toggleHidden: function toggleHidden($elements, isHidden) {
      $elements = $($elements);
      var config = Adapt.a11y.config;
      if (!config._isEnabled || !config._options._isAriaHiddenManagementEnabled) {
        return this;
      }
      isHidden = isHidden === undefined ? true : isHidden;
      if (isHidden === true) {
        $elements.attr('aria-hidden', true);
      } else {
        $elements.removeAttr('aria-hidden');
      }
      return this;
    },

    /**
        * Adds or removes `aria-hidden` and `disabled` attributes and `disabled`
        * classes to elements.
        *
        * @param {Object|string|Array} $elements
        * @param {boolean} [isHidden=true]
        * @returns {Object} Returns `Adapt.a11y`
        */
    toggleAccessibleEnabled: function toggleAccessibleEnabled($elements, isAccessibleEnabled) {
      this.toggleAccessible($elements, isAccessibleEnabled);
      this.toggleEnabled($elements, isAccessibleEnabled);
      return this;
    },

    /**
        * Adds or removes `aria-hidden` attribute and disables `tabindex` on elements.
        *
        * @param {Object|string|Array} $elements
        * @param {boolean} [isReadable=true]
        * @returns {Object} Returns `Adapt.a11y`
        */
    toggleAccessible: function toggleAccessible($elements, isReadable) {
      $elements = $($elements);
      var config = Adapt.a11y.config;
      if (!config._isEnabled || !config._options._isAriaHiddenManagementEnabled || $elements.length === 0) {
        return this;
      }
      isReadable = isReadable === undefined ? true : isReadable;
      if (!isReadable) {
        $elements.attr({
          tabindex: '-1',
          'aria-hidden': 'true' }).
        addClass('aria-hidden');
      } else {
        $elements.removeAttr('aria-hidden tabindex').removeClass('aria-hidden');
        $elements.parents(config._options._ariaHiddenExcludes).removeAttr('aria-hidden').removeClass('aria-hidden');
      }
      return this;
    },

    /**
        * Adds or removes `disabled` attribute and `disabled` class.
        *
        * @param {Object|string|Array} $elements
        * @param {boolean} [isEnabled=true]
        * @returns {Object} Returns `Adapt.a11y`
        */
    toggleEnabled: function toggleEnabled($elements, isEnabled) {
      $elements = $($elements);
      if ($elements.length === 0) {
        return this;
      }
      isEnabled = isEnabled === undefined ? true : isEnabled;
      if (!isEnabled) {
        $elements.attr('disabled', 'disabled').addClass('is-disabled');
      } else {
        $elements.removeAttr('disabled').removeClass('is-disabled');
      }
      return this;
    },

    /**
        * Find the first tabbable element after the specified element.
        *
        * @param {Object|string|Array} $element
        * @returns {Object}
        */
    findFirstTabbable: function findFirstTabbable($element) {
      $element = $($element).first();
      return this._findFirstForward($element, this.isTabbable);
    },

    /**
        * Find the first readable element after the specified element.
        *
        * @param {Object|string|Array} $element
        * @returns {Object}
        */
    findFirstReadable: function findFirstReadable($element) {
      $element = $($element).first();
      return this._findFirstForward($element, this.isReadable);
    },

    /**
        * Find all tabbable elements in the specified element.
        *
        * @param {Object|string|Array} $element
        * @returns {Object}
        */
    findTabbable: function findTabbable($element) {
      var config = Adapt.a11y.config;
      return $($element).find(config._options._tabbableElements).filter(config._options._tabbableElementsExcludes);
    },

    /**
        * Find all readable elements in the specified element.
        *
        * @param {Object|string|Array} $element
        */
    findReadable: function findReadable($element) {
      return $($element).find('*').filter(function (index, element) {
        return this.isReadable(element);
      }.bind(this));
    },

    /**
        * Check if the element is natively or explicitly tabbable.
        *
        * @param {Object|string|Array} $element
        * @returns {boolean|undefined}
        */
    isTabbable: function isTabbable($element) {
      var config = Adapt.a11y.config;
      var value = $($element).is(config._options._tabbableElements).is(config._options._tabbableElementsExcludes);
      if (!value) {
        return undefined; // Allow _findForward to descend
      }
      return value;
    },

    /**
        * Check if the first item is readable by a screen reader.
        *
        * @param {Object|string|Array} $element
        * @param {boolean} [checkParents=true] Check if parents are inaccessible.
        * @returns {boolean}
        */
    isReadable: function isReadable($element, checkParents) {
      var config = Adapt.a11y.config;
      $element = $($element).first();
      checkParents = checkParents === undefined;

      var $branch = checkParents ?
      $element.add($element.parents()) :
      $element;

      var isNotVisible = _.find($branch.toArray(), function (item) {
        var $item = $(item);
        // make sure item is not explicitly invisible
        var isNotVisible = $item.css('display') === 'none' ||
        $item.css('visibility') === 'hidden' ||
        $item.attr('aria-hidden') === 'true';
        if (isNotVisible) {
          return true;
        }
      });
      if (isNotVisible) {
        return false;
      }

      // check that the component is natively tabbable or
      // will be knowingly read by a screen reader
      var hasNativeFocusOrIsScreenReadable = $element.is(config._options._focusableElements) ||
      $element.is(config._options._readableElements);
      if (hasNativeFocusOrIsScreenReadable) {
        return true;
      }
      var childNodes = $element[0].childNodes;
      for (var c = 0, cl = childNodes.length; c < cl; c++) {
        var childNode = childNodes[c];
        var isTextNode = childNode.nodeType === 3;
        if (!isTextNode) {
          continue;
        }
        var isOnlyWhiteSpace = /^\s*$/.test(childNode.nodeValue);
        if (isOnlyWhiteSpace) {
          continue;
        }
        return true;
      }
      return undefined; // Allows _findForward to decend.
    },

    /**
        * Find forward in the DOM, descending and ascending to move forward
        * as appropriate.
        *
        * If the selector is a function it should returns true, false or undefined.
        * Returning true matches the item and returns it. Returning false means do
        * not match or descend into this item, returning undefined means do not match,
        * but descend into this item.
        *
        * @param {Object|string|Array} $element
        * @param {string|function|undefined} selector
        * @returns {Object} Returns found descendant.
        */
    _findFirstForward: function _findFirstForward($element, selector) {
      $element = $($element).first();

      // make sure iterator is correct, use boolean or selector comparison
      // appropriately
      var iterator;
      switch (_typeof(selector)) {
        case 'string':
          // make selector iterator
          iterator = function iterator($tag) {
            return $tag.is(selector) || undefined;
          };
          break;
        case 'function':
          iterator = selector;
          break;
        case 'undefined':
          // find first next element
          iterator = Boolean;}


      if ($element.length === 0) {
        return $element.not('*');
      }

      // check children by walking the tree
      var $found = this._findFirstForwardDescendant($element, iterator);
      if ($found && $found.length) {
        return $found;
      }

      // check subsequent siblings
      var $nextSiblings = $element.nextAll().toArray();
      _.find($nextSiblings, function (sibling) {
        var $sibling = $(sibling);
        var value = iterator($sibling);

        // skip this sibling if explicitly instructed
        if (value === false) {
          return;
        }

        if (value) {
          // sibling matched
          $found = $sibling;
          return true;
        }

        // check parent sibling children by walking the tree
        $found = this._findFirstForwardDescendant($sibling, iterator);
        if ($found && $found.length) return true;
      }.bind(this));
      if ($found && $found.length) {
        return $found;
      }

      // move through parents towards the body element
      var $branch = $element.add($element.parents()).toArray().reverse();
      _.find($branch, function (parent) {
        var $parent = $(parent);
        if (iterator($parent) === false) {
          // skip this parent if explicitly instructed
          return false;
        }

        // move through parents nextAll siblings
        var $siblings = $parent.nextAll().toArray();
        return _.find($siblings, function (sibling) {
          var $sibling = $(sibling);
          var value = iterator($sibling);

          // skip this sibling if explicitly instructed
          if (value === false) {
            return;
          }

          if (value) {
            // sibling matched
            $found = $sibling;
            return true;
          }

          // check parent sibling children by walking the tree
          $found = this._findFirstForwardDescendant($sibling, iterator);
          if ($found && $found.length) {
            return true;
          }
        }.bind(this));
      }.bind(this));

      if (!$found || !$found.length) {
        return $element.not('*');
      }
      return $found;
    },

    /**
        * Find descendant in a DOM tree, work from selected to branch-end, through allowed
        * branch structures in hierarchy order
        *
        * If the selector is a function it should returns true, false or undefined.
        * Returning true matches the item and returns it. Returning false means do
        * not match or descend into this item, returning undefined means do not match,
        * but descend into this item.
        *
        * @param {Object|string|Array} $element jQuery element to start from.
        * @param {string|function|undefined} selector
        * @returns {Object} Returns found descendant.
        */
    _findFirstForwardDescendant: function _findFirstForwardDescendant($element, selector) {
      $element = $($element).first();

      // make sure iterator is correct, use boolean or selector comparison
      // appropriately
      var iterator;
      switch (_typeof(selector)) {
        case 'string':
          // make selector iterator
          iterator = function iterator($tag) {
            return $tag.is(selector) || undefined;
          };
          break;
        case 'function':
          iterator = selector;
          break;
        case 'undefined':
          // find first next element
          iterator = Boolean;}


      var $notFound = $element.not('*');
      if ($element.length === 0) {
        return $notFound;
      }

      // keep walked+passed children in a stack
      var stack = [{
        item: $element[0],
        value: undefined }];

      var stackIndexPosition = 0;
      var childIndexPosition = stackIndexPosition + 1;
      do {

        var stackEntry = stack[stackIndexPosition];
        var $stackItem = $(stackEntry.item);

        // check current item
        switch (stackEntry.value) {
          case true:
            return $stackItem;
          case false:
            return $notFound;}


        // get i stack children
        var $children = $stackItem.children().toArray();
        _.find($children, function (item) {
          var $item = $(item);
          var value = iterator($item);

          // item explicitly not allowed, don't add to stack,
          // skip children
          if (value === false) {
            return false;
          }

          // item passed or readable, add to stack before any parent
          // siblings
          stack.splice(childIndexPosition++, 0, {
            item: item,
            value: value });

        });

        // move to next stack item
        stackIndexPosition++;
        // keep place to inject children
        childIndexPosition = stackIndexPosition + 1;
      } while (stackIndexPosition < stack.length);

      return $notFound;
    },

    /**
        * Assign focus to the next readable element.
        *
        * @param {Object|string|Array} $element
        * @param {FocusOptions} options
        * @returns {Object} Returns `Adapt.a11y`
        */
    focusNext: function focusNext($element, options) {
      options = new FocusOptions(options);
      $element = $($element).first();
      $element = Adapt.a11y.findFirstReadable($element);
      this.focus($element, options);
      return this;
    },

    /**
        * Assign focus to either the specified element if it is readable or the
        * next readable element.
        *
        * @param {Object|string|Array} $element
        * @param {FocusOptions} options
        * @returns {Object} Returns `Adapt.a11y`
        */
    focusFirst: function focusFirst($element, options) {
      options = new FocusOptions(options);
      $element = $($element).first();
      if (Adapt.a11y.isReadable($element)) {
        this.focus($element, options);
        return $element;
      }
      $element = Adapt.a11y.findFirstReadable($element);
      this.focus($element, options);
      return $element;
    },

    /**
        * Force focus to the specified element with/without a defer or scroll.
        *
        * @param {Object|string|Array} $element
        * @param {FocusOptions} options
        * @returns {Object} Returns `Adapt.a11y`
        */
    focus: function focus($element, options) {
      options = new FocusOptions(options);
      $element = $($element).first();
      var config = Adapt.a11y.config;
      if (!config._isEnabled || !config._options._isFocusAssignmentEnabled || $element.length === 0) {
        return this;
      }
      function perform() {
        if (options.preventScroll) {
          var y = $(window).scrollTop();
          try {
            if ($element.attr('tabindex') === undefined) {
              $element.attr({
                'tabindex': '-1',
                'data-a11y-force-focus': 'true' });

            }
            $element[0].focus({
              preventScroll: true });

          } catch (e) {
            // Drop focus errors as only happens when the element
            // isn't attached to the DOM.
          }
          switch (Adapt.device.browser) {
            case 'internet explorer':
            case 'microsoft edge':
            case 'safari':
              // return to previous scroll position due to no support for preventScroll
              window.scrollTo(null, y);}

        } else {
          $element[0].focus();
        }
      }
      if (options.defer) {
        _.defer(function () {
          perform();
        });
      } else {
        perform();
      }
      return this;
    },

    /**
        * Used to convert html to text aria-labels.
        *
        * @param {string} htmls Any html strings.
        * @returns {string} Returns text without markup or html encoded characters.
        */
    normalize: function normalize(htmls) {
      var values = Array.prototype.slice.call(arguments, 0);
      values = values.filter(Boolean);
      values = values.filter(_.isString);
      htmls = values.join(' ');
      var text = $('<div>' + htmls + '</div>').text();
      // Remove all html encoded characters, such as &apos;
      return text.replace(this._htmlCharRegex, '');
    },

    /**
        * Removes all html tags except stylistic elements.
        * Useful for producing uninterrupted text for screen readers from
        * any html.
        *
        * @param  {string} htmls Any html strings.
        * @return {string} Returns html string without markup which would cause screen reader to pause.
        */
    removeBreaks: function removeBreaks(htmls) {
      var values = Array.prototype.slice.call(arguments, 0);
      values = values.filter(Boolean);
      values = values.filter(_.isString);
      htmls = values.join(' ');
      var $div = $('<div>' + htmls + '</div>');
      var stack = [$div[0]];
      var stackIndex = 0;
      var outputs = [];
      do {
        if (stack[stackIndex].childNodes.length) {
          var nodes = stack[stackIndex].childNodes;
          var usable = _.filter(nodes, function (node) {
            var isTextNode = node.nodeType === 3;
            if (isTextNode) {
              return true;
            }
            var isStyleElement = $(node).is(Adapt.a11y.config._options._wrapStyleElements);
            if (isStyleElement) {
              return true;
            }
            return false;
          });
          outputs.push.apply(outputs, usable);
          stack.push.apply(stack, nodes);
        }
        stackIndex++;
      } while (stackIndex < stack.length);
      var rtnText = '';
      outputs.forEach(function (item) {
        rtnText += item.outerHTML || item.textContent;
      });
      return rtnText;
    },

    /**
        * @param {Object|string|Array} $elements
        * @returns {Object} Returns `Adapt.a11y`
        */
    scrollEnable: function scrollEnable($elements) {
      this._scroll.enable($elements);
      return this;
    },

    /**
        * @param {Object|string|Array} $elements
        * @returns {Object} Returns `Adapt.a11y`
        */
    scrollDisable: function scrollDisable($elements) {
      this._scroll.disable($elements);
      return this;
    },

    /**
        * To apply accessibilty handling to a tag, isolating the user.
        *
        * @param {Object} $popupElement Element encapsulating the popup.
        * @returns {Object} Returns `Adapt.a11y`
        */
    popupOpened: function popupOpened($popupElement) {
      this._popup.opened($popupElement);
      return this;
    },

    /**
        * Remove the isolation applied with a call to `popupOpened`.
        *
        * @param {Object} [$focusElement] Element to move focus to.
        * @returns {Object} Returns `Adapt.a11y`
        */
    popupClosed: function popupClosed($focusElement) {
      this._popup.closed($focusElement);
      return this;
    },

    /**
        * When a popup is open, this function makes it possible to swap the element
        * that should receive focus on popup close.
        *
        * @param {Object} $focusElement Set a new element to focus on.
        * @returns {Object} Returns previously set focus element.
        */
    setPopupCloseTo: function setPopupCloseTo($focusElement) {
      return this._popup.setCloseTo($focusElement);
    } });



  return Adapt.a11y = new A11y();

});

define('core/js/accessibility', [
'core/js/adapt',
'./a11y'],
function (Adapt, a11y) {

  /**
                         * Backwards compatibility `Adapt.accessibility` reroutes to `Adapt.a11y`
                         * with a warning.
                         */
  Object.defineProperty(Adapt, 'accessibility', {

    get: function get() {
      a11y.log.deprecated('Adapt.accessibility has moved to Adapt.a11y');
      return Adapt.accessibility = a11y;
    } });



});

define('core/js/collections/adaptCollection', [
'core/js/adapt'],
function (Adapt) {var

  AdaptCollection = /*#__PURE__*/function (_Backbone$Collection) {"use strict";_inherits(AdaptCollection, _Backbone$Collection);var _super4 = _createSuper(AdaptCollection);function AdaptCollection() {_classCallCheck(this, AdaptCollection);return _super4.apply(this, arguments);}_createClass(AdaptCollection, [{ key: "initialize", value: function initialize(

      models, options) {
        this.once('reset', this.loadedData, this);
      } }, { key: "loadedData", value: function loadedData()

      {
        Adapt.trigger('adaptCollection:dataLoaded');
      } }]);return AdaptCollection;}(Backbone.Collection);



  return AdaptCollection;

});

define('core/js/enums/logLevelEnum', [], function () {

  // Used to determine if log call should be printed based on log level
  var LOG_LEVEL = ENUM([
  'DEBUG',
  'INFO',
  'WARN',
  'ERROR',
  'FATAL']);


  return LOG_LEVEL;

});

define('core/js/logging', [
'core/js/adapt',
'core/js/enums/logLevelEnum'],
function (Adapt, LOG_LEVEL) {var

  Logging = /*#__PURE__*/function (_Backbone$Controller3) {"use strict";_inherits(Logging, _Backbone$Controller3);var _super5 = _createSuper(Logging);function Logging() {_classCallCheck(this, Logging);return _super5.apply(this, arguments);}_createClass(Logging, [{ key: "initialize", value: function initialize()

      {
        this._config = {
          _isEnabled: true,
          _level: LOG_LEVEL.INFO.asLowerCase, // Default log level
          _console: true, // Log to console
          _warnFirstOnly: true // Show only first of identical removed and deprecated warnings
        };
        this._warned = {};
        this.listenToOnce(Adapt, 'configModel:dataLoaded', this.onLoadConfigData);
      } }, { key: "onLoadConfigData", value: function onLoadConfigData()

      {

        this.loadConfig();

        this.debug('Logging config loaded');

        this.trigger('log:ready');

      } }, { key: "loadConfig", value: function loadConfig()

      {

        if (Adapt.config.has('_logging')) {
          this._config = Adapt.config.get('_logging');
        }

        this.checkQueryStringOverride();

      } }, { key: "checkQueryStringOverride", value: function checkQueryStringOverride()

      {

        // Override default log level with level present in query string
        var matches = window.location.search.match(/[?&]loglevel=([a-z]*)/i);
        if (!matches || matches.length < 2) return;

        var override = LOG_LEVEL(matches[1].toUpperCase());
        if (!override) return;

        this._config._level = override.asLowerCase;
        this.debug('Loglevel override in query string:', this._config._level);

      } }, { key: "debug", value: function debug()

      {for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {args[_key4] = arguments[_key4];}
        this._log(LOG_LEVEL.DEBUG, args);
      } }, { key: "info", value: function info()

      {for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {args[_key5] = arguments[_key5];}
        this._log(LOG_LEVEL.INFO, args);
      } }, { key: "warn", value: function warn()

      {for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {args[_key6] = arguments[_key6];}
        this._log(LOG_LEVEL.WARN, args);
      } }, { key: "error", value: function error()

      {for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {args[_key7] = arguments[_key7];}
        this._log(LOG_LEVEL.ERROR, args);
      } }, { key: "fatal", value: function fatal()

      {for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {args[_key8] = arguments[_key8];}
        this._log(LOG_LEVEL.FATAL, args);
      } }, { key: "removed", value: function removed()

      {for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {args[_key9] = arguments[_key9];}
        args = ['REMOVED'].concat(args);
        this.warnOnce.apply(this, _toConsumableArray(args));
      } }, { key: "deprecated", value: function deprecated()

      {for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {args[_key10] = arguments[_key10];}
        args = ['DEPRECATED'].concat(args);
        this.warnOnce.apply(this, _toConsumableArray(args));
      } }, { key: "warnOnce", value: function warnOnce()

      {for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {args[_key11] = arguments[_key11];}
        if (this._hasWarned(args)) {
          return;
        }
        this._log(LOG_LEVEL.WARN, args);
      } }, { key: "_log", value: function _log(

      level, data) {

        var isEnabled = this._config._isEnabled;
        if (!isEnabled) return;

        var configLevel = LOG_LEVEL(this._config._level.toUpperCase());

        var isLogLevelAllowed = level >= configLevel;
        if (!isLogLevelAllowed) return;

        this._logToConsole(level, data);

        // Allow error reporting plugins to hook and report to logging systems
        this.trigger('log', level, data);
        this.trigger('log:' + level.asLowerCase, level, data);

      } }, { key: "_logToConsole", value: function _logToConsole(

      level, data) {

        var shouldLogToConsole = this._config._console;
        if (!shouldLogToConsole) return;

        var log = [level.asUpperCase + ':'];
        data && log.push.apply(log, _toConsumableArray(data));

        // is there a matching console method we can use e.g. console.error()?
        if (console[level.asLowerCase]) {var _console;
          (_console = console)[level.asLowerCase].apply(_console, log);
        } else {var _console2;
          (_console2 = console).log.apply(_console2, log);
        }
      } }, { key: "_hasWarned", value: function _hasWarned(

      args) {
        if (!this._config._warnFirstOnly) {
          return false;
        }
        var hash = args.map(String).join(':');
        if (this._warned[hash]) {
          return true;
        }
        this._warned[hash] = true;
        return false;
      } }]);return Logging;}(Backbone.Controller);



  return Adapt.log = new Logging();

});

define('core/js/models/buildModel', [
'core/js/adapt',
'core/js/logging'],
function (Adapt) {var

  BuildModel = /*#__PURE__*/function (_Backbone$Model2) {"use strict";_inherits(BuildModel, _Backbone$Model2);var _super6 = _createSuper(BuildModel);function BuildModel() {_classCallCheck(this, BuildModel);return _super6.apply(this, arguments);}_createClass(BuildModel, [{ key: "defaults", value: function defaults()

      {
        return {
          jsonext: 'json' };

      } }, { key: "initialize", value: function initialize(

      attrs, options) {var _this13 = this;
        this.url = options.url;
        // Fetch data & if successful trigger event to enable plugins to stop course files loading
        // Then check if course files can load
        // 'configModel:loadCourseData' event starts the core content collections and models being fetched
        this.fetch({
          success: function success() {_newArrowCheck(this, _this13);
            this.isLoaded = true;
            Adapt.trigger('buildModel:dataLoaded');
          }.bind(this),
          error: function error() {_newArrowCheck(this, _this13);
            console.log('Unable to load adapt/js/build.js');
            Adapt.trigger('buildModel:dataLoaded');
          }.bind(this) });

      } }, { key: "whenReady", value: function whenReady()

      {var _this14 = this;
        if (this.isLoaded) return Promise.resolve();
        return new Promise(function (resolve) {_newArrowCheck(this, _this14);
          Adapt.once('buildModel:dataLoaded', resolve);
        }.bind(this));
      } }]);return BuildModel;}(Backbone.Model);



  return BuildModel;

});

define('core/js/models/configModel', [
'core/js/adapt'],
function (Adapt) {var

  ConfigModel = /*#__PURE__*/function (_Backbone$Model3) {"use strict";_inherits(ConfigModel, _Backbone$Model3);var _super7 = _createSuper(ConfigModel);function ConfigModel() {_classCallCheck(this, ConfigModel);return _super7.apply(this, arguments);}_createClass(ConfigModel, [{ key: "defaults", value: function defaults()

      {
        return {
          screenSize: {
            large: 900,
            medium: 760,
            small: 520 },

          _forceRouteLocking: false,
          _canLoadData: true,
          _disableAnimation: false };

      } }, { key: "initialize", value: function initialize(

      attrs, options) {var _this15 = this;
        this.url = options.url;
        // Fetch data & if successful trigger event to enable plugins to stop course files loading
        // Then check if course files can load
        // 'configModel:loadCourseData' event starts the core content collections and models being fetched
        this.fetch({
          success: function success() {var _this16 = this;_newArrowCheck(this, _this15);
            Adapt.trigger('offlineStorage:prepare');
            Adapt.wait.queue(function () {_newArrowCheck(this, _this16);
              Adapt.trigger('configModel:dataLoaded');
              if (!this.get('_canLoadData')) return;
              Adapt.trigger('configModel:loadCourseData');
            }.bind(this));
          }.bind(this),
          error: function error() {_newArrowCheck(this, _this15);return console.log('Unable to load course/config.json');}.bind(this) });

      } }, { key: "loadData", value: function loadData()

      {} }]);return ConfigModel;}(Backbone.Model);



  return ConfigModel;

});

define('core/js/modelEvent', [], function () {

  var ModelEvent = Backbone.Controller.extend({

    type: null,
    target: null,
    value: null,
    canBubble: true,
    deepPath: null,
    timeStamp: null,

    /**
                      * @param {string} type Event name / type
                      * @param {Backbone.Model} target Origin model
                      * @param {*} [value] Any value that should be carried through on the event
                      */
    initialize: function initialize(type, target, value) {
      this.type = type;
      this.target = target;
      this.value = value;
      this.deepPath = [target];
    },

    stopPropagation: function stopPropagation() {
      this.canBubble = false;
    },

    addPath: function addPath(target) {
      this.deepPath.unshift(target);
    } });



  return ModelEvent;

});

define('core/js/models/adaptModel', [
'core/js/adapt',
'core/js/modelEvent',
'core/js/logging'],
function (Adapt, ModelEvent) {var

  AdaptModel = /*#__PURE__*/function (_Backbone$Model4) {"use strict";_inherits(AdaptModel, _Backbone$Model4);var _super8 = _createSuper(AdaptModel);function AdaptModel() {_classCallCheck(this, AdaptModel);return _super8.apply(this, arguments);}_createClass(AdaptModel, [{ key: "toJSON", value: function toJSON()

      {
        // Perform shallow clone
        var json = _.clone(this.attributes);
        // Remove deprecated values as they are not true json
        delete json._children;
        delete json._parent;
        // Perform deep clone
        return $.extend(true, {}, json);
      } }, { key: "get", value: function get(

      name) {
        switch (name) {
          case '_parent':
          case '_children':
            Adapt.log.deprecated("Use model.getChildren() or model.getParent() instead of model.get('_children') or model.get('_parent')");}

        return _get(_getPrototypeOf(AdaptModel.prototype), "get", this).call(this, name);
      } }, { key: "defaults", value: function defaults()

      {
        return {
          _canShowFeedback: true,
          _classes: '',
          _canReset: false,
          _canRequestChild: false,
          _isComplete: false,
          _isInteractionComplete: false,
          _isA11yRegionEnabled: false,
          _isA11yCompletionDescriptionEnabled: true,
          _requireCompletionOf: -1,
          _isEnabled: true,
          _isResetOnRevisit: false,
          _isAvailable: true,
          _isOptional: false,
          _isRendered: false,
          _isReady: false,
          _isVisible: true,
          _isLocked: false,
          _isHidden: false };

      } }, { key: "trackable", value: function trackable()

      {
        return [
        '_id',
        '_isComplete',
        '_isInteractionComplete'];

      } }, { key: "trackableType", value: function trackableType()

      {
        return [
        String,
        Boolean,
        Boolean];

      } }, { key: "bubblingEvents", value: function bubblingEvents()

      {
        return [
        'change:_isComplete',
        'change:_isInteractionComplete',
        'change:_isActive'];

      } }, { key: "setupModel", value: function setupModel()

      {var _this17 = this;
        if (this.hasManagedChildren) {
          this.setupChildListeners();
        }

        this.init();

        _.defer(function () {_newArrowCheck(this, _this17);
          if (this.hasManagedChildren) {
            this.checkCompletionStatus();

            this.checkInteractionCompletionStatus();

            this.checkLocking();
          }

          this.setupTrackables();

        }.bind(this));

      } }, { key: "setupTrackables", value: function setupTrackables()

      {var _this18 = this;

        // Limit state trigger calls and make state change callbacks batched-asynchronous
        var originalTrackableStateFunction = this.triggerTrackableState;
        this.triggerTrackableState = _.compose(
        function () {_newArrowCheck(this, _this18);

          // Flag that the function is awaiting trigger
          this.triggerTrackableState.isQueued = true;

        }.bind(this),
        _.debounce(function () {_newArrowCheck(this, _this18);

          // Trigger original function
          originalTrackableStateFunction.apply(this);

          // Unset waiting flag
          this.triggerTrackableState.isQueued = false;

        }.bind(this), 17));


        // Listen to model changes, trigger trackable state change when appropriate
        this.listenTo(this, 'change', function (_ref) {var _this19 = this;_newArrowCheck(this, _this18);var changed = _ref.changed;

          // Skip if trigger queued or adapt hasn't started yet
          if (this.triggerTrackableState.isQueued || !Adapt.attributes._isStarted) {
            return;
          }

          // Check that property is trackable
          var trackablePropertyNames = _.result(this, 'trackable', []);
          var changedPropertyNames = Object.keys(changed);
          var isTrackable = changedPropertyNames.find(function (item) {_newArrowCheck(this, _this19);
            return trackablePropertyNames.includes(item);
          }.bind(this));

          if (isTrackable) {
            // Trigger trackable state change
            this.triggerTrackableState();
          }
        }.bind(this));
      } }, { key: "setupChildListeners", value: function setupChildListeners()

      {
        var children = this.getChildren();
        if (!children.length) {
          return;
        }

        this.listenTo(children, {
          'all': this.onAll,
          'bubble': this.bubble,
          'change:_isReady': this.checkReadyStatus,
          'change:_isComplete': this.onIsComplete,
          'change:_isInteractionComplete': this.checkInteractionCompletionStatus });

      } }, { key: "init", value: function init()

      {} }, { key: "getTrackableState", value: function getTrackableState()

      {var _ref2;

        var trackable = this.resultExtend('trackable', []);
        var json = this.toJSON();

        var args = trackable;
        args.unshift(json);

        return (_ref2 = _).pick.apply(_ref2, _toConsumableArray(args));

      } }, { key: "setTrackableState", value: function setTrackableState(

      state) {var _ref3;

        var trackable = this.resultExtend('trackable', []);

        var args = trackable;
        args.unshift(state);

        state = (_ref3 = _).pick.apply(_ref3, _toConsumableArray(args));

        this.set(state);

        return this;

      } }, { key: "triggerTrackableState", value: function triggerTrackableState()

      {

        Adapt.trigger('state:change', this, this.getTrackableState());

      } }, { key: "reset", value: function reset(

      type, force) {
        if (!this.get('_canReset') && !force) return;

        type = type || true;

        switch (type) {
          case 'hard':case true:
            this.set({
              _isEnabled: true,
              _isComplete: false,
              _isInteractionComplete: false });

            break;
          case 'soft':
            this.set({
              _isEnabled: true,
              _isInteractionComplete: false });

            break;}

      }

      /**
         * Checks if any child models which have been _isRendered are not _isReady.
         * If all rendered child models are marked ready then this model will be
         * marked _isReady: true as well.
         * @param {AdaptModel} [model]
         * @param {boolean} [value]
         * @returns {boolean}
         */ }, { key: "checkReadyStatus", value: function checkReadyStatus(
      model, value) {var _this20 = this;
        if (value === false) {
          // Do not respond to _isReady: false as _isReady is unset throughout
          // the rendering process
          return false;
        }
        // Filter children based upon whether they are available
        // Check if any _isRendered: true children return _isReady: false
        // If not - set this model to _isReady: true
        var children = this.getAvailableChildModels();
        if (children.find(function (child) {_newArrowCheck(this, _this20);return child.get('_isReady') === false && child.get('_isRendered');}.bind(this))) {
          return false;
        }

        this.set('_isReady', true);
        return true;
      } }, { key: "setCompletionStatus", value: function setCompletionStatus()

      {
        if (!this.get('_isVisible')) return;

        this.set({
          _isComplete: true,
          _isInteractionComplete: true });

      } }, { key: "checkCompletionStatus", value: function checkCompletionStatus()

      {
        // defer to allow other change:_isComplete handlers to fire before cascading to parent
        Adapt.checkingCompletion();
        _.defer(this.checkCompletionStatusFor.bind(this), '_isComplete');
      } }, { key: "checkInteractionCompletionStatus", value: function checkInteractionCompletionStatus()

      {
        // defer to allow other change:_isInteractionComplete handlers to fire before cascading to parent
        Adapt.checkingCompletion();
        _.defer(this.checkCompletionStatusFor.bind(this), '_isInteractionComplete');
      }

      /**
         * Function for checking whether the supplied completion attribute should be set to true or false.
         * It iterates over our immediate children, checking the same completion attribute on any mandatory child
         * to see if enough/all of them them have been completed. If enough/all have, we set our attribute to true;
         * if not, we set it to false.
         * @param {string} [completionAttribute] Either '_isComplete' or '_isInteractionComplete'. Defaults to '_isComplete' if not supplied.
         */ }, { key: "checkCompletionStatusFor", value: function checkCompletionStatusFor()

      {var _this21 = this;var completionAttribute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '_isComplete';
        var completed = false;
        var children = this.getAvailableChildModels();
        var requireCompletionOf = this.get('_requireCompletionOf');

        if (requireCompletionOf === -1) {// a value of -1 indicates that ALL mandatory children must be completed
          completed = children.every(function (child) {_newArrowCheck(this, _this21);
            return child.get(completionAttribute) || child.get('_isOptional');
          }.bind(this));
        } else {
          completed = children.filter(function (child) {_newArrowCheck(this, _this21);
            return child.get(completionAttribute) && !child.get('_isOptional');
          }.bind(this)).length >= requireCompletionOf;
        }

        this.set(completionAttribute, completed);

        Adapt.checkedCompletion();
      }

      /**
         * Returns a string describing the type group of this model.
         * Strings should be lowercase and not plurlaized.
         * i.e. 'page', 'menu', 'contentobject', 'component', 'article', 'block'
         * Override in inheritance chain.
         * @returns {string}
         */ }, { key: "getTypeGroup", value: function getTypeGroup()
      {}

      /**
          * Returns true if this model is of the type group described.
          * Automatically manages pluralization typeGroup and matches lowercase only.
          * Pluralized typeGroups and uppercase characters in typeGroups are discouraged.
          * @param {string} type Type group name i.e. course, contentobject, article, block, component
          * @returns {boolean}
          */ }, { key: "isTypeGroup", value: function isTypeGroup(
      typeGroup) {
        var hasUpperCase = /[A-Z]+/.test(typeGroup);
        var isPluralized = typeGroup.slice(-1) === 's';
        var lowerCased = typeGroup.toLowerCase();
        var singular = isPluralized && lowerCased.slice(0, -1); // remove pluralization if ending in s
        var singularLowerCased = (singular || lowerCased).toLowerCase();
        if (isPluralized || hasUpperCase) {
          Adapt.log.deprecated("'".concat(typeGroup, "' appears pluralized or contains uppercase characters, suggest using the singular, lowercase type group '").concat(singularLowerCased, "'."));
        }
        var pluralizedLowerCaseTypes = [
        singularLowerCased,
        !isPluralized && "".concat(lowerCased, "s") // pluralize if not ending in s
        ].filter(Boolean);
        var typeGroups = this.getTypeGroups();
        if (_.intersection(pluralizedLowerCaseTypes, typeGroups).length) {
          return true;
        }
        return false;
      }

      /**
         * Returns an array of strings describing the model type groups.
         * All strings are lowercase and should not be pluralized.
         * i.e. ['course', 'menu', 'contentobject'], ['page', 'contentobject'], ['component']
         * @returns {[string]}
         */ }, { key: "getTypeGroups", value: function getTypeGroups()
      {var _this22 = this;
        if (this._typeGroups) return this._typeGroups;
        var typeGroups = [this.get('_type')];
        var parentClass = this;
        while (parentClass = Object.getPrototypeOf(parentClass)) {
          if (!parentClass.hasOwnProperty('getTypeGroup')) continue;
          typeGroups.push(parentClass.getTypeGroup.call(this));
        }
        return this._typeGroups = _.uniq(typeGroups.filter(Boolean).map(function (s) {_newArrowCheck(this, _this22);return s.toLowerCase();}.bind(this)));
      }

      /**
         * Searches the model's ancestors to find the first instance of the specified ancestor type
         * @param {string} [ancestorType] Valid values are 'course', 'pages', 'contentObjects', 'articles' or 'blocks'.
         * If left blank, the immediate ancestor (if there is one) is returned
         * @return {object} Reference to the model of the first ancestor of the specified type that's found - or `undefined` if none found
         */ }, { key: "findAncestor", value: function findAncestor(
      ancestorType) {
        var parent = this.getParent();
        if (!parent) return;
        if (!ancestorType || parent.isTypeGroup(ancestorType)) {
          return parent;
        }
        return parent.findAncestor(ancestorType);
      }

      /**
         * Returns all the descendant models of a specific type
         * @param {string} descendants Valid values are 'contentobject', 'page', 'menu', 'article', 'block', 'component', 'question'
         * @param {object} options an object that defines the search type and the properties/values to search on. Currently only the `where` search type (equivalent to `Backbone.Collection.where()`) is supported.
         * @param {object} options.where
         * @return {array}
         * @example
         * //find all available, non-optional components
         * this.findDescendantModels('component', { where: { _isAvailable: true, _isOptional: false }});
         */ }, { key: "findDescendantModels", value: function findDescendantModels(
      descendants, options) {var _this23 = this;
        var allDescendantsModels = this.getAllDescendantModels();
        var returnedDescendants = allDescendantsModels.filter(function (model) {_newArrowCheck(this, _this23);
          return model.isTypeGroup(descendants);
        }.bind(this));

        if (!options) {
          return returnedDescendants;
        }

        if (options.where) {
          return returnedDescendants.filter(function (descendant) {_newArrowCheck(this, _this23);
            for (var property in options.where) {
              var value = options.where[property];
              if (descendant.get(property) !== value) {
                return false;
              }
            }
            return true;
          }.bind(this));
        }
      }

      /**
         * Fetches the sub structure of a model as a flattened array
         *
         * Such that the tree:
         *  { a1: { b1: [ c1, c2 ], b2: [ c3, c4 ] }, a2: { b3: [ c5, c6 ] } }
         *
         * will become the array (parent first = false):
         *  [ c1, c2, b1, c3, c4, b2, a1, c5, c6, b3, a2 ]
         *
         * or (parent first = true):
         *  [ a1, b1, c1, c2, b2, c3, c4, a2, b3, c5, c6 ]
         *
         * This is useful when sequential operations are performed on the menu/page/article/block/component hierarchy.
         * @param {boolean} [isParentFirst]
         * @return {array}
         */ }, { key: "getAllDescendantModels", value: function getAllDescendantModels(
      isParentFirst) {var _this24 = this;

        var descendants = [];

        if (!this.hasManagedChildren) {
          return descendants;
        }

        var children = this.getChildren();

        children.models.forEach(function (child) {_newArrowCheck(this, _this24);

          if (!child.hasManagedChildren) {
            descendants.push(child);
            return;
          }

          var subDescendants = child.getAllDescendantModels(isParentFirst);
          if (isParentFirst === true) {
            descendants.push(child);
          }

          descendants.push.apply(descendants, _toConsumableArray(subDescendants));

          if (isParentFirst !== true) {
            descendants.push(child);
          }
        }.bind(this));

        return descendants;

      }

      /**
         * Returns a relative model from the Adapt hierarchy
         *
         * Such that in the tree:
         *  { a1: { b1: [ c1, c2 ], b2: [ c3, c4 ] }, a2: { b3: [ c5, c6 ] } }
         *
         *  c1.findRelativeModel('@block +1') = b2;
         *  c1.findRelativeModel('@component +4') = c5;
         *
         * @see Adapt.parseRelativeString for a description of relativeStrings
         * @param {string} relativeString
         * @param {object} options Search configuration settings
         * @param {boolean} options.limitParentId
         * @param {function} options.filter
         * @param {boolean} options.loop
         * @return {array}
         */ }, { key: "findRelativeModel", value: function findRelativeModel(
      relativeString) {var _this25 = this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        // return a model relative to the specified one if opinionated
        var rootModel = options.limitParentId ?
        Adapt.findById(options.limitParentId) :
        Adapt.course;

        var relativeDescriptor = Adapt.parseRelativeString(relativeString);
        var searchBackwards = relativeDescriptor.offset < 0;
        var moveBy = Math.abs(relativeDescriptor.offset);
        var movementCount = 0;

        var hasDescendantsOfType = Boolean(this.findDescendantModels(relativeDescriptor.type).length);
        if (hasDescendantsOfType) {
          // move by one less as first found is considered next
          // will find descendants on either side but not inside
          moveBy--;
        }

        var pageDescendants;
        if (searchBackwards) {var _pageDescendants;
          // parents first [p1,a1,b1,c1,c2,a2,b2,c3,c4,p2,a3,b3,c6,c7,a4,b4,c8,c9]
          pageDescendants = [rootModel];
          (_pageDescendants = pageDescendants).push.apply(_pageDescendants, _toConsumableArray(rootModel.getAllDescendantModels(true)));

          // reverse so that we don't need a forward and a backward iterating loop
          // reversed [c9,c8,b4,a4,c7,c6,b3,a3,p2,c4,c3,b2,a2,c2,c1,b1,a1,p1]
          pageDescendants.reverse();
        } else {
          // children first [c1,c2,b1,a1,c3,c4,b2,a2,p1,c6,c7,b3,a3,c8,c9,b4,a4,p2]
          pageDescendants = rootModel.getAllDescendantModels(false);
          pageDescendants.push(rootModel);
        }

        // filter if opinionated
        if (typeof options.filter === 'function') {
          pageDescendants = pageDescendants.filter(options.filter);
        }

        // find current index in array
        var modelId = this.get('_id');
        var modelIndex = pageDescendants.findIndex(function (pageDescendant) {_newArrowCheck(this, _this25);
          if (pageDescendant.get('_id') === modelId) {
            return true;
          }
          return false;
        }.bind(this));

        if (options.loop) {
          // normalize offset position to allow for overflow looping
          var totalOfType = pageDescendants.reduce(function (count, model) {_newArrowCheck(this, _this25);
            if (!model.isTypeGroup(relativeDescriptor.type)) return count;
            return ++count;
          }.bind(this), 0);
          // take the remainder after removing whole units of the type count
          moveBy = moveBy % totalOfType;
          // double up entries to allow for overflow looping
          pageDescendants = pageDescendants.concat(pageDescendants.slice(0));
        }

        for (var i = modelIndex, l = pageDescendants.length; i < l; i++) {
          var descendant = pageDescendants[i];
          if (descendant.isTypeGroup(relativeDescriptor.type)) {
            if (movementCount > moveBy) {
              // there is no descendant which matches this relativeString
              // probably looking for the descendant 0 in a parent
              break;
            }
            if (movementCount === moveBy) {
              return Adapt.findById(descendant.get('_id'));
            }
            movementCount++;
          }
        }

      } }, { key: "getChildren", value: function getChildren()





      {var _this26 = this;
        if (this._childrenCollection) {
          return this._childrenCollection;
        }

        var childrenCollection;

        if (!this.hasManagedChildren) {
          childrenCollection = new Backbone.Collection();
        } else {
          var id = this.get('_id');
          // Look up child by _parentId from Adapt.data
          var children = Adapt.data.filter(function (model) {_newArrowCheck(this, _this26);return model.get('_parentId') === id;}.bind(this));
          childrenCollection = new Backbone.Collection(children);
        }

        if (this.get('_type') === 'block' &&
        childrenCollection.length === 2 &&
        childrenCollection.models[0].get('_layout') !== 'left') {
          // Components may have a 'left' or 'right' _layout,
          // so ensure they appear in the correct order
          // Re-order component models to correct it
          childrenCollection.comparator = '_layout';
          childrenCollection.sort();
        }

        this.setChildren(childrenCollection);
        return this._childrenCollection;
      } }, { key: "setChildren", value: function setChildren(

      children) {
        this._childrenCollection = children;
        // Setup deprecated reference
        this.set('_children', children);
      } }, { key: "getAvailableChildModels", value: function getAvailableChildModels()

      {
        return this.getChildren().where({
          _isAvailable: true });

      } }, { key: "getParent", value: function getParent()

      {
        if (this._parentModel) {
          return this._parentModel;
        }
        var parentId = this.get('_parentId');
        if (!parentId) return;
        // Look up parent by id from Adapt.data
        this.setParent(Adapt.findById(parentId));
        return this._parentModel;
      } }, { key: "setParent", value: function setParent(

      parent) {
        this._parentModel = parent;
        this.set('_parentId', this._parentModel.get('_id'));
        // Set up deprecated reference
        this.set('_parent', this._parentModel);
      } }, { key: "getAncestorModels", value: function getAncestorModels(

      shouldIncludeChild) {
        var parents = [];
        var context = this;

        if (shouldIncludeChild) parents.push(context);

        while (context.has('_parentId')) {
          context = context.getParent();
          parents.push(context);
        }

        return parents.length ? parents : null;
      } }, { key: "getSiblings", value: function getSiblings(

      passSiblingsAndIncludeSelf) {var _this27 = this;
        var id = this.get('_id');
        var parentId = this.get('_parentId');
        var siblings;
        if (!passSiblingsAndIncludeSelf) {
          // returns a collection of siblings excluding self
          if (this._hasSiblingsAndSelf === false) {
            return this.get('_siblings');
          }
          siblings = Adapt.data.filter(function (model) {_newArrowCheck(this, _this27);
            return model.get('_parentId') === parentId &&
            model.get('_id') !== id;
          }.bind(this));

          this._hasSiblingsAndSelf = false;

        } else {
          // returns a collection of siblings including self
          if (this._hasSiblingsAndSelf) {
            return this.get('_siblings');
          }

          siblings = Adapt.data.filter(function (model) {_newArrowCheck(this, _this27);
            return model.get('_parentId') === parentId;
          }.bind(this));
          this._hasSiblingsAndSelf = true;
        }

        var siblingsCollection = new Backbone.Collection(siblings);
        this.set('_siblings', siblingsCollection);
        return siblingsCollection;
      }

      /**
         * @param  {string} key
         * @param  {any} value
         * @param  {Object} options
         */ }, { key: "setOnChildren", value: function setOnChildren()
      {var _this28 = this;for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {args[_key12] = arguments[_key12];}

        this.set.apply(this, args);

        if (!this.hasManagedChildren) return;

        var children = this.getChildren();
        children.models.forEach(function (child) {_newArrowCheck(this, _this28);return child.setOnChildren.apply(child, args);}.bind(this));

      }

      /**
         * @deprecated since v3.2.3 - please use `model.set('_isOptional', value)` instead
         */ }, { key: "setOptional", value: function setOptional(
      value) {
        Adapt.log.deprecated("Use model.set('_isOptional', value) as setOptional() may be removed in the future");
        this.set({ _isOptional: value });
      } }, { key: "checkLocking", value: function checkLocking()

      {
        var lockType = this.get('_lockType');

        if (!lockType) return;

        switch (lockType) {
          case 'sequential':
            this.setSequentialLocking();
            break;
          case 'unlockFirst':
            this.setUnlockFirstLocking();
            break;
          case 'lockLast':
            this.setLockLastLocking();
            break;
          case 'custom':
            this.setCustomLocking();
            break;
          default:
            console.warn("AdaptModel.checkLocking: unknown _lockType '".concat(lockType, "' found on ").concat(this.get('_id')));}

      } }, { key: "setSequentialLocking", value: function setSequentialLocking()

      {
        var children = this.getAvailableChildModels();

        for (var i = 1, j = children.length; i < j; i++) {
          children[i].set('_isLocked', !children[i - 1].get('_isComplete'));
        }
      } }, { key: "setUnlockFirstLocking", value: function setUnlockFirstLocking()

      {
        var children = this.getAvailableChildModels();
        var isFirstChildComplete = children[0].get('_isComplete');

        for (var i = 1, j = children.length; i < j; i++) {
          children[i].set('_isLocked', !isFirstChildComplete);
        }
      } }, { key: "setLockLastLocking", value: function setLockLastLocking()

      {
        var children = this.getAvailableChildModels();
        var lastIndex = children.length - 1;

        for (var i = lastIndex - 1; i >= 0; i--) {
          if (!children[i].get('_isComplete')) {
            return children[lastIndex].set('_isLocked', true);
          }
        }

        children[lastIndex].set('_isLocked', false);
      } }, { key: "setCustomLocking", value: function setCustomLocking()

      {var _this29 = this;
        var children = this.getAvailableChildModels();
        children.forEach(function (child) {_newArrowCheck(this, _this29);
          child.set('_isLocked', this.shouldLock(child));
        }.bind(this));
      } }, { key: "shouldLock", value: function shouldLock(

      child) {
        var lockedBy = child.get('_lockedBy');

        if (!lockedBy) return false;

        for (var i = lockedBy.length - 1; i >= 0; i--) {
          var id = lockedBy[i];

          try {
            var model = Adapt.findById(id);

            if (!model.get('_isAvailable')) continue;
            if (!model.get('_isComplete')) return true;
          } catch (e) {
            console.warn("AdaptModel.shouldLock: unknown _lockedBy ID '".concat(id, "' found on ").concat(child.get('_id')));
          }
        }

        return false;
      } }, { key: "onIsComplete", value: function onIsComplete()

      {
        this.checkCompletionStatus();

        this.checkLocking();
      }

      /**
         * Used before a model is rendered to determine if it should be reset to its
         * default values.
         */ }, { key: "checkIfResetOnRevisit", value: function checkIfResetOnRevisit()
      {
        var isResetOnRevisit = this.get('_isResetOnRevisit');
        if (!isResetOnRevisit) {
          return;
        }
        // If reset is enabled set defaults
        this.reset(isResetOnRevisit);
      }

      /**
         * Clones this model and all managed children returning a new branch.
         * Assign new unique ids to each cloned model.
         * @param {Function} [modifier] A callback function for each child to allow for custom modifications
         * @returns {AdaptModel}
         */ }, { key: "deepClone", value: function deepClone()
      {var _this30 = this;var modifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        // Fetch the class
        var ModelClass = this.constructor;
        // Clone the model
        var clonedModel = new ModelClass(this.toJSON());
        // Run the custom modifier on the clone
        if (modifier) {
          modifier(clonedModel, this);
        }
        var clonedId = clonedModel.get('_id');
        var hasId = Boolean(clonedId);
        var shouldAssignUniqueId = this.get('_id') === clonedId;
        if (hasId && shouldAssignUniqueId) {
          // Create a unique id if none was set by the modifier
          var cid = _.uniqueId(ModelClass.prototype.cidPrefix || 'c');
          clonedId = "".concat(clonedId, "_").concat(cid);
          clonedModel.set('_id', clonedId);
        }
        // Add the cloned model to Adapt.data for Adapt.findById resolution
        if (hasId) {
          Adapt.data.add(clonedModel);
        }
        // Clone any children
        if (this.hasManagedChildren) {
          this.getChildren().each(function (child) {var _this31 = this;_newArrowCheck(this, _this30);
            if (!child.deepClone) {
              throw new Error('Cannot deepClone child.');
            }
            child.deepClone(function (clone, child) {_newArrowCheck(this, _this31);
              if (hasId) {
                // Set the cloned child parent id
                clone.set('_parentId', clonedId);
              }
              if (modifier) {
                // Run the custom modifier function on the cloned child
                modifier(clone, child);
              }
            }.bind(this));
          }.bind(this));
        }
        // Add the cloned model to its parent for model.findDescendants resolution
        clonedModel.getParent().getChildren().add(clonedModel);
        // Setup the cloned model after setting the id, the parent and adding any children
        clonedModel.setupModel();
        return clonedModel;
      }

      /**
         * Internal event handler for all module events. Triggers event bubbling
         * through the module hierarchy when the event is included in
         * `this.bubblingEvents`.
         * @param {string} type Event name / type
         * @param {Backbone.Model} model Origin backbone model
         * @param {*} value New property value
         */ }, { key: "onAll", value: function onAll(
      type, model, value) {
        if (!_.result(this, 'bubblingEvents').includes(type)) return;
        var event = new ModelEvent(type, model, value);
        this.bubble(event);
      }

      /**
         * Internal event handler for bubbling events.
         * @param {ModelEvent} event
         */ }, { key: "bubble", value: function bubble(
      event) {
        if (!event.canBubble) return;
        event.addPath(this);
        this.trigger("bubble:".concat(event.type, " bubble"), event);
      } }, { key: "hasManagedChildren", get: function get() {return true;} }]);return AdaptModel;}(Backbone.Model);



  return AdaptModel;

});

define('core/js/models/contentObjectModel', [
'core/js/adapt',
'core/js/models/adaptModel'],
function (Adapt, AdaptModel) {var

  ContentObjectModel = /*#__PURE__*/function (_AdaptModel) {"use strict";_inherits(ContentObjectModel, _AdaptModel);var _super9 = _createSuper(ContentObjectModel);function ContentObjectModel() {_classCallCheck(this, ContentObjectModel);return _super9.apply(this, arguments);}_createClass(ContentObjectModel, [{ key: "getTypeGroup",




















      /**
                                                                                                                                                                                                                                                                                                                                             * Returns a string of the model type group.
                                                                                                                                                                                                                                                                                                                                             * @returns {string}
                                                                                                                                                                                                                                                                                                                                             */value: function getTypeGroup()
      {
        return 'contentobject';
      } }, { key: "_parent", get: function get() {Adapt.log.deprecated('contentObjectModel._parent, use contentObjectModel.getParent() instead, parent models are defined by the JSON');var isParentCourse = this.get('_parentId') === Adapt.course.get('_id');if (isParentCourse) {return 'course';}return 'contentObjects';} }, { key: "_siblings", get: function get() {Adapt.log.deprecated('contentObjectModel._siblings, use contentObjectModel.getSiblings() instead, sibling models are defined by the JSON');return 'contentObjects';} }, { key: "_children", get: function get() {Adapt.log.deprecated('contentObjectModel._children, use contentObjectModel.hasManagedChildren instead, child models are defined by the JSON');return null;} }]);return ContentObjectModel;}(AdaptModel);



  return ContentObjectModel;

});

define('core/js/models/menuModel', [
'core/js/adapt',
'core/js/models/contentObjectModel'],
function (Adapt, ContentObjectModel) {var

  MenuModel = /*#__PURE__*/function (_ContentObjectModel) {"use strict";_inherits(MenuModel, _ContentObjectModel);var _super10 = _createSuper(MenuModel);function MenuModel() {_classCallCheck(this, MenuModel);return _super10.apply(this, arguments);}_createClass(MenuModel, [{ key: "getTypeGroup",






      /**
                                                                                                                                                                                                                                                                                                         * Returns a string of the model type group.
                                                                                                                                                                                                                                                                                                         * @returns {string}
                                                                                                                                                                                                                                                                                                         */value: function getTypeGroup()
      {
        return 'menu';
      } }, { key: "setCustomLocking", value: function setCustomLocking()

      {var _this32 = this;
        var children = this.getAvailableChildModels();
        children.forEach(function (child) {_newArrowCheck(this, _this32);
          child.set('_isLocked', this.shouldLock(child));
          if (!(child instanceof MenuModel)) return;
          child.checkLocking();
        }.bind(this));
      } }, { key: "_children", get: function get() {Adapt.log.deprecated('menuModel._children, use menuModel.hasManagedChildren instead, child models are defined by the JSON');return 'contentObjects';} }]);return MenuModel;}(ContentObjectModel);



  Adapt.register('menu', { model: MenuModel });

  return MenuModel;

});

define('core/js/models/courseModel', [
'core/js/adapt',
'core/js/models/menuModel'],
function (Adapt, MenuModel) {var

  CourseModel = /*#__PURE__*/function (_MenuModel) {"use strict";_inherits(CourseModel, _MenuModel);var _super11 = _createSuper(CourseModel);function CourseModel() {_classCallCheck(this, CourseModel);return _super11.apply(this, arguments);}_createClass(CourseModel, [{ key: "_parent", get: function get()

      {
        Adapt.log.deprecated('courseModel._parent, use courseModel.getParent() instead, parent models are defined by the JSON');
        return null;
      } }, { key: "_siblings", get: function get()

      {
        Adapt.log.deprecated('courseModel._siblings, use courseModel.getSiblings() instead, sibling models are defined by the JSON');
        return null;
      } }]);return CourseModel;}(MenuModel);



  Adapt.register('course', { model: CourseModel });

  return CourseModel;

});

define('core/js/startController', [
'core/js/adapt'],
function (Adapt) {

  var StartController = Backbone.Controller.extend({

    model: null,

    loadCourseData: function loadCourseData() {
      this.model = new Backbone.Model(Adapt.course.get('_start'));
    },

    setStartLocation: function setStartLocation() {
      if (!this.isEnabled()) return;
      window.history.replaceState('', '', this.getStartHash());
    },

    returnToStartLocation: function returnToStartLocation() {
      var startIds = this.model.get('_startIds');
      if (startIds) {
        // ensure we can return to the start page even if it is completed
        startIds.forEach(function (startId) {
          startId._skipIfComplete = false;
        });
      }
      window.location.hash = this.getStartHash(true);
    },

    /**
        * Returns a string in URL.hash format representing the route that the course should be sent to
        * @param {boolean} [alwaysForce] Ignore any route specified in location.hash and force use of the start page instead
        * @return {string}
        */
    getStartHash: function getStartHash(alwaysForce) {
      var startId = this.getStartId();
      var isRouteSpecified = window.location.href.indexOf('#') > -1;
      var shouldForceStartId = alwaysForce || this.model.get('_force');
      var shouldNavigateToStartId = startId && (!isRouteSpecified || shouldForceStartId);

      if (shouldNavigateToStartId && startId !== Adapt.course.get('_id')) {
        return '#/id/' + startId;
      }

      // If there's a route specified in location.hash, use that - otherwise go to main menu
      return window.location.hash || '#/';
    },

    isEnabled: function isEnabled() {
      if (!this.model || !this.model.get('_isEnabled')) return false;
      return true;
    },

    getStartId: function getStartId() {
      var startId = this.model.get('_id');
      var startIds = this.model.get('_startIds');

      if (!startIds || !startIds.length) return startId;

      var $html = $('html');
      for (var i = 0, l = startIds.length; i < l; i++) {
        var item = startIds[i];
        var className = item._className;
        var skipIfComplete = item._skipIfComplete;

        var model = Adapt.findById(item._id);

        if (!model) {
          console.log('startController: cannot find id', item._id);
          continue;
        }

        if (skipIfComplete) {
          if (model.get('_isComplete')) continue;
        }

        if (!className || $html.is(className) || $html.hasClass(className)) {
          // See https://github.com/adaptlearning/adapt_framework/issues/1843
          startId = item._id;
          break;
        }
      }

      return startId;
    } });



  Adapt.once('adapt:start', function () {
    Adapt.startController.loadCourseData();
    Adapt.startController.setStartLocation();
  });

  /*
      * allows you to call returnToStartLocation either by calling `Adapt.trigger('navigation:returnToStart')`
      * or by including in the top navigation bar a button that has the attribute `data-event="returnToStart"`
      */
  Adapt.on('navigation:returnToStart', function () {
    Adapt.startController.returnToStartLocation();
  });

  return Adapt.startController = new StartController();

});

define('core/js/data', [
'core/js/adapt',
'core/js/collections/adaptCollection',
'core/js/models/buildModel',
'core/js/models/configModel',
'core/js/models/courseModel',
'core/js/models/lockingModel',
'core/js/startController'],
function (Adapt, AdaptCollection, BuildModel, ConfigModel, CourseModel) {var

  Data = /*#__PURE__*/function (_AdaptCollection) {"use strict";_inherits(Data, _AdaptCollection);var _super12 = _createSuper(Data);function Data() {_classCallCheck(this, Data);return _super12.apply(this, arguments);}_createClass(Data, [{ key: "model", value: function model(

      json) {
        var ModelClass = Adapt.getModelClass(json);
        if (!ModelClass) {
          return new Backbone.Model(json);
        }
        return new ModelClass(json);
      } }, { key: "initialize", value: function initialize()

      {
        _get(_getPrototypeOf(Data.prototype), "initialize", this).call(this);
        this.on({
          'add': this.onAdded,
          'remove': this.onRemoved });

      } }, { key: "init", value: function () {var _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:


                  this.reset();
                  this._byAdaptID = {};
                  Adapt.build = new BuildModel(null, { url: 'adapt/js/build.min.js', reset: true });_context4.next = 5;return (
                    Adapt.build.whenReady());case 5:
                  $('html').attr('data-adapt-framework-version', Adapt.build.get('package').version);
                  this.loadConfigData();case 7:case "end":return _context4.stop();}}}, _callee4, this);}));function init() {return _init.apply(this, arguments);}return init;}() }, { key: "onAdded", value: function onAdded(


      model) {
        this._byAdaptID[model.get('_id')] = model;
      } }, { key: "onRemoved", value: function onRemoved(

      model) {
        delete this._byAdaptID[model.get('_id')];
      } }, { key: "loadConfigData", value: function loadConfigData()

      {
        Adapt.config = new ConfigModel(null, { url: 'course/config.' + Adapt.build.get('jsonext'), reset: true });
        this.listenToOnce(Adapt, 'configModel:loadCourseData', this.onLoadCourseData);
        this.listenTo(Adapt.config, {
          'change:_activeLanguage': this.onLanguageChange,
          'change:_defaultDirection': this.onDirectionChange });

      } }, { key: "onDirectionChange", value: function onDirectionChange(

      model, direction) {
        if (direction === 'rtl') {
          $('html').removeClass('dir-ltr').addClass('dir-rtl').attr('dir', 'rtl');
        } else {
          $('html').removeClass('dir-rtl').addClass('dir-ltr').attr('dir', 'ltr');
        }
      }

      /**
         * Before we actually go to load the course data, we first need to check to see if a language has been set
         * If it has we can go ahead and start loading; if it hasn't, apply the defaultLanguage from config.json
         */ }, { key: "onLoadCourseData", value: function onLoadCourseData()
      {
        if (!Adapt.config.get('_activeLanguage')) {
          Adapt.config.set('_activeLanguage', Adapt.config.get('_defaultLanguage'));
          return;
        }
        this.loadCourseData();
      } }, { key: "onLanguageChange", value: function onLanguageChange(

      model, language) {
        Adapt.offlineStorage.set('lang', language);
        this.loadCourseData(language);
      } }, { key: "loadCourseData", value: function () {var _loadCourseData = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(

        newLanguage) {var language, courseFolder;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:

                  // All code that needs to run before adapt starts should go here
                  language = Adapt.config.get('_activeLanguage');
                  courseFolder = 'course/' + language + '/';

                  $('html').attr('lang', language);_context5.next = 5;return (

                    this.loadManifestFiles(courseFolder));case 5:_context5.next = 7;return (
                    this.triggerDataLoaded());case 7:_context5.next = 9;return (
                    this.triggerDataReady(newLanguage));case 9:
                  this.triggerInit();case 10:case "end":return _context5.stop();}}}, _callee5, this);}));function loadCourseData(_x) {return _loadCourseData.apply(this, arguments);}return loadCourseData;}() }, { key: "getJSON", value: function getJSON(



      path) {var _this33 = this;
        return new Promise(function (resolve, reject) {var _this34 = this;_newArrowCheck(this, _this33);
          $.getJSON(path, function (data) {_newArrowCheck(this, _this34);
            // Add path to data incase it's necessary later
            data.__path__ = path;
            resolve(data);
          }.bind(this)).fail(reject);
        }.bind(this));
      } }, { key: "loadManifestFiles", value: function () {var _loadManifestFiles = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(

        languagePath) {var _this35 = this;var manifestPath, manifest, allFileData, allModelData, course;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:
                  this.trigger('loading');
                  this.reset();
                  manifestPath = languagePath + 'language_data_manifest.js';_context6.prev = 3;_context6.next = 6;return (


                    this.getJSON(manifestPath));case 6:manifest = _context6.sent;_context6.next = 13;break;case 9:_context6.prev = 9;_context6.t0 = _context6["catch"](3);

                  manifest = ['course.json', 'contentObjects.json', 'articles.json', 'blocks.json', 'components.json'];
                  Adapt.log.warnOnce("Manifest path '".concat(manifestPath, " not found. Using traditional files: ").concat(manifest.join(', ')));case 13:_context6.next = 15;return (

                    Promise.all(manifest.map(function (filePath) {_newArrowCheck(this, _this35);
                      return this.getJSON("".concat(languagePath).concat(filePath));
                    }.bind(this))));case 15:allFileData = _context6.sent;
                  // Flatten all file data into a single array of model data
                  allModelData = allFileData.reduce(function (result, fileData) {_newArrowCheck(this, _this35);
                    if (Array.isArray(fileData)) {
                      result.push.apply(result, _toConsumableArray(fileData));
                    } else if (fileData instanceof Object) {
                      result.push(fileData);
                    } else {
                      Adapt.log.warnOnce("File data isn't an array or object: ".concat(fileData.__path__));
                    }
                    return result;
                  }.bind(this), []);
                  // Add course model first to allow other model/views to utilize its settings
                  course = allModelData.find(function (modelData) {_newArrowCheck(this, _this35);return modelData._type === 'course';}.bind(this));if (
                  course) {_context6.next = 20;break;}throw (
                    new Error("Expected a model data with \"_type\": \"course\", none found."));case 20:

                  Adapt.trigger('courseModel:dataLoading');
                  Adapt.course = this.push(course);
                  Adapt.trigger('courseModel:dataLoaded');
                  // Add other models
                  allModelData.forEach(function (modelData) {_newArrowCheck(this, _this35);
                    if (modelData._type === 'course') {
                      return;
                    }
                    this.push(modelData);
                  }.bind(this));
                  this.trigger('reset');
                  this.trigger('loaded');_context6.next = 28;return (
                    Adapt.wait.queue());case 28:case "end":return _context6.stop();}}}, _callee6, this, [[3, 9]]);}));function loadManifestFiles(_x2) {return _loadManifestFiles.apply(this, arguments);}return loadManifestFiles;}() }, { key: "triggerDataLoaded", value: function () {var _triggerDataLoaded = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {var _this36 = this;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:



                  Adapt.log.debug('Firing app:dataLoaded');
                  try {
                    // Setup the newly added models
                    this.forEach(function (model) {_newArrowCheck(this, _this36);return model.setupModel && model.setupModel();}.bind(this));
                    Adapt.trigger('app:dataLoaded');
                  } catch (e) {
                    Adapt.log.error('Error during app:dataLoading trigger', e);
                  }_context7.next = 4;return (
                    Adapt.wait.queue());case 4:case "end":return _context7.stop();}}}, _callee7, this);}));function triggerDataLoaded() {return _triggerDataLoaded.apply(this, arguments);}return triggerDataLoaded;}() }, { key: "triggerDataReady", value: function () {var _triggerDataReady = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(


        newLanguage) {var _this37 = this;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:
                  if (newLanguage) {
                    Adapt.trigger('app:languageChanged', newLanguage);
                    _.defer(function () {_newArrowCheck(this, _this37);
                      Adapt.startController.loadCourseData();
                      var hash = Adapt.startController.isEnabled() ? Adapt.startController.getStartHash(true) : '#/';
                      Adapt.router.navigate(hash, { trigger: true, replace: true });
                    }.bind(this));
                  }
                  Adapt.log.debug('Firing app:dataReady');
                  try {
                    Adapt.trigger('app:dataReady');
                  } catch (e) {
                    Adapt.log.error('Error during app:dataReady trigger', e);
                  }_context8.next = 5;return (
                    Adapt.wait.queue());case 5:case "end":return _context8.stop();}}}, _callee8, this);}));function triggerDataReady(_x3) {return _triggerDataReady.apply(this, arguments);}return triggerDataReady;}() }, { key: "triggerInit", value: function triggerInit()


      {
        this.isReady = true;
        this.trigger('ready');
      } }, { key: "whenReady", value: function whenReady()

      {var _this38 = this;
        if (this.isReady) return Promise.resolve();
        return new Promise(function (resolve) {_newArrowCheck(this, _this38);
          this.once('ready', resolve);
        }.bind(this));
      }

      /**
         * Looks up a model by its `_id` property
         * @param {string} id The id of the item e.g. "co-05"
         * @return {Backbone.Model}
         */ }, { key: "findById", value: function findById(
      id) {
        var model = this._byAdaptID[id];
        if (!model) {
          console.warn("Adapt.findById() unable to find collection type for id: ".concat(id));
          return;
        }
        return model;
      } }]);return Data;}(AdaptCollection);



  return Adapt.data = new Data();

});

define('core/js/offlineStorage', [
'core/js/adapt'],
function (Adapt) {

  // Basic API for setting and getting name+value pairs
  // Allows registration of a single handler.

  var OfflineStorage = Backbone.Controller.extend({

    /**
                                                     * set to true initially so that if there are no offlineStorage handlers (i.e. if contrib-spoor is not installed)
                                                     * this can still be accessed OK
                                                     */
    ready: true,
    _handler: undefined,

    /**
                          * set .ready to false if an offlineStorage handler is being attached - we'll need to wait until the handler lets us know
                          * it's ready before we can safely use offlineStorage
                          */
    initialize: function initialize(handler) {
      if (!handler) {
        return;
      }

      this.ready = false;
      this._handler = handler;
    },

    /**
        * Flag to indicate if an offlineStorage handler has been defined.
        * @returns {boolean} true if an offlineStorage handler has been defined, false otherwise
        */
    hasHandler: function hasHandler() {
      return this._handler !== undefined;
    },

    /**
        * Causes state to be serialized and saved.
        */
    save: function save() {
      Adapt.trigger('tracking:save');
      if (this._handler && this._handler.save) {
        return this._handler.save.apply(this._handler, arguments);
      }
    },

    /**
        * Serializes nested arrays, booleans and numbers into an encoded string.
        * @param {Array|boolean|number} value
        * @returns {string}
        */
    serialize: function serialize(value) {
      if (this._handler && this._handler.serialize) {
        return this._handler.serialize.apply(this._handler, arguments);
      }
      return JSON.stringify(value);
    },

    /**
        * Deserializes encoded strings back into nested arrays, booleans and numbers.
        * @param {string} value
        * @returns {Array|boolean|number}
        */
    deserialize: function deserialize(value) {
      if (this._handler && this._handler.deserialize) {
        return this._handler.deserialize.apply(this._handler, arguments);
      }
      return JSON.parse(value);
    },

    set: function set(name, value) {
      if (this._handler && this._handler.set) {
        return this._handler.set.apply(this._handler, arguments);
      }
      // if no handler has been defined, just store the data locally
      this[name] = value;
    },

    get: function get(name) {
      if (this._handler && this._handler.get) {
        return this._handler.get.apply(this._handler, arguments);
      }
      // if no handler has been defined, check local data store
      return this[name];
    },

    /**
        * Some forms of offlineStorage could take time to initialise, this allows us to let plugins know when it's ready to be used
        */
    setReadyStatus: function setReadyStatus() {
      this.ready = true;
      Adapt.trigger('offlineStorage:ready');
    } });



  Adapt.offlineStorage = new OfflineStorage();

  return Adapt.offlineStorage;

});

define('core/js/enums/completionStateEnum', [], function () {

  var COMPLETION_STATE = ENUM([
  'INCOMPLETE',
  'COMPLETED',
  'PASSED',
  'FAILED']);


  return COMPLETION_STATE;

});

define('core/js/tracking', [
'core/js/adapt',
'core/js/enums/completionStateEnum'],
function (Adapt, COMPLETION_STATE) {

  var Tracking = Backbone.Controller.extend({

    _config: {
      _requireContentCompleted: true,
      _requireAssessmentCompleted: false },


    _assessmentState: null,

    initialize: function initialize() {
      Adapt.once('configModel:dataLoaded', this.loadConfig.bind(this));
      Adapt.on('app:dataReady', this.setupEventListeners.bind(this));
    },

    setupEventListeners: function setupEventListeners() {
      // Check if completion requires passing an assessment.
      if (this._config._requireAssessmentCompleted) {
        this.listenTo(Adapt, {
          'assessment:complete': this.onAssessmentComplete,
          'assessment:restored': this.onAssessmentRestored });

      }

      // Check if completion requires completing all content.
      if (this._config._requireContentCompleted) {
        this.listenTo(Adapt.course, 'change:_isComplete', this.checkCompletion);
      }
    },

    /**
        * Store the assessment state.
        * @param {object} assessmentState - The object returned by Adapt.assessment.getState()
        */
    onAssessmentComplete: function onAssessmentComplete(assessmentState) {
      this._assessmentState = assessmentState;

      this.checkCompletion();
    },

    /**
        * Restores the _assessmentState object when an assessment is registered.
        * @param {object} assessmentState - An object representing the overall assessment state
        */
    onAssessmentRestored: function onAssessmentRestored(assessmentState) {
      this._assessmentState = assessmentState;
    },

    /**
        * Evaluate the course and assessment completion.
        */
    checkCompletion: function checkCompletion() {
      var completionData = this.getCompletionData();

      if (completionData.status === COMPLETION_STATE.INCOMPLETE) {
        return;
      }

      Adapt.trigger('tracking:complete', completionData);
      Adapt.log.debug('tracking:complete', completionData);
    },

    /**
        * The return value of this function should be passed to the trigger of 'tracking:complete'.
        * @returns An object representing the user's course completion.
        */
    getCompletionData: function getCompletionData() {
      var completionData = {
        status: COMPLETION_STATE.INCOMPLETE,
        assessment: null };


      // Course complete is required.
      if (this._config._requireContentCompleted && !Adapt.course.get('_isComplete')) {
        // INCOMPLETE: course not complete.
        return completionData;
      }

      // Assessment completed required.
      if (this._config._requireAssessmentCompleted) {
        if (!this._assessmentState) {
          // INCOMPLETE: assessment is not complete.
          return completionData;
        }

        // PASSED/FAILED: assessment completed.
        completionData.status = this._assessmentState.isPass ? COMPLETION_STATE.PASSED : COMPLETION_STATE.FAILED;
        completionData.assessment = this._assessmentState;

        return completionData;
      }

      // COMPLETED: criteria met, no assessment requirements.
      completionData.status = COMPLETION_STATE.COMPLETED;

      return completionData;
    },

    /**
        * Set the _config object to the values retrieved from config.json.
        */
    loadConfig: function loadConfig() {
      if (Adapt.config.has('_completionCriteria')) {
        this._config = Adapt.config.get('_completionCriteria');
      }
    } });



  Adapt.tracking = new Tracking();

  return Adapt.tracking;

});

define('core/js/device', [
'core/js/adapt',
'bowser'],
function (Adapt, Bowser) {

  var $html = $('html');
  var $window = $(window);

  Adapt.device = {
    touch: Modernizr.touchevents,
    screenWidth: getScreenWidth(),
    screenHeight: getScreenHeight(),
    browser: (Bowser.name || '').toLowerCase(),
    version: (Bowser.version || '').toLowerCase(),
    OS: getOperatingSystem().toLowerCase(),
    osVersion: Bowser.osversion || '',
    renderingEngine: getRenderingEngine() };


  // Define 'orientation' and 'aspectRatio' here once 'screenWidth' and 'screenHeight' have been set,
  // as both these functions are getters, essentially.
  Object.defineProperties(Adapt.device, {
    'orientation': {
      get: function get() {
        return this.screenWidth >= this.screenHeight ? 'landscape' : 'portrait';
      } },

    'aspectRatio': {
      get: function get() {
        return this.screenWidth / this.screenHeight;
      } } });



  Adapt.once('app:dataReady', function () {
    Adapt.device.screenSize = checkScreenSize();

    $html.addClass('size-' + Adapt.device.screenSize);

    if (Adapt.device.orientation) {
      $html.addClass('orientation-' + Adapt.device.orientation);
    }

    // As Adapt.config is available it's ok to bind the 'resize'.
    $window.on('resize orientationchange', onWindowResize);
  });

  /**
       * Compares the calculated screen width to the breakpoints defined in config.json.
       *
       * @returns {string} 'large', 'medium' or 'small'
       */
  function checkScreenSize() {
    var screenSizeConfig = Adapt.config.get('screenSize');
    var screenSize;

    var screensizeEmThreshold = 300;
    var baseFontSize = 16;

    // Check to see if the screen size value is larger than the em threshold
    // If value is larger than em threshold, convert value (assumed px) to ems
    // Otherwise assume value is in ems
    var mediumEmBreakpoint = screenSizeConfig.medium > screensizeEmThreshold ?
    screenSizeConfig.medium / baseFontSize :
    screenSizeConfig.medium;
    var smallEmBreakpoint = screenSizeConfig.small > screensizeEmThreshold ?
    screenSizeConfig.small / baseFontSize :
    screenSizeConfig.small;

    var fontSize = parseFloat($('html').css('font-size'));
    var screenSizeEmWidth = Adapt.device.screenWidth / fontSize;

    // Check to see if client screen width is larger than medium em breakpoint
    // If so apply large, otherwise check to see if client screen width is
    // larger than small em breakpoint. If so apply medium, otherwise apply small
    if (screenSizeEmWidth >= mediumEmBreakpoint) {
      screenSize = 'large';
    } else if (screenSizeEmWidth >= smallEmBreakpoint) {
      screenSize = 'medium';
    } else {
      screenSize = 'small';
    }

    return screenSize;
  }

  function getScreenWidth() {
    return isAppleDevice() ?
    getAppleScreenWidth() :
    window.innerWidth || $window.width();
  }

  function getScreenHeight() {
    return isAppleDevice() ?
    getAppleScreenHeight() :
    window.innerHeight || $window.height();
  }

  function getOperatingSystem() {
    var os = '';
    var flags = ['windows', 'mac', 'linux', 'windowsphone', 'chromeos', 'android',
    'ios', 'blackberry', 'firefoxos', 'webos', 'bada', 'tizen', 'sailfish'];

    for (var i = 0; i < flags.length; i++) {
      if (Bowser[flags[i]]) {
        os = flags[i];
        break;
      }
    }

    if (os === '') {
      // Fall back to using navigator.platform in case Bowser can't detect the OS.
      var platform = navigator.platform;
      var platforms = ['Win', 'Mac', 'Linux'];
      os = 'PlatformUnknown';

      for (var j = 0; j < platforms.length; j++) {
        if (platform.indexOf(platforms[j]) !== -1) {
          os = platforms[j].toLowerCase();
          break;
        }
      }

      // Set consistency with the Bowser flags.
      if (os === 'win') {
        os = 'windows';
      }
    }

    return os;
  }

  function getRenderingEngine() {
    var engine = '';
    var flags = ['webkit', 'blink', 'gecko', 'msie', 'msedge'];

    for (var i = 0; i < flags.length; i++) {
      if (Bowser[flags[i]]) {
        engine = flags[i];
        break;
      }
    }

    return engine;
  }

  var onWindowResize = _.debounce(function onScreenSizeChanged() {
    // Calculate the screen properties.
    var previousWidth = Adapt.device.screenWidth;
    var previousHeight = Adapt.device.screenHeight;

    Adapt.device.screenWidth = getScreenWidth();
    Adapt.device.screenHeight = getScreenHeight();

    if (previousWidth === Adapt.device.screenWidth && previousHeight === Adapt.device.screenHeight) {
      // Do not trigger a change if the viewport hasn't actually changed.  Scrolling on iOS will trigger a resize.
      return;
    }

    var newScreenSize = checkScreenSize();

    if (newScreenSize !== Adapt.device.screenSize) {
      Adapt.device.screenSize = newScreenSize;

      $html.removeClass('size-small size-medium size-large').addClass('size-' + Adapt.device.screenSize);

      if (Adapt.device.orientation) {
        $html.removeClass('orientation-landscape orientation-portrait').addClass('orientation-' + Adapt.device.orientation);
      }

      Adapt.trigger('device:changed', Adapt.device.screenSize);
    }

    Adapt.trigger('device:preResize device:resize device:postResize', Adapt.device.screenWidth);

  }, 100);

  function isAppleDevice() {
    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  }

  function getAppleScreenWidth() {
    return Math.abs(window.orientation) === 90 ? screen.height : screen.width;
  }

  function getAppleScreenHeight() {
    return Math.abs(window.orientation) === 90 ? screen.width : screen.height;
  }

  function getAppleDeviceType() {
    var type = '';

    var flags = ['iphone', 'ipad', 'ipod'];

    for (var i = 0; i < flags.length; i++) {
      if (Bowser[flags[i]]) {
        type = flags[i];
        break;
      }
    }

    return type;
  }

  function pixelDensity() {
    var pixelDensity = window.devicePixelRatio || 1;

    if (pixelDensity >= 3) {
      return 'ultra-high';
    } else if (pixelDensity >= 2) {
      return 'high';
    } else if (pixelDensity >= 1.5) {
      return 'medium';
    } else {
      return 'low';
    }
  }

  var browser = Adapt.device.browser.toLowerCase();
  // Convert 'msie' and 'internet explorer' to 'ie'.
  var browserString = browser.replace(/msie|internet explorer/, 'ie');
  browserString = browserString + ' version-' + Adapt.device.version + ' OS-' + Adapt.device.OS + ' ' + getAppleDeviceType();
  browserString += browserString.replace('.', '-').toLowerCase();

  $html.addClass(browserString + ' pixel-density-' + pixelDensity());
});

define('core/js/views/drawerItemView', [
'core/js/adapt'],
function (Adapt) {

  var DrawerItemView = Backbone.View.extend({

    className: 'drawer__menu drawer__item',

    attributes: {
      role: 'list' },


    initialize: function initialize() {
      this.listenTo(Adapt, 'drawer:empty', this.remove);
      this.render();
    },

    events: {
      'click .drawer__item-btn': 'onDrawerItemClicked' },


    render: function render() {
      var data = this.model.toJSON();
      var template = Handlebars.templates['drawerItem'];
      $(this.el).html(template(data)).appendTo('.drawer__holder');
      return this;
    },

    onDrawerItemClicked: function onDrawerItemClicked(event) {
      event.preventDefault();
      var eventCallback = this.model.get('eventCallback');
      Adapt.trigger(eventCallback);
    } },

  {
    type: 'drawerItem' });


  return DrawerItemView;

});

define('core/js/views/drawerView', [
'core/js/adapt',
'core/js/views/drawerItemView'],
function (Adapt, DrawerItemView) {

  var DrawerView = Backbone.View.extend({

    className: 'drawer u-display-none',
    disableAnimation: false,

    attributes: {
      'role': 'dialog',
      'aria-modal': 'true',
      'aria-labelledby': 'drawer-heading',
      'aria-hidden': 'true' },


    initialize: function initialize() {
      this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
      this._isVisible = false;
      this.drawerDir = 'right';
      if (Adapt.config.get('_defaultDirection') === 'rtl') {// on RTL drawer on the left
        this.drawerDir = 'left';
      }
      this.setupEventListeners();
      this.render();
      this.drawerDuration = Adapt.config.get('_drawer')._duration;
      this.drawerDuration = this.drawerDuration ? this.drawerDuration : 400;
      // Setup cached selectors
      this.$wrapper = $('#wrapper');
    },

    setupEventListeners: function setupEventListeners() {
      this.listenTo(Adapt, {
        'navigation:toggleDrawer': this.toggleDrawer,
        'drawer:triggerCustomView': this.openCustomView,
        'drawer:closeDrawer': this.onCloseDrawer,
        'remove': this.onRemove,
        'drawer:remove': this.remove });


      this._onKeyUp = _.bind(this.onKeyUp, this);
      this.setupEscapeKey();
    },

    setupEscapeKey: function setupEscapeKey() {
      $(window).on('keyup', this._onKeyUp);
    },

    onKeyUp: function onKeyUp(event) {
      if (event.which !== 27) return;
      event.preventDefault();

      this.onCloseDrawer();
    },

    events: {
      'click .drawer__back': 'onBackButtonClicked',
      'click .drawer__close': 'onCloseClicked' },


    render: function render() {
      var template = Handlebars.templates['drawer'];
      $(this.el).html(template({ _globals: Adapt.course.get('_globals') })).prependTo('body');
      var shadowTemplate = Handlebars.templates['shadow'];
      $(shadowTemplate()).prependTo('body');
      // Set defer on post render
      _.defer(_.bind(function () {
        this.postRender();
      }, this));
      return this;
    },

    // Set tabindex for select elements
    postRender: function postRender() {
      this.$('a, button, input, select, textarea').attr('tabindex', -1);

      this.checkIfDrawerIsAvailable();
    },

    openCustomView: function openCustomView(view, hasBackButton) {
      // Set whether back button should display
      this._hasBackButton = hasBackButton;
      this._isCustomViewVisible = true;
      Adapt.trigger('drawer:empty');
      this.showDrawer();
      this.$('.drawer__holder').html(view);
    },

    checkIfDrawerIsAvailable: function checkIfDrawerIsAvailable() {
      if (this.collection.length === 0) {
        $('.js-nav-drawer-btn').addClass('u-display-none');
        Adapt.trigger('drawer:noItems');
        return;
      }
      $('.js-nav-drawer-btn').removeClass('u-display-none');
    },

    onBackButtonClicked: function onBackButtonClicked(event) {
      event.preventDefault();
      this.showDrawer(true);
    },

    onCloseClicked: function onCloseClicked(event) {
      event.preventDefault();
      this.hideDrawer();
    },

    onCloseDrawer: function onCloseDrawer($toElement) {
      this.hideDrawer($toElement);
    },

    onRemove: function onRemove() {
      this.hideDrawer();
    },

    toggleDrawer: function toggleDrawer() {
      if (this._isVisible && this._isCustomViewVisible === false) {
        this.hideDrawer();
      } else {
        this.showDrawer(true);
      }
    },

    showDrawer: function showDrawer(emptyDrawer) {
      this.$el.removeClass('u-display-none').removeAttr('aria-hidden');
      // Only trigger popup:opened if drawer is visible, pass popup manager drawer element
      if (!this._isVisible) {
        Adapt.a11y.popupOpened(this.$el);
        Adapt.a11y.scrollDisable('body');
        this._isVisible = true;
      }

      // Sets tab index to 0 for all tabbable elements in Drawer
      this.$('a, button, input, select, textarea').attr('tabindex', 0);

      if (emptyDrawer) {
        this.$('.drawer__back').addClass('u-display-none');
        this._isCustomViewVisible = false;
        this.emptyDrawer();
        if (this.collection.models.length === 1) {
          // This callback triggers openCustomView() and sets
          // _isCustomViewVisible to true, causing toggleDrawer()
          // to re-render the drawer on every toggle button press
          Adapt.trigger(this.collection.models[0].get('eventCallback'));
          // Set _isCustomViewVisible to false to prevent re-rendering
          // the drawer and fix the toggle functionality on toggle button press
          this._isCustomViewVisible = false;
        } else {
          this.renderItems();
          Adapt.trigger('drawer:openedItemView');
        }
      } else {
        if (this._hasBackButton && this.collection.models.length > 1) {
          this.$('.drawer__back').removeClass('u-display-none');
        } else {
          this.$('.drawer__back').addClass('u-display-none');
        }
        Adapt.trigger('drawer:openedCustomView');
      }

      // delay drawer animation until after background fadeout animation is complete
      var direction = {};
      if (this.disableAnimation) {
        $('.js-shadow').removeClass('u-display-none');
        $('.js-drawer-holder').scrollTop(0);

        direction[this.drawerDir] = 0;
        this.$el.css(direction);
        complete.call(this);
      } else {
        // eslint-disable-next-line object-property-newline
        $('.js-shadow').velocity({ opacity: 1 }, { duration: this.drawerDuration, begin: _.bind(function () {
            $('.js-shadow').removeClass('u-display-none');
            $('.js-drawer-holder').scrollTop(0);
            complete.call(this);
          }, this) });

        var showEasingAnimation = Adapt.config.get('_drawer')._showEasing;
        var easing = showEasingAnimation || 'easeOutQuart';

        direction[this.drawerDir] = 0;
        this.$el.velocity(direction, this.drawerDuration, easing);
      }

      function complete() {
        this.addShadowEvent();
        Adapt.trigger('drawer:opened');

        // focus on first tabbable element in drawer
        Adapt.a11y.focusFirst(this.$el, { defer: true });
      }

    },

    emptyDrawer: function emptyDrawer() {
      this.$('.drawer__holder').empty();
    },

    renderItems: function renderItems() {
      Adapt.trigger('drawer:empty');
      this.emptyDrawer();
      var models = this.collection.models;
      for (var i = 0, len = models.length; i < len; i++) {
        var item = models[i];
        new DrawerItemView({ model: item });
      }
    },

    hideDrawer: function hideDrawer($toElement) {
      var direction = {};
      // only trigger popup:closed if drawer is visible
      if (this._isVisible) {
        Adapt.a11y.popupClosed($toElement);
        this._isVisible = false;
        Adapt.a11y.scrollEnable('body');
      } else {
        return;
      }

      if (this.disableAnimation) {

        direction[this.drawerDir] = -this.$el.width();
        this.$el.
        css(direction).
        addClass('u-display-none').
        attr('aria-hidden', 'true');

        $('.js-shadow').addClass('u-display-none');

        Adapt.trigger('drawer:closed');

      } else {

        var showEasingAnimation = Adapt.config.get('_drawer')._hideEasing;
        var easing = showEasingAnimation || 'easeOutQuart';

        direction[this.drawerDir] = -this.$el.width();
        this.$el.velocity(direction, this.drawerDuration, easing, _.bind(function () {
          this.$el.
          addClass('u-display-none').
          attr('aria-hidden', 'true');

          Adapt.trigger('drawer:closed');
        }, this));

        $('.js-shadow').velocity({ opacity: 0 }, { duration: this.drawerDuration,
          complete: function complete() {
            $('.js-shadow').addClass('u-display-none');
          } });

      }

      this._isCustomViewVisible = false;
      this.removeShadowEvent();

    },

    addShadowEvent: function addShadowEvent() {
      $('.js-shadow').one('click touchstart', function () {
        this.onCloseDrawer();
      }.bind(this));
    },

    removeShadowEvent: function removeShadowEvent() {
      $('.js-shadow').off('click touchstart');
    },

    remove: function remove() {
      Backbone.View.prototype.remove.apply(this, arguments);
      $(window).off('keyup', this._onKeyUp);

      Adapt.trigger('drawer:empty');
      this.collection.reset();
      $('.js-shadow').remove();
    } },

  {
    childContainer: '.js-drawer-holder',
    childView: DrawerItemView });


  return DrawerView;

});

define('core/js/drawer', [
'core/js/adapt',
'core/js/views/drawerView'],
function (Adapt, DrawerView) {

  var DrawerCollection = new Backbone.Collection(null, { comparator: 'drawerOrder' });
  var Drawer = {};

  Drawer.addItem = function (drawerObject, eventCallback) {
    drawerObject.eventCallback = eventCallback;
    DrawerCollection.add(drawerObject);
  };

  Drawer.triggerCustomView = function (view, hasBackButton) {
    if (hasBackButton !== false) {
      hasBackButton = true;
    }
    Adapt.trigger('drawer:triggerCustomView', view, hasBackButton);
  };

  Adapt.on({
    'adapt:start': function adaptStart() {
      new DrawerView({ collection: DrawerCollection });
    },
    'app:languageChanged': function appLanguageChanged() {
      Adapt.trigger('drawer:remove');
    } });


  Adapt.drawer = Drawer;

});

define('core/js/views/notifyPushView', [
'core/js/adapt'],
function (Adapt) {

  var NotifyPushView = Backbone.View.extend({

    className: function className() {
      var classes = 'notify-push ';
      classes += this.model.get('_classes') || '';
      return classes;
    },

    attributes: {
      'role': 'dialog',
      'aria-labelledby': 'notify-push-heading',
      'aria-modal': 'false' },


    initialize: function initialize() {
      this.listenTo(Adapt, {
        'notify:pushShown notify:pushRemoved': this.updateIndexPosition,
        'remove': this.remove });


      this.listenTo(this.model.collection, {
        'remove': this.updateIndexPosition,
        'change:_index': this.updatePushPosition });


      this.preRender();
      this.render();
    },

    events: {
      'click .js-notify-push-close-btn': 'closePush',
      'click .js-notify-push-inner': 'triggerEvent' },


    preRender: function preRender() {
      this.hasBeenRemoved = false;
    },

    render: function render() {
      var data = this.model.toJSON();
      var template = Handlebars.templates['notifyPush'];
      this.$el.html(template(data)).appendTo('#wrapper');

      _.defer(this.postRender.bind(this));

      return this;
    },

    postRender: function postRender() {
      this.$el.addClass('is-active');

      _.delay(this.closePush.bind(this), this.model.get('_timeout'));

      Adapt.trigger('notify:pushShown');
    },

    closePush: function closePush(event) {
      if (event) {
        event.preventDefault();
      }

      // Check whether this view has been removed as the delay can cause it to be fired twice
      if (this.hasBeenRemoved === false) {

        this.hasBeenRemoved = true;

        this.$el.removeClass('is-active');

        _.delay(function () {
          this.model.collection.remove(this.model);
          Adapt.trigger('notify:pushRemoved', this);
          this.remove();
        }.bind(this), 600);
      }
    },

    triggerEvent: function triggerEvent(event) {
      Adapt.trigger(this.model.get('_callbackEvent'));
      this.closePush();
    },

    updateIndexPosition: function updateIndexPosition() {
      if (!this.hasBeenRemoved) {
        var models = this.model.collection.models;
        for (var i = 0, len = models.length; i < len; i++) {
          var index = i;
          var model = models[i];
          if (model.get('_isActive') === true) {
            model.set('_index', index);
            this.updatePushPosition();
          }
        }
      }
    },

    updatePushPosition: function updatePushPosition() {
      if (this.hasBeenRemoved) {
        return;
      }

      if (typeof this.model.get('_index') !== 'undefined') {
        var elementHeight = this.$el.height();
        var offset = 20;
        var navigationHeight = $('.nav').height();
        var currentIndex = this.model.get('_index');
        var flippedIndex = currentIndex === 0 ? 1 : 0;

        if (this.model.collection.where({ _isActive: true }).length === 1) {
          flippedIndex = 0;
        }

        var positionLowerPush = (elementHeight + offset) * flippedIndex + navigationHeight + offset;
        this.$el.css('top', positionLowerPush);
      }
    } });


  return NotifyPushView;

});

define('core/js/models/notifyModel', [], function () {

  var NotifyModel = Backbone.Model.extend({
    defaults: {
      _isActive: false,
      _showIcon: false,
      _timeout: 3000 } });



  return NotifyModel;

});

define('core/js/collections/notifyPushCollection', [
'core/js/adapt',
'core/js/views/notifyPushView',
'core/js/models/notifyModel'],
function (Adapt, NotifyPushView, NotifyModel) {

  // Build a collection to store push notifications
  var NotifyPushCollection = Backbone.Collection.extend({

    model: NotifyModel,

    initialize: function initialize() {
      this.listenTo(this, 'add', this.onPushAdded);
      this.listenTo(Adapt, 'notify:pushRemoved', this.onRemovePush);
    },

    onPushAdded: function onPushAdded(model) {
      this.checkPushCanShow(model);
    },

    checkPushCanShow: function checkPushCanShow(model) {
      if (this.canShowPush()) {
        model.set('_isActive', true);
        this.showPush(model);
      }
    },

    canShowPush: function canShowPush() {
      var availablePushNotifications = this.where({ _isActive: true });
      if (availablePushNotifications.length >= 2) {
        return false;
      }
      return true;
    },

    showPush: function showPush(model) {
      new NotifyPushView({
        model: model });

    },

    onRemovePush: function onRemovePush(view) {
      var inactivePushNotifications = this.where({ _isActive: false });
      if (inactivePushNotifications.length > 0) {
        this.checkPushCanShow(inactivePushNotifications[0]);
      }
    } });



  return NotifyPushCollection;

});

define('core/js/childEvent', [
'core/js/adapt'],
function (Adapt) {

  /**
                   * Event object triggered for controlling child view rendering.
                   * Sent with 'view:addChild' and 'view:requestChild' events.
                   * All plugins receive the same object reference in their event handler and
                   * as such, this object becomes a place of consensus for plugins to decide how
                   * to handle rendering for this child.
                   */var
  ChildEvent = /*#__PURE__*/function (_Backbone$Controller4) {"use strict";_inherits(ChildEvent, _Backbone$Controller4);var _super13 = _createSuper(ChildEvent);function ChildEvent() {_classCallCheck(this, ChildEvent);return _super13.apply(this, arguments);}_createClass(ChildEvent, [{ key: "initialize",

      /**
                                                                                                                                                                                                                                                                                                                 * @param {string} type Event type
                                                                                                                                                                                                                                                                                                                 * @param {AdaptView} target Parent view
                                                                                                                                                                                                                                                                                                                 * @param {AdaptModel} model Child model
                                                                                                                                                                                                                                                                                                                 */value: function initialize(
      type, target, model) {
        /** @type {string} */
        this.type = type;
        /** @type {AdaptView} */
        this.target = target;
        /** @type {boolean} Force the child model to render */
        this.isForced = false;
        /** @type {boolean} Stop rendering before the child model */
        this.isStoppedImmediate = false;
        /** @type {boolean} Stop rendering after the child model */
        this.isStoppedNext = false;
        /** @type {boolean} Contains a model to render in response to a requestChild event */
        this.hasRequestChild = false;
        this._model = model;
      }

      /**
         * Get the model to be rendered.
         * @returns {AdaptModel}
         */ }, { key: "reset",





















      /**
                                * Reset all render stops.
                                */value: function reset()
      {
        this.isStoppedImmediate = false;
        this.isStoppedNext = false;
      }

      /**
         * Force model to render.
         */ }, { key: "force", value: function force()
      {
        this.isForced = true;
      }

      /**
         * General stop. Stop immediately or stop next with flag to false.
         * @param {boolean} [immediate=true] Flag to stop immediate or next.
         */ }, { key: "stop", value: function stop()
      {var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        if (!immediate) {
          return this.stopNext();
        }
        this.isStoppedImmediate = true;
      }

      /**
         * Shortcut to stop(false). Stop the render after the contained model is rendered.
         */ }, { key: "stopNext", value: function stopNext()
      {
        this.isStoppedNext = true;
      }

      /**
         * Trigger an event to signify that a final decision has been reached.
         */ }, { key: "close", value: function close()
      {
        this.trigger('closed');
      } }, { key: "model", get: function get() {return this._model;} /**
                                                                      * Set the model to render in response to a 'view:requestChild' event.
                                                                      * @param {AdaptModel}
                                                                      */, set: function set(model) {if (this.type !== 'requestChild') {Adapt.log.warn("Cannot change model in ".concat(this.type, " event."));return;}if (this._model) {Adapt.log.warn("Cannot inject two models in one sitting. ".concat(model.get('_id'), " attempts to overwrite ").concat(this._model.get('_id')));return;}this._model = model;this.hasRequestChild = true;} }]);return ChildEvent;}(Backbone.Controller);
  return ChildEvent;

});

define('core/js/views/adaptView', [
'core/js/adapt',
'../childEvent'],
function (Adapt, ChildEvent) {var

  AdaptView = /*#__PURE__*/function (_Backbone$View) {"use strict";_inherits(AdaptView, _Backbone$View);var _super14 = _createSuper(AdaptView);function AdaptView() {_classCallCheck(this, AdaptView);return _super14.apply(this, arguments);}_createClass(AdaptView, [{ key: "attributes", value: function attributes()

      {
        return {
          'data-adapt-id': this.model.get('_id') };

      } }, { key: "initialize", value: function initialize()

      {
        this.listenTo(this.model, {
          'change:_isVisible': this.toggleVisibility,
          'change:_isHidden': this.toggleHidden,
          'change:_isComplete': this.onIsCompleteChange });

        this.model.set({
          '_globals': Adapt.course.get('_globals'),
          '_isReady': false });

        this._isRemoved = false;

        if (Adapt.location._currentId === this.model.get('_id')) {
          Adapt.parentView = this;
        }

        this.preRender();
        this.render();
        this.setupOnScreenHandler();
      } }, { key: "preRender", value: function preRender()

      {} }, { key: "postRender", value: function postRender()

      {
        this.addChildren();
      } }, { key: "render", value: function render()

      {var _this39 = this;
        var type = this.constructor.type;
        Adapt.trigger("".concat(type, "View:preRender view:preRender"), this);

        var data = this.model.toJSON();
        data.view = this;
        var template = Handlebars.templates[this.constructor.template];
        this.$el.html(template(data));

        Adapt.trigger("".concat(type, "View:render view:render"), this);

        _.defer(function () {_newArrowCheck(this, _this39);
          // don't call postRender after remove
          if (this._isRemoved) return;

          this.postRender();
          Adapt.trigger("".concat(type, "View:postRender view:postRender"), this);
        }.bind(this));

        return this;
      } }, { key: "setupOnScreenHandler", value: function setupOnScreenHandler()

      {var _this40 = this;
        var onscreen = this.model.get('_onScreen');

        if (!onscreen || !onscreen._isEnabled) return;

        this.$el.addClass("has-animation ".concat(onscreen._classes, "-before"));
        this.$el.on('onscreen.adaptView', function (e, m) {_newArrowCheck(this, _this40);
          if (!m.onscreen) return;
          var minVerticalInview = onscreen._percentInviewVertical || 33;
          if (m.percentInviewVertical < minVerticalInview) return;
          this.$el.addClass("".concat(onscreen._classes, "-after")).off('onscreen.adaptView');
        }.bind(this));
      }

      /**
         * Add children and descendant views, first-child-first. Wait until all possible
         * views are added before resolving asynchronously.
         * Will trigger 'view:addChild'(ChildEvent), 'view:requestChild'(ChildEvent)
         * and 'view:childAdded'(ParentView, ChildView) accordingly.
         * @returns {number} Count of views added
         */ }, { key: "addChildren", value: function () {var _addChildren = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {var _this41 = this;var addedCount, models, event, subsequentModels, model, ChildView, childView;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:

                  this.nthChild = this.nthChild || 0;
                  // Check descendants first
                  _context9.next = 3;return this.addDescendants(false);case 3:addedCount = _context9.sent;case 4:if (!


                  true) {_context9.next = 26;break;}
                  models = this.model.getAvailableChildModels();
                  event = this._getAddChildEvent(models[this.nthChild]);if (
                  event) {_context9.next = 9;break;}return _context9.abrupt("break", 26);case 9:


                  if (event.isForced) {
                    event.reset();
                  }if (!(
                  event.isStoppedImmediate || !event.model)) {_context9.next = 14;break;}
                  // If addChild has been stopped before it is added then
                  // set all subsequent models and their children as not rendered
                  subsequentModels = models.slice(this.nthChild);
                  subsequentModels.forEach(function (model) {_newArrowCheck(this, _this41);return model.setOnChildren('_isRendered', false);}.bind(this));return _context9.abrupt("break", 26);case 14:


                  // Set model state
                  model = event.model;
                  model.set({
                    '_isRendered': true,
                    '_nthChild': ++this.nthChild });

                  // Create child view
                  ChildView = this.constructor.childView || Adapt.getViewClass(model);if (
                  ChildView) {_context9.next = 19;break;}throw (
                    new Error("The component '".concat(model.attributes._id, "' ('").concat(model.attributes._component, "') has not been installed, and so is not available in your project.")));case 19:

                  childView = new ChildView({ model: model });
                  this.addChildView(childView);
                  addedCount++;if (!
                  event.isStoppedNext) {_context9.next = 24;break;}return _context9.abrupt("break", 26);case 24:_context9.next = 4;break;case 26:if (




                  addedCount) {_context9.next = 28;break;}return _context9.abrupt("return",
                  addedCount);case 28:


                  // Children were added, unset _isReady
                  this.model.set('_isReady', false);return _context9.abrupt("return",
                  addedCount);case 30:case "end":return _context9.stop();}}}, _callee9, this);}));function addChildren() {return _addChildren.apply(this, arguments);}return addChildren;}()


      /**
                                                                                                                                                                                              * Child views can be added with '_renderPosition': 'outer-append' or
                                                                                                                                                                                              * 'inner-append' (default). Each child view will trigger a
                                                                                                                                                                                              * 'view:childAdded'(ParentView, ChildView) event and be added to the
                                                                                                                                                                                              * this.getChildViews() array on this parent.
                                                                                                                                                                                              * @param {AdaptView} childView
                                                                                                                                                                                              * @returns {AdaptView} Returns this childView
                                                                                                                                                                                              */ }, { key: "addChildView", value: function addChildView(
      childView) {
        var childViews = this.getChildViews() || [];
        childViews.push(childView);
        this.setChildViews(childViews);
        var $parentContainer = this.$(this.constructor.childContainer);
        switch (childView.model.get('_renderPosition')) {
          case 'outer-append':
            // Useful for trickle buttons, inline feedback etc
            this.$el.append(childView.$el);
            break;
          case 'inner-append':
          default:
            $parentContainer.append(childView.$el);
            break;}

        // Signify that a child has been added to the view to enable updates to status bars
        Adapt.trigger('view:childAdded', this, childView);
        return childView;
      }

      /**
         * Iterates through existing childViews and runs addChildren on them, resolving
         * the total count of views added asynchronously.
         * @returns {number} Count of views added
         */ }, { key: "addDescendants", value: function () {var _addDescendants = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {var addedDescendantCount, childViews, i, l, view;return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:

                  addedDescendantCount = 0;
                  childViews = this.getChildViews();if (
                  childViews) {_context10.next = 4;break;}return _context10.abrupt("return",
                  addedDescendantCount);case 4:

                  i = 0, l = childViews.length;case 5:if (!(i < l)) {_context10.next = 20;break;}
                  view = childViews[i];if (!
                  view.addChildren) {_context10.next = 13;break;}_context10.next = 10;return view.addChildren();case 10:_context10.t0 = _context10.sent;_context10.next = 14;break;case 13:_context10.t0 = 0;case 14:addedDescendantCount = _context10.t0;if (!
                  addedDescendantCount) {_context10.next = 17;break;}return _context10.abrupt("break", 20);case 17:i++;_context10.next = 5;break;case 20:if (



                  addedDescendantCount) {_context10.next = 23;break;}
                  this.model.checkReadyStatus();return _context10.abrupt("return",
                  addedDescendantCount);case 23:

                  // Descendants were added, unset _isReady
                  this.model.set('_isReady', false);return _context10.abrupt("return",
                  addedDescendantCount);case 25:case "end":return _context10.stop();}}}, _callee10, this);}));function addDescendants() {return _addDescendants.apply(this, arguments);}return addDescendants;}()


      /**
                                                                                                                                                                                                                   * Resolves after outstanding asynchronous view additions are finished
                                                                                                                                                                                                                   * and ready.
                                                                                                                                                                                                                   */ }, { key: "whenReady", value: function () {var _whenReady = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {var _this42 = this;return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:if (!

                  this.model.get('_isReady')) {_context11.next = 2;break;}return _context11.abrupt("return");case 2:return _context11.abrupt("return",
                  new Promise(function (resolve) {var _this43 = this;_newArrowCheck(this, _this42);
                    var _onReadyChange = function onReadyChange(model, value) {_newArrowCheck(this, _this43);
                      if (!value) return;
                      this.stopListening(this.model, 'change:_isReady', _onReadyChange);
                      resolve();
                    }.bind(this);
                    this.listenTo(this.model, 'change:_isReady', _onReadyChange);
                    this.model.checkReadyStatus();
                  }.bind(this)));case 3:case "end":return _context11.stop();}}}, _callee11, this);}));function whenReady() {return _whenReady.apply(this, arguments);}return whenReady;}()


      /**
                                                                                                                                                                                            * Triggers and returns a new ChildEvent object for render control.
                                                                                                                                                                                            * This function is used by addChildren to manage event triggering.
                                                                                                                                                                                            * @param {AdaptModel} model
                                                                                                                                                                                            * @returns {ChildEvent}
                                                                                                                                                                                            */ }, { key: "_getAddChildEvent", value: function _getAddChildEvent(
      model) {
        var isRequestChild = !model;
        var event = new ChildEvent(null, this, model);
        if (isRequestChild) {
          // No model has been supplied, we are at the end of the available child list
          var canRequestChild = this.model.get('_canRequestChild');
          if (!canRequestChild) {
            // This model cannot request children
            return;
          }
          event.type = 'requestChild';
          // Send a request asking for a new model
          Adapt.trigger('view:requestChild', event);
          if (!event.hasRequestChild) {
            // No new model was supplied
            // Close the event so that the final state can be scrutinized
            event.close();
            return;
          }
          // A new model has been supplied for the end of the list.
        }
        // Trigger an event to signify that a new model is to be added
        event.type = 'addChild';
        Adapt.trigger('view:addChild', event);
        // Close the event so that the final state can be scrutinized
        event.close();
        return event;
      }

      /**
         * Return an array of all child and descendant views.
         * @param {boolean} [isParentFirst=false] Array returns with parents before children
         * @returns {[AdaptView]}
         */ }, { key: "findDescendantViews", value: function findDescendantViews(
      isParentFirst) {var _this44 = this;
        var descendants = [];
        var childViews = this.getChildViews();
        childViews && childViews.forEach(function (view) {_newArrowCheck(this, _this44);
          if (isParentFirst) descendants.push(view);
          var children = view.findDescendantViews && view.findDescendantViews(isParentFirst);
          if (children) descendants.push.apply(descendants, _toConsumableArray(children));
          if (!isParentFirst) descendants.push(view);
        }.bind(this));
        return descendants;
      } }, { key: "setReadyStatus", value: function setReadyStatus()

      {
        this.model.set('_isReady', true);
      } }, { key: "setCompletionStatus", value: function setCompletionStatus()

      {
        if (!this.model.get('_isVisible')) return;
        this.model.set({
          _isComplete: true,
          _isInteractionComplete: true });

      } }, { key: "resetCompletionStatus", value: function resetCompletionStatus(

      type) {var _this45 = this;
        if (!this.model.get('_canReset')) return;

        var descendantComponents = this.model.findDescendantModels('component');
        if (descendantComponents.length === 0) {
          this.model.reset(type);
        } else {
          descendantComponents.forEach(function (model) {_newArrowCheck(this, _this45);return model.reset(type);}.bind(this));
        }
      } }, { key: "preRemove", value: function preRemove()

      {
        var type = this.constructor.type;
        Adapt.trigger("".concat(type, "View:preRemove view:preRemove"), this);
      } }, { key: "remove", value: function remove()

      {var _this46 = this;
        var type = this.constructor.type;
        this.preRemove();
        Adapt.trigger("".concat(type, "View:remove view:remove"), this);
        this._isRemoved = true;

        Adapt.wait.for(function (end) {var _this47 = this;_newArrowCheck(this, _this46);
          this.$el.off('onscreen.adaptView');
          _get(_getPrototypeOf(AdaptView.prototype), "remove", this).call(this);
          _.defer(function () {_newArrowCheck(this, _this47);
            Adapt.trigger("".concat(type, "View:postRemove view:postRemove"), this);
          }.bind(this));
          end();
        }.bind(this));

        return this;
      } }, { key: "setVisibility", value: function setVisibility()

      {
        return this.model.get('_isVisible') ? '' : 'u-visibility-hidden';
      } }, { key: "toggleVisibility", value: function toggleVisibility()

      {
        this.$el.toggleClass('u-visibility-hidden', !this.model.get('_isVisible'));
      } }, { key: "setHidden", value: function setHidden()

      {
        return this.model.get('_isHidden') ? 'u-display-none' : '';
      } }, { key: "toggleHidden", value: function toggleHidden()

      {
        this.$el.toggleClass('u-display-none', this.model.get('_isHidden'));
      } }, { key: "onIsCompleteChange", value: function onIsCompleteChange(

      model, isComplete) {
        this.$el.toggleClass('is-complete', isComplete);
      }

      /**
         * @returns {[AdaptViews]}
         */ }, { key: "getChildViews", value: function getChildViews()
      {
        return this._childViews;
      }

      /**
         * @param {[AdaptView]} value
         */ }, { key: "setChildViews", value: function setChildViews(
      value) {
        this._childViews = value;
      }

      /**
         * Returns an indexed by id list of child views.
         * @deprecated since 0.5.5
         * @returns {{<string, AdaptView}}
         */ }, { key: "childViews", get: function get()
      {var _this48 = this;
        Adapt.log.deprecated("view.childViews use view.getChildViews()");
        return _.indexBy(this.getChildViews(), function (view) {_newArrowCheck(this, _this48);return view.model.get('_id');}.bind(this));
      } }]);return AdaptView;}(Backbone.View);



  AdaptView.className = '';

  return AdaptView;

});

define('core/js/views/notifyView', [
'core/js/adapt',
"core/js/views/adaptView"],
function (Adapt, AdaptView) {var

  NotifyView = /*#__PURE__*/function (_Backbone$View2) {"use strict";_inherits(NotifyView, _Backbone$View2);var _super15 = _createSuper(NotifyView);function NotifyView() {_classCallCheck(this, NotifyView);return _super15.apply(this, arguments);}_createClass(NotifyView, [{ key: "className", value: function className()

      {
        return "notify ".concat(this.model.get('_classes') || '');
      } }, { key: "attributes", value: function attributes()

      {
        return Object.assign({
          role: 'dialog',
          'aria-labelledby': 'notify-heading',
          'aria-modal': 'true' },
        this.model.get('_attributes'));
      } }, { key: "events", value: function events()

      {
        return {
          'click .js-notify-btn-alert': 'onAlertButtonClicked',
          'click .js-notify-btn-prompt': 'onPromptButtonClicked',
          'click .js-notify-close-btn': 'onCloseButtonClicked',
          'click .js-notify-shadow-click': 'onShadowClicked' };

      } }, { key: "initialize", value: function initialize()

      {
        _.bindAll(this, 'resetNotifySize', 'onKeyUp');
        this.disableAnimation = Adapt.config.get('_disableAnimation') || false;
        this.isOpen = false;
        this.hasOpened = false;
        this.setupEventListeners();
        this.render();
      } }, { key: "setupEventListeners", value: function setupEventListeners()

      {
        this.listenTo(Adapt, {
          'remove page:scrollTo': this.closeNotify,
          'notify:resize': this.resetNotifySize,
          'notify:cancel': this.cancelNotify,
          'notify:close': this.closeNotify,
          'device:resize': this.resetNotifySize });

        this.setupEscapeKey();
      } }, { key: "setupEscapeKey", value: function setupEscapeKey()

      {
        $(window).on('keyup', this.onKeyUp);
      } }, { key: "onKeyUp", value: function onKeyUp(

      event) {
        if (event.which !== 27) return;
        event.preventDefault();
        this.cancelNotify();
      } }, { key: "render", value: function render()

      {
        var data = this.model.toJSON();
        var template = Handlebars.templates.notify;
        // hide notify container
        this.$el.css('visibility', 'hidden');
        // attach popup + shadow
        this.$el.html(template(data)).appendTo('body');
        // hide popup
        this.$('.notify__popup').css('visibility', 'hidden');
        // show notify container
        this.$el.css('visibility', 'visible');
        this.showNotify();
        return this;
      } }, { key: "onAlertButtonClicked", value: function onAlertButtonClicked(

      event) {
        event.preventDefault();
        // tab index preservation, notify must close before subsequent callback is triggered
        this.closeNotify();
        Adapt.trigger(this.model.get('_callbackEvent'), this);
      } }, { key: "onPromptButtonClicked", value: function onPromptButtonClicked(

      event) {
        event.preventDefault();
        // tab index preservation, notify must close before subsequent callback is triggered
        this.closeNotify();
        Adapt.trigger($(event.currentTarget).attr('data-event'), this);
      } }, { key: "onCloseButtonClicked", value: function onCloseButtonClicked(

      event) {
        event.preventDefault();
        // tab index preservation, notify must close before subsequent callback is triggered
        this.cancelNotify();
      } }, { key: "onShadowClicked", value: function onShadowClicked(

      event) {
        event.preventDefault();
        if (this.model.get('_closeOnShadowClick') === false) return;
        this.cancelNotify();
      } }, { key: "cancelNotify", value: function cancelNotify()

      {
        if (this.model.get('_isCancellable') === false) return;
        // tab index preservation, notify must close before subsequent callback is triggered
        this.closeNotify();
        Adapt.trigger('notify:cancelled', this);
      } }, { key: "resetNotifySize", value: function resetNotifySize()

      {
        if (!this.hasOpened) return;
        this.resizeNotify();
      } }, { key: "resizeNotify", value: function resizeNotify()

      {
        var windowHeight = $(window).height();
        var notifyHeight = this.$('.notify__popup-inner').outerHeight();
        var isFullWindow = notifyHeight >= windowHeight;
        this.$('.notify__popup').css({
          'height': isFullWindow ? '100%' : 'auto',
          'top': isFullWindow ? 0 : '',
          'margin-top': isFullWindow ? '' : -(notifyHeight / 2),
          'overflow-y': isFullWindow ? 'scroll' : '',
          '-webkit-overflow-scrolling': isFullWindow ? 'touch' : '' });

      } }, { key: "showNotify", value: function () {var _showNotify = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:


                  this.isOpen = true;_context12.next = 3;return (
                    this.addSubView());case 3:
                  // Add to the list of open popups
                  Adapt.notify.stack.push(this);
                  // Keep focus from previous action
                  this.$previousActiveElement = $(document.activeElement);
                  Adapt.trigger('notify:opened', this);
                  this.$el.imageready(this.onLoaded.bind(this));case 7:case "end":return _context12.stop();}}}, _callee12, this);}));function showNotify() {return _showNotify.apply(this, arguments);}return showNotify;}() }, { key: "onLoaded", value: function onLoaded()


      {var _this49 = this;
        if (this.disableAnimation) {
          this.$('.notify__shadow').css('display', 'block');
        } else {
          this.$('.notify__shadow').velocity({ opacity: 0 }, { duration: 0 }).velocity({ opacity: 1 }, { duration: 400,
            begin: function begin() {_newArrowCheck(this, _this49);
              this.$('.notify__shadow').css('display', 'block');
            }.bind(this) });

        }
        this.resizeNotify();
        if (this.disableAnimation) {
          this.$('.notify__popup').css('visibility', 'visible');
          this.onOpened();
        } else {
          this.$('.notify__popup').velocity({ opacity: 0 }, { duration: 0 }).velocity({ opacity: 1 }, { duration: 400,
            begin: function begin() {_newArrowCheck(this, _this49);
              // Make sure to make the notify visible and then set
              // focus, disabled scroll and manage tabs
              this.$('.notify__popup').css('visibility', 'visible');
              this.onOpened();
            }.bind(this) });

        }
      } }, { key: "onOpened", value: function onOpened()

      {
        $.inview();
        this.hasOpened = true;
        // Allows popup manager to control focus
        Adapt.a11y.popupOpened(this.$('.notify__popup'));
        Adapt.a11y.scrollDisable('body');
        $('html').addClass('notify');
        // Set focus to first accessible element
        Adapt.a11y.focusFirst(this.$('.notify__popup'), { defer: false });
      } }, { key: "addSubView", value: function () {var _addSubView = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {var _this50 = this;var model, View;return regeneratorRuntime.wrap(function _callee13$(_context13) {while (1) {switch (_context13.prev = _context13.next) {case 0:


                  this.subView = this.model.get('_view');
                  if (this.model.get('_id')) {
                    // Automatically render the specified id
                    model = Adapt.findById(this.model.get('_id'));
                    View = Adapt.getViewClass(model);
                    this.subView = new View({ model: model });
                  }if (
                  this.subView) {_context13.next = 4;break;}return _context13.abrupt("return");case 4:
                  this.subView.$el.on('resize', this.resetNotifySize);
                  this.$('.notify__content-inner').prepend(this.subView.$el);if (!(
                  !(this.subView instanceof AdaptView) || this.subView.model.get('_isReady'))) {_context13.next = 8;break;}return _context13.abrupt("return");case 8:return _context13.abrupt("return",

                  new Promise(function (resolve) {var _this51 = this;_newArrowCheck(this, _this50);
                    var _check = function check(model, value) {_newArrowCheck(this, _this51);
                      if (!value) return;
                      this.subView.model.off('change:_isReady', _check);
                      resolve();
                    }.bind(this);
                    this.subView.model.on('change:_isReady', _check);
                  }.bind(this)));case 9:case "end":return _context13.stop();}}}, _callee13, this);}));function addSubView() {return _addSubView.apply(this, arguments);}return addSubView;}() }, { key: "closeNotify", value: function closeNotify()


      {var _this52 = this;
        // Make sure that only the top most notify is closed
        var stackItem = Adapt.notify.stack[Adapt.notify.stack.length - 1];
        if (this !== stackItem) return;
        Adapt.notify.stack.pop();
        // Prevent from being invoked multiple times - see https://github.com/adaptlearning/adapt_framework/issues/1659
        if (!this.isOpen) return;
        this.isOpen = false;
        // If closeNotify is called before showNotify has finished then wait
        // until it's open.
        if (this.hasOpened) {
          this.onCloseReady();
          return;
        }
        this.listenToOnce(Adapt, 'popup:opened', function () {_newArrowCheck(this, _this52);
          // Wait for popup:opened to finish processing
          _.defer(this.onCloseReady.bind(this));
        }.bind(this));
      } }, { key: "onCloseReady", value: function onCloseReady()

      {var _this53 = this;
        if (this.disableAnimation) {
          this.$('.notify__popup').css('visibility', 'hidden');
          this.$el.css('visibility', 'hidden');
          this.remove();
        } else {
          this.$('.notify__popup').velocity({ opacity: 0 }, { duration: 400,
            complete: function complete() {_newArrowCheck(this, _this53);
              this.$('.notify__popup').css('visibility', 'hidden');
            }.bind(this) });

          this.$('.notify__shadow').velocity({ opacity: 0 }, { duration: 400,
            complete: function complete() {_newArrowCheck(this, _this53);
              this.$el.css('visibility', 'hidden');
              this.remove();
            }.bind(this) });

        }
        Adapt.a11y.scrollEnable('body');
        $('html').removeClass('notify');
        // Return focus to previous active element
        Adapt.a11y.popupClosed(this.$previousActiveElement);
        // Return reference to the notify view
        Adapt.trigger('notify:closed', this);
      } }, { key: "remove", value: function remove()

      {var _get2;
        this.removeSubView();
        $(window).off('keyup', this.onKeyUp);for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {args[_key13] = arguments[_key13];}
        (_get2 = _get(_getPrototypeOf(NotifyView.prototype), "remove", this)).call.apply(_get2, [this].concat(args));
      } }, { key: "removeSubView", value: function removeSubView()

      {var _this54 = this;
        if (!this.subView) return;
        this.subView.$el.off('resize', this.resetNotifySize);
        if (this.subView instanceof AdaptView) {
          // Clear up nested views and models
          var views = [].concat(_toConsumableArray(this.subView.findDescendantViews()), [this.subView]);
          views.forEach(function (view) {_newArrowCheck(this, _this54);
            view.model.set('_isReady', false);
            view.remove();
          }.bind(this));
        } else {
          this.subView.remove();
        }
        this.subView = null;
      } }]);return NotifyView;}(Backbone.View);



  return NotifyView;

});

define('core/js/notify', [
'core/js/adapt',
'core/js/collections/notifyPushCollection',
'core/js/views/notifyView',
'core/js/models/notifyModel'],
function (Adapt, NotifyPushCollection, NotifyView, NotifyModel) {var

  Notify = /*#__PURE__*/function (_Backbone$Controller5) {"use strict";_inherits(Notify, _Backbone$Controller5);var _super16 = _createSuper(Notify);function Notify() {_classCallCheck(this, Notify);return _super16.apply(this, arguments);}_createClass(Notify, [{ key: "initialize", value: function initialize()

      {
        this._stack = [];
        this.notifyPushes = new NotifyPushCollection();
        this.listenTo(Adapt, {
          'notify:popup': this._deprecated.bind(this, 'popup'),
          'notify:alert': this._deprecated.bind(this, 'alert'),
          'notify:prompt': this._deprecated.bind(this, 'prompt'),
          'notify:push': this._deprecated.bind(this, 'push') });

      } }, { key: "_deprecated", value: function _deprecated(





      type, notifyObject) {
        Adapt.log.deprecated("NOTIFY DEPRECATED: Adapt.trigger('notify:".concat(type, "', notifyObject); is no longer supported, please use Adapt.notify.").concat(type, "(notifyObject);"));
        return this.create(notifyObject, { _type: type });
      } }, { key: "create", value: function create(

      notifyObject, defaults) {
        notifyObject = _.defaults({}, notifyObject, defaults, {
          _type: 'popup',
          _isCancellable: true,
          _showCloseButton: true,
          _closeOnShadowClick: true });


        if (notifyObject._type === 'push') {
          this.notifyPushes.push(notifyObject);
          return;
        }

        return new NotifyView({
          model: new NotifyModel(notifyObject) });

      }

      /**
         * Creates a 'popup' notify
         * @param {Object} notifyObject An object containing all the settings for the popup
         * @param {string} notifyObject.title Title of the popup
         * @param {string} notifyObject.body Body of the popup
         * @param {Boolean} [notifyObject._showCloseButton=true] If set to `false` the popup will not have a close button. The learner will still be able to dismiss the popup by clicking outside of it or by pressing the Esc key. This setting is typically used mainly for popups that have a subview (where the subview contains the close button)
         * @param {Boolean} [notifyObject._isCancellable=true] If set to `false` the learner will not be able to close the popup - use with caution!
         * @param {string} [notifyObject._classes] A class name or (space separated) list of class names you'd like to be applied to the popup's `<div>`
         * @param {Backbone.View} [notifyObject._view] Subview to display in the popup instead of the standard view
         */ }, { key: "popup", value: function popup(
      notifyObject) {
        return this.create(notifyObject, { _type: 'popup' });
      }

      /**
         * Creates an 'alert' notify popup
         * @param {Object} notifyObject An object containing all the settings for the alert popup
         * @param {string} notifyObject.title Title of the alert popup
         * @param {string} notifyObject.body Body of the alert popup
         * @param {string} notifyObject.confirmText Label for the popup confirm button
         * @param {Boolean} [notifyObject._isCancellable=true] If set to `false` only the confirm button can be used to dismiss/close the popup
         * @param {Boolean} [notifyObject._showIcon=false] If set to `true` an 'alert' icon will be displayed in the popup
         * @param {string} [notifyObject._callbackEvent] Event to trigger when the confirm button is clicked
         * @param {string} [notifyObject._classes] A class name or (space separated) list of class names you'd like to be applied to the popup's `<div>`
         * @param {Backbone.View} [notifyObject._view] Subview to display in the popup instead of the standard view
         */ }, { key: "alert", value: function alert(
      notifyObject) {
        return this.create(notifyObject, { _type: 'alert' });
      }

      /**
         * Creates a 'prompt dialog' notify popup
         * @param {Object} notifyObject An object containing all the settings for the prompt dialog
         * @param {string} notifyObject.title Title of the prompt
         * @param {string} notifyObject.body Body of the prompt
         * @param {Object[]} notifyObject._prompts Array of objects that each define a button (and associated callback event) that you want shown in the prompt
         * @param {string} notifyObject._prompts[].promptText Label for this button
         * @param {string} notifyObject._prompts[]._callbackEvent Event to be triggered when this button is clicked
         * @param {Boolean} [notifyObject._isCancellable=true] If set to `false` only the confirm button can be used to dismiss/close the prompt
         * @param {Boolean} [notifyObject._showIcon=true] If set to `true` a 'query' icon will be displayed in the popup
         * @param {string} [notifyObject._callbackEvent] Event to trigger when the confirm button is clicked
         * @param {string} [notifyObject._classes] A class name or (space separated) list of class names you'd like to be applied to the popup's `<div>`
         * @param {Backbone.View} [notifyObject._view] Subview to display in the popup instead of the standard view
         */ }, { key: "prompt", value: function prompt(
      notifyObject) {
        return this.create(notifyObject, { _type: 'prompt' });
      }

      /**
         * Creates a 'push notification'
         * @param {Object} notifyObject An object containing all the settings for the push notification
         * @param {string} notifyObject.title Title of the push notification
         * @param {string} notifyObject.body Body of the push notification
         * @param {Number} [notifyObject._timeout=3000] Length of time (in milliseconds) the notification should left on-screen before automatically fading away
         * @param {string} notifyObject._callbackEvent Event to be triggered if the learner clicks on the push notification (not triggered if they use the close button)
         * @param {string} [notifyObject._classes] A class name or (space separated) list of class names you'd like to be applied to the popup's `<div>`
         */ }, { key: "push", value: function push(
      notifyObject) {
        return this.create(notifyObject, { _type: 'push' });
      } }, { key: "stack", get: function get() {return this._stack;} }]);return Notify;}(Backbone.Controller);



  return Adapt.notify = new Notify();

});

define('core/js/models/routerModel', [
'core/js/adapt'],
function (Adapt) {var

  RouterModel = /*#__PURE__*/function (_Backbone$Model5) {"use strict";_inherits(RouterModel, _Backbone$Model5);var _super17 = _createSuper(RouterModel);function RouterModel() {_classCallCheck(this, RouterModel);return _super17.apply(this, arguments);}_createClass(RouterModel, [{ key: "defaults", value: function defaults()

      {
        return {
          _canNavigate: true,
          _shouldNavigateFocus: true };

      } }, { key: "lockedAttributes", value: function lockedAttributes()

      {
        return {
          _canNavigate: false,
          _shouldNavigateFocus: false };

      } }]);return RouterModel;}(Backbone.Model);



  return RouterModel;

});

define('core/js/router', [
'core/js/adapt',
'core/js/models/routerModel',
'core/js/models/courseModel',
'core/js/models/contentObjectModel',
'core/js/models/menuModel',
'core/js/startController'],
function (Adapt, RouterModel, CourseModel, ContentObjectModel, MenuModel) {var

  Router = /*#__PURE__*/function (_Backbone$Router) {"use strict";_inherits(Router, _Backbone$Router);var _super18 = _createSuper(Router);function Router() {_classCallCheck(this, Router);return _super18.apply(this, arguments);}_createClass(Router, [{ key: "routes", value: function routes()

      {
        return {
          '': 'handleRoute',
          'id/:id': 'handleRoute',
          ':pluginName(/*location)(/*action)': 'handleRoute' };

      } }, { key: "initialize", value: function initialize(_ref4)

      {var model = _ref4.model;
        this.model = model;
        this._navigationRoot = null;
        // Flag to indicate if the router has tried to redirect to the current location.
        this._isCircularNavigationInProgress = false;
        this.showLoading();
        // Store #wrapper element and html to cache for later use.
        this.$wrapper = $('#wrapper');
        this.$html = $('html');
        this.listenToOnce(Adapt, 'app:dataReady', this.setDocumentTitle);
        this.listenTo(Adapt, 'router:navigateTo', this.navigateToArguments);
      } }, { key: "showLoading", value: function showLoading()









      {
        $('.js-loading').show();
      } }, { key: "hideLoading", value: function hideLoading()

      {
        $('.js-loading').hide();
      } }, { key: "setDocumentTitle", value: function setDocumentTitle()

      {var _this55 = this;
        var currentModel = Adapt.location._currentModel;
        var hasSubTitle = currentModel && currentModel !== Adapt.router.rootModel && currentModel.get('title');
        var title = [
        this.rootModel.get('title'),
        hasSubTitle && currentModel.get('title')].
        filter(Boolean).join(' | ');
        this.listenToOnce(Adapt, 'contentObjectView:preRender', function () {_newArrowCheck(this, _this55);
          var escapedTitle = $("<div>".concat(title, "</div>")).text();
          document.title = escapedTitle;
        }.bind(this));
      } }, { key: "navigateToArguments", value: function navigateToArguments(

      args) {var _this56 = this;
        args = args.filter(function (v) {_newArrowCheck(this, _this56);return v !== null;}.bind(this));
        var options = { trigger: false, replace: false };
        if (args.length === 1 && Adapt.findById(args[0])) {
          this.navigate('#/id/' + args[0], options);
          return;
        }
        if (args.length <= 3) {
          this.navigate('#/' + args.join('/'), options);
          return;
        }
        Adapt.log.deprecated("Use Backbone.history.navigate or window.location.href instead of Adapt.trigger('router:navigateTo')");
        this.handleRoute.apply(this, _toConsumableArray(args));
      } }, { key: "handleRoute", value: function handleRoute()

      {var _this57 = this;for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {args[_key14] = arguments[_key14];}
        args = args.filter(function (v) {_newArrowCheck(this, _this57);return v !== null;}.bind(this));

        if (this.model.get('_canNavigate')) {
          // Reset _isCircularNavigationInProgress protection as code is allowed to navigate away.
          this._isCircularNavigationInProgress = false;
        }

        // Check if the current page is in the process of navigating to itself.
        // It will redirect to itself if the URL was changed and _canNavigate is false.
        if (this._isCircularNavigationInProgress === false) {
          // Trigger an event pre 'router:location' to allow extensions to stop routing.
          Adapt.trigger('router:navigate', args);
        }

        // Re-check as _canNavigate can be set to false on 'router:navigate' event.
        if (this.model.get('_canNavigate')) {
          // Disable navigation whilst rendering.
          this.model.set('_canNavigate', false, { pluginName: 'adapt' });
          if (args.length <= 1) {
            return this.handleId.apply(this, _toConsumableArray(args));
          }
          return this.handlePluginRouter.apply(this, _toConsumableArray(args));
        }

        if (this._isCircularNavigationInProgress) {
          // Navigation correction finished.
          // Router has successfully re-navigated to the current _id as the URL was changed
          // while _canNavigate: false
          this._isCircularNavigationInProgress = false;
          return;
        }

        // Cancel navigation to stay at the current location.
        this._isCircularNavigationInProgress = true;
        Adapt.trigger('router:navigationCancelled', args);

        // Reset URL to the current one.
        this.navigateToCurrentRoute(true);
      } }, { key: "handlePluginRouter", value: function () {var _handlePluginRouter = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(

        pluginName, location, action) {var pluginLocation;return regeneratorRuntime.wrap(function _callee14$(_context14) {while (1) {switch (_context14.prev = _context14.next) {case 0:
                  pluginLocation = [
                  pluginName,
                  location && "-".concat(location),
                  action && "-".concat(action)].
                  filter(Boolean).join('');_context14.next = 3;return (
                    this.updateLocation(pluginLocation, null, null, null));case 3:

                  Adapt.trigger('router:plugin:' + pluginName, pluginName, location, action);
                  Adapt.trigger('router:plugin', pluginName, location, action);
                  this.model.set('_canNavigate', true, { pluginName: 'adapt' });case 6:case "end":return _context14.stop();}}}, _callee14, this);}));function handlePluginRouter(_x4, _x5, _x6) {return _handlePluginRouter.apply(this, arguments);}return handlePluginRouter;}() }, { key: "handleId", value: function () {var _handleId = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(


        id) {var _this58 = this;var rootModel, model, isContentObject, navigateToId, isRoot, startController, isCourse, type, location, ViewClass, isMenu;return regeneratorRuntime.wrap(function _callee15$(_context15) {while (1) {switch (_context15.prev = _context15.next) {case 0:
                  rootModel = Adapt.router.rootModel;
                  model = !id ? rootModel : Adapt.findById(id);if (

                  model) {_context15.next = 5;break;}
                  // Bad id
                  this.model.set('_canNavigate', true, { pluginName: 'adapt' });return _context15.abrupt("return");case 5:



                  // Keep the routed id incase it needs to be scrolled to later
                  isContentObject = model instanceof ContentObjectModel;
                  navigateToId = model.get('_id');

                  // Ensure that the router is rendering a contentobject
                  model = isContentObject ? model : model.findAncestor('contentobject');
                  id = model.get('_id');

                  isRoot = model === rootModel;if (!(
                  isRoot && Adapt.course.has('_start'))) {_context15.next = 14;break;}
                  // Do not allow access to the menu when the start controller is enabled.
                  startController = Adapt.course.get('_start');if (!(
                  startController._isEnabled === true && startController._isMenuDisabled === true)) {_context15.next = 14;break;}return _context15.abrupt("return");case 14:if (!(




                  model.get('_isLocked') && Adapt.config.get('_forceRouteLocking'))) {_context15.next = 20;break;}
                  // Locked id
                  Adapt.log.warn('Unable to navigate to locked id: ' + id);
                  this.model.set('_canNavigate', true, { pluginName: 'adapt' });if (!(
                  Adapt.location._previousId === undefined)) {_context15.next = 19;break;}return _context15.abrupt("return",
                  this.navigate('#/', { trigger: true, replace: true }));case 19:return _context15.abrupt("return",

                  this.navigateBack());case 20:


                  // Move to a content object
                  this.showLoading();_context15.next = 23;return (
                    Adapt.remove());case 23:

                  /**
                                              * TODO:
                                              * As the course object has separate location and type rules,
                                              * it makes it more difficult to update the Adapt.location object
                                              * should stop doing this.
                                              */
                  isCourse = model instanceof CourseModel;
                  type = isCourse ? 'menu' : model.get('_type');
                  location = isCourse ? 'course' : "".concat(type, "-").concat(id);

                  model.set('_isVisited', true);_context15.next = 29;return (
                    this.updateLocation(location, type, id, model));case 29:

                  Adapt.once('contentObjectView:ready', function () {_newArrowCheck(this, _this58);
                    // Allow navigation.
                    this.model.set('_canNavigate', true, { pluginName: 'adapt' });
                    this.handleNavigationFocus();
                  }.bind(this));
                  Adapt.trigger("router:".concat(type, " router:contentObject"), model);

                  ViewClass = Adapt.getViewClass(model);
                  isMenu = model instanceof MenuModel;if (!(
                  !ViewClass && isMenu)) {_context15.next = 36;break;}
                  Adapt.log.deprecated("Using event based menu view instantiation for '".concat(Adapt.getViewName(model), "'"));return _context15.abrupt("return");case 36:


                  this.$wrapper.append(new ViewClass({ model: model }).$el);if (!(

                  !isContentObject && !this.isScrolling)) {_context15.next = 40;break;}_context15.next = 40;return (

                    Adapt.navigateToElement('.' + navigateToId, { replace: true, duration: 400 }));case 40:case "end":return _context15.stop();}}}, _callee15, this);}));function handleId(_x7) {return _handleId.apply(this, arguments);}return handleId;}() }, { key: "updateLocation", value: function () {var _updateLocation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(




        currentLocation, type, id, currentModel) {return regeneratorRuntime.wrap(function _callee16$(_context16) {while (1) {switch (_context16.prev = _context16.next) {case 0:
                  // Handles updating the location.
                  Adapt.location._previousModel = Adapt.location._currentModel;
                  Adapt.location._previousId = Adapt.location._currentId;
                  Adapt.location._previousContentType = Adapt.location._contentType;

                  Adapt.location._currentModel = currentModel;
                  Adapt.location._currentId = id;
                  Adapt.location._contentType = type;
                  Adapt.location._currentLocation = currentLocation;

                  /**
                                                                      * TODO:
                                                                      * this if block should be removed,
                                                                      * these properties are unused in the framework
                                                                      */
                  if (type === 'menu') {
                    Adapt.location._lastVisitedType = 'menu';
                    Adapt.location._lastVisitedMenu = id;
                  } else if (type === 'page') {
                    Adapt.location._lastVisitedType = 'page';
                    Adapt.location._lastVisitedPage = id;
                  }

                  this.setDocumentTitle();
                  this.setGlobalClasses();

                  // Trigger event when location changes.
                  Adapt.trigger('router:location', Adapt.location);_context16.next = 13;return (

                    Adapt.wait.queue());case 13:case "end":return _context16.stop();}}}, _callee16, this);}));function updateLocation(_x8, _x9, _x10, _x11) {return _updateLocation.apply(this, arguments);}return updateLocation;}() }, { key: "setGlobalClasses", value: function setGlobalClasses()


      {
        var currentModel = Adapt.location._currentModel;

        var htmlClasses = currentModel && currentModel.get('_htmlClasses') || '';
        var classes = Adapt.location._currentId ? "location-".concat(
        Adapt.location._contentType, " location-id-").concat(Adapt.location._currentId) : "location-".concat(
        Adapt.location._currentLocation);
        var currentClasses = "".concat(classes, " ").concat(htmlClasses);

        this.$html.
        removeClass(Adapt.location._previousClasses).
        addClass(currentClasses).
        attr('data-location', Adapt.location._currentLocation);

        this.$wrapper.
        removeClass().
        addClass(classes).
        attr('data-location', Adapt.location._currentLocation);

        Adapt.location._previousClasses = currentClasses;
      } }, { key: "handleNavigationFocus", value: function handleNavigationFocus()

      {
        if (!this.model.get('_shouldNavigateFocus')) return;
        // Body will be forced to accept focus to start the
        // screen reader reading the page.
        Adapt.a11y.focus('body');
      } }, { key: "navigateBack", value: function navigateBack()

      {
        Backbone.history.history.back();
      } }, { key: "navigateToCurrentRoute", value: function navigateToCurrentRoute(

      force) {
        if (!this.model.get('_canNavigate') && !force) {
          return;
        }
        if (!Adapt.location._currentId) {
          return;
        }
        var currentId = Adapt.location._currentModel.get('_id');
        var isRoot = Adapt.location._currentModel === this.rootModel;
        var route = isRoot ? '#/' : '#/id/' + currentId;
        this.navigate(route, { trigger: true, replace: true });
      } }, { key: "navigateToPreviousRoute", value: function navigateToPreviousRoute(

      force) {
        // Sometimes a plugin might want to stop the default navigation.
        // Check whether default navigation has changed.
        if (!this.model.get('_canNavigate') && !force) {
          return;
        }
        var currentModel = Adapt.location._currentModel;
        var previousModel = Adapt.location._previousModel;
        if (!currentModel) {
          return this.navigateBack();
        }
        if (Adapt.location._currentModel instanceof MenuModel) {
          return this.navigateToParent();
        }
        if (previousModel) {
          return this.navigateBack();
        }
        this.navigateToParent();
      } }, { key: "navigateToParent", value: function navigateToParent(

      force) {
        if (!this.model.get('_canNavigate') && !force) {
          return;
        }
        var parentId = Adapt.location._currentModel.get('_parentId');
        var parentModel = Adapt.findById(parentId);
        var isRoot = parentModel === this.rootModel;
        var route = isRoot ? '#/' : '#/id/' + parentId;
        this.navigate(route, { trigger: true });
      } }, { key: "navigateToHomeRoute", value: function navigateToHomeRoute(

      force) {
        if (!this.model.get('_canNavigate') && !force) {
          return;
        }
        this.navigate('#/', { trigger: true });
      }

      /**
         * Allows a selector or id to be passed in and Adapt will navigate to this element. Resolves
         * asynchronously when the element has been navigated to.
         * Backend for Adapt.navigateToElement
         * @param {string} selector CSS selector or id of the Adapt element you want to navigate to e.g. `".co-05"` or `"co-05"`
         * @param {Object} [settings] The settings for the `$.scrollTo` function (See https://github.com/flesler/jquery.scrollTo#settings).
         * @param {Object} [settings.replace=false] Set to `true` if you want to update the URL without creating an entry in the browser's history.
         */ }, { key: "navigateToElement", value: function () {var _navigateToElement2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(
        selector) {var _this59 = this;var settings,currentModelId,currentModel,shouldReplace,contentObject,contentObjectId,isInCurrentContentObject,location,disableScrollToAnimation,offsetTop,_args17 = arguments;return regeneratorRuntime.wrap(function _callee17$(_context17) {while (1) {switch (_context17.prev = _context17.next) {case 0:settings = _args17.length > 1 && _args17[1] !== undefined ? _args17[1] : {};
                  currentModelId = selector.replace(/\./g, '').split(' ')[0];
                  currentModel = Adapt.findById(currentModelId);if (!(

                  currentModel && (!currentModel.get('_isRendered') || !currentModel.get('_isReady')))) {_context17.next = 17;break;}
                  shouldReplace = settings.replace || false;
                  contentObject = currentModel instanceof ContentObjectModel ? currentModel : currentModel.findAncestor('contentobject');
                  contentObjectId = contentObject.get('_id');
                  isInCurrentContentObject = contentObjectId !== Adapt.location._currentId;if (!
                  isInCurrentContentObject) {_context17.next = 15;break;}
                  this.isScrolling = true;
                  this.navigate("#/id/".concat(currentModelId), { trigger: true, replace: shouldReplace });
                  this.model.set('_shouldNavigateFocus', false, { pluginName: 'adapt' });_context17.next = 14;return (
                    new Promise(function (resolve) {var _this60 = this;_newArrowCheck(this, _this59);return Adapt.once('contentObjectView:ready', _.debounce(function () {_newArrowCheck(this, _this60);
                        this.model.set('_shouldNavigateFocus', true, { pluginName: 'adapt' });
                        resolve();
                      }.bind(this), 1));}.bind(this)));case 14:
                  this.isScrolling = false;case 15:_context17.next = 17;return (

                    Adapt.parentView.renderTo(currentModelId));case 17:


                  // Correct selector when passed a pure id
                  if (currentModel && selector === currentModel.get('_id')) {
                    selector = ".".concat(selector);
                  }

                  // Get the current location - this is set in the router
                  location = Adapt.location._contentType ?
                  Adapt.location._contentType : Adapt.location._currentLocation;
                  // Trigger initial scrollTo event
                  Adapt.trigger("".concat(location, ":scrollTo"), selector);
                  // Setup duration variable
                  disableScrollToAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
                  if (disableScrollToAnimation) {
                    settings.duration = 0;
                  } else if (!settings.duration) {
                    settings.duration = $.scrollTo.defaults.duration;
                  }

                  offsetTop = 0;
                  if (Adapt.scrolling.isLegacyScrolling) {
                    offsetTop = -$('.nav').outerHeight();
                    // prevent scroll issue when component description aria-label coincident with top of component
                    if ($(selector).hasClass('component')) {
                      offsetTop -= $(selector).find('.aria-label').height() || 0;
                    }
                  }

                  if (!settings.offset) settings.offset = { top: offsetTop, left: 0 };
                  if (settings.offset.top === undefined) settings.offset.top = offsetTop;
                  if (settings.offset.left === undefined) settings.offset.left = 0;

                  if (settings.offset.left === 0) settings.axis = 'y';

                  if (Adapt.get('_canScroll') !== false) {
                    // Trigger scrollTo plugin
                    $.scrollTo(selector, settings);
                  }

                  // Trigger an event after animation
                  // 300 milliseconds added to make sure queue has finished
                  _context17.next = 31;return new Promise(function (resolve) {var _this61 = this;_newArrowCheck(this, _this59);
                    _.delay(function () {_newArrowCheck(this, _this61);
                      Adapt.a11y.focusNext(selector);
                      Adapt.trigger("".concat(location, ":scrolledTo"), selector);
                      resolve();
                    }.bind(this), settings.duration + 300);
                  }.bind(this));case 31:case "end":return _context17.stop();}}}, _callee17, this);}));function navigateToElement(_x12) {return _navigateToElement2.apply(this, arguments);}return navigateToElement;}() }, { key: "get", value: function get()


      {var _this$model;
        Adapt.log.deprecated('Adapt.router.get, please use Adapt.router.model.get');
        return (_this$model = this.model).get.apply(_this$model, arguments);
      } }, { key: "set", value: function set()

      {var _this$model2;
        Adapt.log.deprecated('Adapt.router.set, please use Adapt.router.model.set');
        return (_this$model2 = this.model).set.apply(_this$model2, arguments);
      } }, { key: "rootModel", get: function get() {return this._navigationRoot || Adapt.course;}, set: function set(model) {this._navigationRoot = model;} }]);return Router;}(Backbone.Router);



  Adapt.router = new Router({
    model: new RouterModel(null, { reset: true }) });


  Adapt.navigateToElement = Adapt.router.navigateToElement.bind(Adapt.router);

  return Adapt.router;

});

define('core/js/collections/adaptSubsetCollection', [
'./adaptCollection'],
function (AdaptCollection) {var

  AdaptSubsetCollection = /*#__PURE__*/function (_AdaptCollection2) {"use strict";_inherits(AdaptSubsetCollection, _AdaptCollection2);var _super19 = _createSuper(AdaptSubsetCollection);function AdaptSubsetCollection() {_classCallCheck(this, AdaptSubsetCollection);return _super19.apply(this, arguments);}_createClass(AdaptSubsetCollection, [{ key: "initialize", value: function initialize(

      models, options) {
        _get(_getPrototypeOf(AdaptSubsetCollection.prototype), "initialize", this).call(this, models, options);
        this.parent = options.parent;
        this.listenTo(this.parent, 'reset', this.loadSubset);
      } }, { key: "loadSubset", value: function loadSubset()

      {var _this62 = this;
        this.set(this.parent.filter(function (model) {_newArrowCheck(this, _this62);return model instanceof this.model;}.bind(this)));
        this._byAdaptID = this.groupBy('_id');
      } }]);return AdaptSubsetCollection;}(AdaptCollection);



  return AdaptSubsetCollection;

});

define('core/js/models/pageModel', [
'core/js/adapt',
'core/js/models/contentObjectModel'],
function (Adapt, ContentObjectModel) {var

  PageModel = /*#__PURE__*/function (_ContentObjectModel2) {"use strict";_inherits(PageModel, _ContentObjectModel2);var _super20 = _createSuper(PageModel);function PageModel() {_classCallCheck(this, PageModel);return _super20.apply(this, arguments);}_createClass(PageModel, [{ key: "getTypeGroup",






      /**
                                                                                                                                                                                                                                                                                                           * Returns a string of the model type group.
                                                                                                                                                                                                                                                                                                           * @returns {string}
                                                                                                                                                                                                                                                                                                           */value: function getTypeGroup()
      {
        return 'page';
      } }, { key: "_children", get: function get() {Adapt.log.deprecated('pageModel._children, use menuModel.hasManagedChildren instead, child models are defined by the JSON');return 'articles';} }]);return PageModel;}(ContentObjectModel);



  Adapt.register('page', { model: PageModel });

  return PageModel;

});

define('core/js/models/articleModel', [
'core/js/adapt',
'core/js/models/adaptModel'],
function (Adapt, AdaptModel) {var

  ArticleModel = /*#__PURE__*/function (_AdaptModel2) {"use strict";_inherits(ArticleModel, _AdaptModel2);var _super21 = _createSuper(ArticleModel);function ArticleModel() {_classCallCheck(this, ArticleModel);return _super21.apply(this, arguments);}_createClass(ArticleModel, [{ key: "getTypeGroup",
















      /**
                                                                                                                                                                                                                                                                                                             * Returns a string of the model type group.
                                                                                                                                                                                                                                                                                                             * @returns {string}
                                                                                                                                                                                                                                                                                                             */value: function getTypeGroup()
      {
        return 'article';
      } }, { key: "_parent", get: function get() {Adapt.log.deprecated('articleModel._parent, use articleModel.getParent() instead, parent models are defined by the JSON');return 'contentObjects';} }, { key: "_siblings", get: function get() {Adapt.log.deprecated('articleModel._siblings, use articleModel.getSiblings() instead, sibling models are defined by the JSON');return 'articles';} }, { key: "_children", get: function get() {Adapt.log.deprecated('articleModel._children, use articleModel.hasManagedChildren instead, child models are defined by the JSON');return 'blocks';} }]);return ArticleModel;}(AdaptModel);



  Adapt.register('article', { model: ArticleModel });

  return ArticleModel;

});

define('core/js/models/blockModel', [
'core/js/adapt',
'core/js/models/adaptModel'],
function (Adapt, AdaptModel) {var

  BlockModel = /*#__PURE__*/function (_AdaptModel3) {"use strict";_inherits(BlockModel, _AdaptModel3);var _super22 = _createSuper(BlockModel);function BlockModel() {_classCallCheck(this, BlockModel);return _super22.apply(this, arguments);}_createClass(BlockModel, [{ key: "getTypeGroup",
















      /**
                                                                                                                                                                                                                                                                                                 * Returns a string of the model type group.
                                                                                                                                                                                                                                                                                                 * @returns {string}
                                                                                                                                                                                                                                                                                                 */value: function getTypeGroup()
      {
        return 'block';
      } }, { key: "_parent", get: function get() {Adapt.log.deprecated('blockModel._parent, use blockModel.getParent() instead, parent models are defined by the JSON');return 'articles';} }, { key: "_siblings", get: function get() {Adapt.log.deprecated('blockModel._siblings, use blockModel.getSiblings() instead, sibling models are defined by the JSON');return 'blocks';} }, { key: "_children", get: function get() {Adapt.log.deprecated('blockModel._children, use blockModel.hasManagedChildren instead, child models are defined by the JSON');return 'components';} }]);return BlockModel;}(AdaptModel);



  Adapt.register('block', { model: BlockModel });

  return BlockModel;

});

define('core/js/models/componentModel', [
'core/js/adapt',
'core/js/models/adaptModel'],
function (Adapt, AdaptModel) {var

  ComponentModel = /*#__PURE__*/function (_AdaptModel4) {"use strict";_inherits(ComponentModel, _AdaptModel4);var _super23 = _createSuper(ComponentModel);function ComponentModel() {_classCallCheck(this, ComponentModel);return _super23.apply(this, arguments);}_createClass(ComponentModel, [{ key: "getTypeGroup",











      /**
                                                                                                                                                                                                                                                                                                                         * Returns a string of the model type group.
                                                                                                                                                                                                                                                                                                                         * @returns {string}
                                                                                                                                                                                                                                                                                                                         */value: function getTypeGroup()
      {
        return 'component';
      } }, { key: "defaults", value: function defaults()

      {
        return AdaptModel.resultExtend('defaults', {
          _isA11yComponentDescriptionEnabled: true,
          _userAnswer: null,
          _attemptStates: null });

      } }, { key: "trackable", value: function trackable()

      {
        return AdaptModel.resultExtend('trackable', [
        '_userAnswer',
        '_attemptStates']);

      } }, { key: "trackableType", value: function trackableType()

      {
        return AdaptModel.resultExtend('trackableType', [
        Array,
        Array]);

      } }, { key: "init", value: function init()





      {
        if (Adapt.get('_isStarted')) {
          this.onAdaptInitialize();
          return;
        }
        this.listenToOnce(Adapt, 'adapt:initialize', this.onAdaptInitialize);
      } }, { key: "onAdaptInitialize", value: function onAdaptInitialize()

      {
        this.restoreUserAnswers();
      }

      /**
         * Restore the user's answer from the _userAnswer property.
         * The _userAnswer value must be in the form of arrays containing
         * numbers, booleans or arrays only.
         */ }, { key: "restoreUserAnswers", value: function restoreUserAnswers()
      {}

      /**
          * Store the user's answer in the _userAnswer property.
          * The _userAnswer value must be in the form of arrays containing
          * numbers, booleans or arrays only.
          */ }, { key: "storeUserAnswer", value: function storeUserAnswer()
      {} }, { key: "resetUserAnswer", value: function resetUserAnswer()

      {
        this.set('_userAnswer', null);
      } }, { key: "reset", value: function reset(

      type, force) {
        if (!this.get('_canReset') && !force) return;
        this.resetUserAnswer();
        _get(_getPrototypeOf(ComponentModel.prototype), "reset", this).call(this, type, force);
      }

      /**
         * Returns the current attempt state raw data or the raw data from the supplied attempt state object.
         * @param {Object} [object] JSON object representing the component state. Defaults to current JSON.
         * @returns {Array}
         */ }, { key: "getAttemptState", value: function getAttemptState()
      {var _this63 = this;var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toJSON();
        var trackables = this.trackable();
        var types = this.trackableType();
        trackables.find(function (name, index) {_newArrowCheck(this, _this63);
          // Exclude _attemptStates as it's trackable but isn't needed here
          if (name !== '_attemptStates') return;
          trackables.splice(index, 1);
          types.splice(index, 1);
          return true;
        }.bind(this));
        var values = trackables.map(function (n) {_newArrowCheck(this, _this63);return object[n];}.bind(this));
        var booleans = values.filter(function (v, i) {_newArrowCheck(this, _this63);return types[i] === Boolean;}.bind(this)).map(Boolean);
        var numbers = values.filter(function (v, i) {_newArrowCheck(this, _this63);return types[i] === Number;}.bind(this)).map(function (v) {_newArrowCheck(this, _this63);return Number(v) || 0;}.bind(this));
        var arrays = values.filter(function (v, i) {_newArrowCheck(this, _this63);return types[i] === Array;}.bind(this));
        return [
        numbers,
        booleans,
        arrays];

      }

      /**
         * Returns an attempt object representing the current state or a formatted version of the raw state object supplied.
         * @param {Array} [state] JSON object representing the component state, defaults to current state returned from getAttemptState().
         * @returns {Object}
         */ }, { key: "getAttemptObject", value: function getAttemptObject()
      {var _this64 = this;var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttemptState();
        var trackables = this.trackable();
        var types = this.trackableType();
        trackables.find(function (name, index) {_newArrowCheck(this, _this64);
          // Exclude _attemptStates as it's trackable but isn't needed here
          if (name !== '_attemptStates') return;
          trackables.splice(index, 1);
          types.splice(index, 1);
          return true;
        }.bind(this));
        var numbers = (state[0] || []).slice(0);
        var booleans = (state[1] || []).slice(0);
        var arrays = (state[2] || []).slice(0);
        var object = {};
        trackables.forEach(function (n, i) {_newArrowCheck(this, _this64);
          if (n === '_id') return;
          switch (types[i]) {
            case Number:
              object[n] = numbers.shift();
              break;
            case Boolean:
              object[n] = booleans.shift();
              break;
            case Array:
              object[n] = arrays.shift();
              break;}

        }.bind(this));
        return object;
      }

      /**
         * Sets the current attempt state from the supplied attempt state object.
         * @param {Object} object JSON object representing the component state.
         * @param {boolean} silent Stops change events from triggering
         */ }, { key: "setAttemptObject", value: function setAttemptObject(
      object) {var silent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        this.set(object, { silent: silent });
      }

      /**
         * Adds the current attempt state object or the supplied state object to the attempts store.
         * @param {Object} [object] JSON object representing the component state. Defaults to current JSON.
         */ }, { key: "addAttemptObject", value: function addAttemptObject()
      {var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttemptObject();
        var attemptStates = this.get('_attemptStates') || [];
        var state = this.getAttemptState(object);
        attemptStates.push(state);
        this.set('_attemptStates', attemptStates);
      }

      /**
         * Returns an array of the previous state objects. The most recent state is last in the list.
         * @returns {Array}
         */ }, { key: "getAttemptObjects", value: function getAttemptObjects()
      {var _this65 = this;
        var states = this.get('_attemptStates') || [];
        return states.map(function (state) {_newArrowCheck(this, _this65);return this.getAttemptObject(state);}.bind(this));
      } }, { key: "_parent", get: function get() {Adapt.log.deprecated('componentModel._parent, use componentModel.getParent() instead, parent models are defined by the JSON');return 'blocks';} }, { key: "_siblings", get: function get() {Adapt.log.deprecated('componentModel._siblings, use componentModel.getSiblings() instead, sibling models are defined by the JSON');return 'components';} }, { key: "hasManagedChildren", get: function get() {return false;} }]);return ComponentModel;}(AdaptModel);



  // This abstract model needs to registered to support deprecated view-only components
  Adapt.register('component', { model: ComponentModel });

  return ComponentModel;

});

define('core/js/views/contentObjectView', [
'core/js/adapt',
'core/js/views/adaptView'],
function (Adapt, AdaptView) {var

  ContentObjectView = /*#__PURE__*/function (_AdaptView) {"use strict";_inherits(ContentObjectView, _AdaptView);var _super24 = _createSuper(ContentObjectView);function ContentObjectView() {_classCallCheck(this, ContentObjectView);return _super24.apply(this, arguments);}_createClass(ContentObjectView, [{ key: "attributes", value: function attributes()

      {
        return AdaptView.resultExtend('attributes', {
          'role': 'main',
          'aria-labelledby': "".concat(this.model.get('_id'), "-heading") },
        this);
      } }, { key: "className", value: function className()

      {
        return [
        this.constructor.type,
        'contentobject',
        this.constructor.className,
        this.model.get('_id'),
        this.model.get('_classes'),
        this.setVisibility(),
        this.model.get('_isComplete') ? 'is-complete' : '',
        this.model.get('_isOptional') ? 'is-optional' : ''].
        filter(Boolean).join(' ');
      } }, { key: "preRender", value: function preRender()

      {
        $.inview.lock(this.constructor.type + 'View');
        this.disableAnimation = Adapt.config.has('_disableAnimation') ? Adapt.config.get('_disableAnimation') : false;
        this.$el.css('opacity', 0);
        this.listenTo(this.model, 'change:_isReady', this.isReady);
      } }, { key: "render", value: function render()

      {var _this66 = this;
        var type = this.constructor.type;
        Adapt.trigger("".concat(type, "View:preRender contentObjectView:preRender view:preRender"), this);

        var data = this.model.toJSON();
        data.view = this;
        var template = Handlebars.templates[this.constructor.template];
        this.$el.html(template(data));

        Adapt.trigger("".concat(type, "View:render contentObjectView:render view:render"), this);

        _.defer(function () {_newArrowCheck(this, _this66);
          // don't call postRender after remove
          if (this._isRemoved) return;

          this.postRender();
          Adapt.trigger("".concat(type, "View:postRender contentObjectView:postRender view:postRender"), this);
        }.bind(this));

        return this;
      } }, { key: "isReady", value: function () {var _isReady = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {var _this67 = this;var type, performIsReady;return regeneratorRuntime.wrap(function _callee19$(_context19) {while (1) {switch (_context19.prev = _context19.next) {case 0:if (!(


                  !this.model.get('_isReady') || this._isTriggeredReady)) {_context19.next = 2;break;}return _context19.abrupt("return");case 2:
                  this._isTriggeredReady = true;

                  type = this.constructor.type;
                  performIsReady = /*#__PURE__*/function () {var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {var _this68 = this;var styleOptions;return regeneratorRuntime.wrap(function _callee18$(_context18) {while (1) {switch (_context18.prev = _context18.next) {case 0:
                              Adapt.trigger("".concat(type, "View:preReady contentObjectView:preReady view:preReady"), _this67);_context18.next = 3;return (
                                Adapt.wait.queue());case 3:
                              $('.js-loading').hide();
                              if (Adapt.get('_shouldContentObjectScrollTop') !== false) {
                                $(window).scrollTop(0);
                              }
                              Adapt.trigger("".concat(type, "View:ready contentObjectView:ready view:ready"), _this67);
                              $.inview.unlock("".concat(type, "View"));
                              styleOptions = { opacity: 1 };
                              if (_this67.disableAnimation) {
                                _this67.$el.css(styleOptions);
                                $.inview();
                                _.defer(function () {_newArrowCheck(this, _this68);
                                  Adapt.trigger("".concat(type, "View:postReady contentObjectView:postReady view:postReady"), _this67);
                                }.bind(this));
                              } else {
                                _this67.$el.velocity(styleOptions, {
                                  duration: 'fast',
                                  complete: function complete() {_newArrowCheck(this, _this68);
                                    $.inview();
                                    Adapt.trigger("".concat(type, "View:postReady contentObjectView:postReady view:postReady"), _this67);
                                  }.bind(this) });

                              }
                              $(window).scroll();case 10:case "end":return _context18.stop();}}}, _callee18, this);}));return function performIsReady() {return _ref5.apply(this, arguments);};}();


                  _.defer(performIsReady);case 6:case "end":return _context19.stop();}}}, _callee19, this);}));function isReady() {return _isReady.apply(this, arguments);}return isReady;}()


      /**
                                                                                                                                                                                               * Force render up to specified id. Resolves when views are ready.
                                                                                                                                                                                               * @param {string} id
                                                                                                                                                                                               */ }, { key: "renderTo", value: function () {var _renderTo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(
        id) {var _this69 = this;var isRenderToSelf, models, index, model, ids, _forceUntilId;return regeneratorRuntime.wrap(function _callee20$(_context20) {while (1) {switch (_context20.prev = _context20.next) {case 0:
                  isRenderToSelf = id === this.model.get('_id');if (!
                  isRenderToSelf) {_context20.next = 3;break;}return _context20.abrupt("return");case 3:
                  models = this.model.getAllDescendantModels(true).filter(function (model) {_newArrowCheck(this, _this69);return model.get('_isAvailable');}.bind(this));
                  index = models.findIndex(function (model) {_newArrowCheck(this, _this69);return model.get('_id') === id;}.bind(this));if (!(
                  index === -1)) {_context20.next = 7;break;}throw (
                    new Error("Cannot renderTo \"".concat(id, "\" as it isn't a descendant.")));case 7:

                  // Return early if the model is already rendered and ready
                  model = models[index];if (!(
                  model.get('_isRendered') && model.get('_isReady'))) {_context20.next = 10;break;}return _context20.abrupt("return");case 10:


                  // Force all models up until the id to render
                  models = models.slice(0, index + 1);
                  ids = _.indexBy(models, function (model) {_newArrowCheck(this, _this69);return model.get('_id');}.bind(this));
                  _forceUntilId = function forceUntilId(event) {_newArrowCheck(this, _this69);
                    var addingId = event.model.get('_id');
                    if (!ids[addingId]) return;
                    event.force();
                    if (addingId !== id) return;
                    Adapt.off('view:addChild', _forceUntilId);
                  }.bind(this);
                  Adapt.on('view:addChild', _forceUntilId);
                  // Trigger addChildren cascade
                  _context20.next = 16;return this.addChildren();case 16:_context20.next = 18;return (
                    this.whenReady());case 18:if (!(

                  !model.get('_isRendered') || !model.get('_isReady'))) {_context20.next = 20;break;}throw (
                    new Error("Cannot renderTo \"".concat(id, "\".")));case 20:case "end":return _context20.stop();}}}, _callee20, this);}));function renderTo(_x13) {return _renderTo.apply(this, arguments);}return renderTo;}() }, { key: "preRemove", value: function preRemove()



      {
        var type = this.constructor.type;
        Adapt.trigger("".concat(type, "View:preRemove contentObjectView:preRemove view:preRemove"), this);
      } }, { key: "remove", value: function remove()

      {var _this70 = this;
        var type = this.constructor.type;
        this.preRemove();
        Adapt.trigger("".concat(type, "View:remove contentObjectView:remove view:remove"), this);
        this._isRemoved = true;

        Adapt.wait.for(function (end) {var _this71 = this;_newArrowCheck(this, _this70);
          this.$el.off('onscreen.adaptView');
          this.findDescendantViews().reverse().forEach(function (view) {_newArrowCheck(this, _this71);
            view.remove();
          }.bind(this));
          this.setChildViews(null);
          _get(_getPrototypeOf(ContentObjectView.prototype), "remove", this).call(this);
          _.defer(function () {_newArrowCheck(this, _this71);
            Adapt.trigger("".concat(type, "View:postRemove contentObjectView:postRemove view:postRemove"), this);
            this.trigger('postRemove');
          }.bind(this));
          end();
        }.bind(this));

        return this;
      } }, { key: "destroy", value: function destroy()

      {
        this.remove();
        if (Adapt.parentView === this) {
          Adapt.parentView = null;
        }
      } }]);return ContentObjectView;}(AdaptView);



  return ContentObjectView;

});

define('core/js/views/pageView', [
'core/js/adapt',
'core/js/views/contentObjectView'],
function (Adapt, ContentObjectView) {var

  PageView = /*#__PURE__*/function (_ContentObjectView) {"use strict";_inherits(PageView, _ContentObjectView);var _super25 = _createSuper(PageView);function PageView() {_classCallCheck(this, PageView);return _super25.apply(this, arguments);}_createClass(PageView, [{ key: "preRender", value: function preRender()

      {var _this72 = this;
        // checkIfResetOnRevisit on descendant models before render
        this.model.getAllDescendantModels().forEach(function (model) {_newArrowCheck(this, _this72);
          if (!model.checkIfResetOnRevisit) return;
          model.checkIfResetOnRevisit();
        }.bind(this));
        _get(_getPrototypeOf(PageView.prototype), "preRender", this).call(this);
      } }, { key: "remove", value: function remove()

      {
        if (this.$pageLabel) {
          this.$pageLabel.remove();
        }
        _get(_getPrototypeOf(PageView.prototype), "remove", this).call(this);
      } }]);return PageView;}(ContentObjectView);



  Object.assign(PageView, {
    childContainer: '.article__container',
    type: 'page',
    template: 'page' });


  Adapt.register('page', { view: PageView });

  return PageView;

});

define('core/js/views/articleView', [
'core/js/adapt',
'core/js/views/adaptView'],
function (Adapt, AdaptView) {var

  ArticleView = /*#__PURE__*/function (_AdaptView2) {"use strict";_inherits(ArticleView, _AdaptView2);var _super26 = _createSuper(ArticleView);function ArticleView() {_classCallCheck(this, ArticleView);return _super26.apply(this, arguments);}_createClass(ArticleView, [{ key: "className", value: function className()

      {
        return [
        'article',
        this.model.get('_id'),
        this.model.get('_classes'),
        this.setVisibility(),
        this.setHidden(),
        this.model.get('_isComplete') ? 'is-complete' : '',
        this.model.get('_isOptional') ? 'is-optional' : ''].
        join(' ');
      } }]);return ArticleView;}(AdaptView);



  Object.assign(ArticleView, {
    childContainer: '.block__container',
    type: 'article',
    template: 'article' });


  Adapt.register('article', { view: ArticleView });

  return ArticleView;

});

define('core/js/views/blockView', [
'core/js/adapt',
'core/js/views/adaptView'],
function (Adapt, AdaptView) {var

  BlockView = /*#__PURE__*/function (_AdaptView3) {"use strict";_inherits(BlockView, _AdaptView3);var _super27 = _createSuper(BlockView);function BlockView() {_classCallCheck(this, BlockView);return _super27.apply(this, arguments);}_createClass(BlockView, [{ key: "className", value: function className()

      {
        return [
        'block',
        this.model.get('_id'),
        this.model.get('_classes'),
        this.setVisibility(),
        this.setHidden(),
        this.model.get('_isComplete') ? 'is-complete' : '',
        this.model.get('_isOptional') ? 'is-optional' : ''].
        join(' ');
      } }]);return BlockView;}(AdaptView);



  Object.assign(BlockView, {
    childContainer: '.component__container',
    type: 'block',
    template: 'block' });


  Adapt.register('block', { view: BlockView });

  return BlockView;

});

define('core/js/mpabc', [
'core/js/adapt',
'core/js/data',
'core/js/collections/adaptSubsetCollection',
'core/js/models/courseModel',
'core/js/models/contentObjectModel',
'core/js/models/menuModel',
'core/js/models/pageModel',
'core/js/models/articleModel',
'core/js/models/blockModel',
'core/js/models/componentModel',
'core/js/views/pageView',
'core/js/views/articleView',
'core/js/views/blockView'],
function (Adapt, Data, AdaptSubsetCollection, CourseModel, ContentObjectModel, MenuModel, PageModel, ArticleModel, BlockModel, ComponentModel, PageView, ArticleView, BlockView) {var

  MPABC = /*#__PURE__*/function (_Backbone$Controller6) {"use strict";_inherits(MPABC, _Backbone$Controller6);var _super28 = _createSuper(MPABC);function MPABC() {_classCallCheck(this, MPABC);return _super28.apply(this, arguments);}_createClass(MPABC, [{ key: "initialize", value: function initialize()

      {
        // Example of how to cause the data loader to wait for another module to setup
        this.listenTo(Data, {
          loading: this.waitForDataLoaded,
          loaded: this.onDataLoaded });

        this.setupSubsetCollections();
      } }, { key: "waitForDataLoaded", value: function waitForDataLoaded()

      {
        // Tell the data loader to wait
        Adapt.wait.begin();
      } }, { key: "onDataLoaded", value: function onDataLoaded()

      {
        // Tell the data loader that we have finished
        Adapt.wait.end();
      } }, { key: "setupSubsetCollections", value: function setupSubsetCollections()

      {
        Adapt.contentObjects = new AdaptSubsetCollection(null, { parent: Data, model: ContentObjectModel });
        Adapt.articles = new AdaptSubsetCollection(null, { parent: Data, model: ArticleModel });
        Adapt.blocks = new AdaptSubsetCollection(null, { parent: Data, model: BlockModel });
        Adapt.components = new AdaptSubsetCollection(null, { parent: Data, model: ComponentModel });
      } }]);return MPABC;}(Backbone.Controller);



  return Adapt.mpabc = new MPABC();

});

define('core/js/helpers', [
'handlebars',
'core/js/adapt'],
function (Handlebars, Adapt) {

  var defaultAriaLevels = {
    '_menu': 1,
    '_menuGroup': 2,
    '_menuItem': 2,
    '_page': 1,
    '_article': 2,
    '_block': 3,
    '_component': 4,
    '_componentItem': 5,
    '_notify': 1 };


  var helpers = {

    lowercase: function lowercase(text) {
      return text.toLowerCase();
    },

    capitalise: function capitalise(text) {
      return text.charAt(0).toUpperCase() + text.slice(1);
    },

    inc: function inc(index) {
      return index + 1;
    },

    dec: function dec(index) {
      return index - 1;
    },

    odd: function odd(index) {
      return (index + 1) % 2 === 0 ? 'even' : 'odd';
    },

    equals: function equals(value, text, block) {
      return helpers.compare.call(this, value, '==', text, block);
    },

    compare: function compare(value, operator, text, block) {
      // Comparison operators
      switch (operator) {
        case '===':
          if (value === text) return block.fn(this);
          break;
        case '=':case '==':
          // eslint-disable-next-line eqeqeq
          if (value == text) return block.fn(this);
          break;
        case '>=':
          if (value >= text) return block.fn(this);
          break;
        case '<=':
          if (value <= text) return block.fn(this);
          break;
        case '>':
          if (value > text) return block.fn(this);
          break;
        case '<':
          if (value < text) return block.fn(this);
          break;}

      return block.inverse(this);
    },

    math: function math(lvalue, operator, rvalue, options) {
      // Mathematical operators
      lvalue = parseFloat(lvalue);
      rvalue = parseFloat(rvalue);
      switch (operator) {
        case '+':return lvalue + rvalue;
        case '-':return lvalue - rvalue;
        case '*':return lvalue * rvalue;
        case '/':return lvalue / rvalue;
        case '%':return lvalue % rvalue;}

    },

    /**
        * Equivalent to:
        *  if (conditionA || conditionB)
        * @example
        * {{#any displayTitle body instruction}}
        * <div class='component__header {{_component}}__header'></div>
        * {{/any}}
        */
    any: function any() {
      var args = Array.prototype.slice.call(arguments, 0, -1);
      var block = Array.prototype.slice.call(arguments, -1)[0];
      return _.any(args) ? block.fn ? block.fn(this) : true : block.inverse ? block.inverse(this) : false;
    },

    /**
        * Equivalent to:
        *  if (conditionA && conditionB)
        * @example
        * {{#all displayTitle body instruction}}
        * <div class='component__header {{_component}}__header'></div>
        * {{/all}}
        */
    all: function all() {
      var args = Array.prototype.slice.call(arguments, 0, -1);
      var block = Array.prototype.slice.call(arguments, -1)[0];
      return _.all(args) ? block.fn ? block.fn(this) : true : block.inverse ? block.inverse(this) : false;
    },

    /**
        * Equivalent to:
        *  if (!conditionA && !conditionB)
        * @example
        * {{#none displayTitle body instruction}}
        * <div class='component__header {{_component}}__header'></div>
        * {{/none}}
        */
    none: function none() {
      var args = Array.prototype.slice.call(arguments, 0, -1);
      var block = Array.prototype.slice.call(arguments, -1)[0];

      return !_.any(args) ? block.fn ? block.fn(this) : true : block.inverse ? block.inverse(this) : false;
    },

    /**
        * Allow JSON to be a template i.e. you can use handlebars {{expressions}} within your JSON
        */
    compile: function compile(template, context) {
      if (!template) {
        return '';
      }
      if (template instanceof Object) template = template.toString();
      var data = this;
      if (context) {
        // choose between a passed argument context or the default handlebars helper context
        data = !context.data || !context.data.root ? context : context.data.root;
      }
      return Handlebars.compile(template)(data);
    },

    /**
        * Allow JSON to be a template and accessible text
        */
    compile_a11y_text: function compile_a11y_text(template, context) {
      Adapt.a11y.log.deprecated('a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/');
      return helpers.compile.call(this, template, context);
    },

    /**
        * Allow JSON to be a template and normalized text
        */
    compile_a11y_normalize: function compile_a11y_normalize(template, context) {
      if (!template) {
        return '';
      }
      if (template instanceof Object) template = template.toString();
      return Handlebars.helpers.a11y_normalize.call(this, helpers.compile.call(this, template, context));
    },

    /**
        * Remove all html tags except styling tags
        */
    compile_a11y_remove_breaks: function compile_a11y_remove_breaks(template, context) {
      if (!template) {
        return '';
      }
      return Handlebars.helpers.a11y_remove_breaks.call(this, helpers.compile.call(this, template, context));
    },

    /**
        * makes the _globals object in course.json available to a template
        */
    import_globals: function import_globals(context) {
      if (context.data.root._globals) {
        return '';
      }
      context.data.root._globals = Adapt.course.get('_globals');
      return '';
    },

    /**
        * makes the Adapt module data available to a template
        */
    import_adapt: function import_adapt(context) {

      if (context.data.root.Adapt) {
        return;
      }
      var adapt = context.data.root.Adapt = {};

      var i, l, name;

      var directImport = ['config', 'course'];
      for (i = 0, l = directImport.length; i < l; i++) {
        name = directImport[i];
        // convert the model to a json object and add to the current context
        adapt[name] = Adapt[name].toJSON();
      }

      var indexedImport = ['contentObjects', 'articles', 'blocks', 'components'];
      for (i = 0, l = indexedImport.length; i < l; i++) {
        name = indexedImport[i];
        // convert the collection of models to an array of json objects
        var importArray = Adapt[name].toJSON();
        // convert the array of json models to an object indexed by id
        var importIndex = {};
        for (var i1 = 0, l1 = importArray.length; i1 < l1; i1++) {
          var item = importArray[i1];
          importIndex[item._id] = item;
        }
        // add the indexed object to the current context
        adapt[name] = importIndex;
      }

      return '';

    },

    /**
        * Allow components to fetch their component description.
        *
        * Creates an aria label using the `a11y_aria_label` helper containing
        * the component description specified in the
        * `_globals._component[componentName].ariaRegion`. This value is defined
        * in the `properties.schema:globals.ariaRegion`.
        *
        * @param {string} [override]
        * @returns {string}
        */
    component_description: function component_description(override, context) {
      if (!this._isA11yComponentDescriptionEnabled) {
        return;
      }
      var isNotDefined = !this._globals._components || !this._globals._components['_' + this._component];
      if (isNotDefined) {
        return;
      }
      var hasOverride = arguments.length > 1;
      var description;
      if (hasOverride) {
        description = override;
        description = helpers.compile(description, context);
      } else {
        description = this._globals._components['_' + this._component].ariaRegion;
        description = helpers.compile(description, override);
      }
      if (!description) {
        return;
      }
      return new Handlebars.SafeString('<div class="aria-label">' + description + '</div>');
    },

    a11y_text: function a11y_text(text) {
      Adapt.a11y.log.deprecated('a11y_text is no longer required. https://tink.uk/understanding-screen-reader-interaction-modes/');
      return text;
    },

    /**
        * Handlebars helper for `Adapt.a11y.normalize(htmls)`.
        *
        * @param {string} htmls Any htmls.
        * @returns {string}
        */
    a11y_normalize: function a11y_normalize(htmls) {
      return Adapt.a11y.normalize.apply(Adapt.a11y, arguments);
    },

    /**
        * Handlebars helper for `Adapt.a11y.removeBreaks(htmls)`.
        *
        * @param {string} htmls Any htmls.
        * @returns {string}
        */
    a11y_remove_breaks: function a11y_remove_breaks(htmls) {
      return Adapt.a11y.removeBreaks.apply(Adapt.a11y, arguments);
    },

    /**
        * Creates a div styled with tiny, transparent text.
        * It it absolutely positioned.
        * The text is not visibly readable but is read by screen readers.
        *
        * @param {string} htmls
        * @returns {string}
        */
    a11y_aria_label: function a11y_aria_label(htmls) {
      var values = Array.prototype.slice.call(arguments, 0, -1);
      values = values.filter(Boolean);
      return new Handlebars.SafeString('<div class="aria-label">' + values.join(' ') + '</div>');
    },

    /**
        * Creates a div styled with tiny, transparent text.
        * It it relatively positioned.
        * The text is not visibly readable but is read by screen readers.
        *
        * @param {string} htmls Aria label texts.
        * @returns {string}
        */
    a11y_aria_label_relative: function a11y_aria_label_relative(htmls) {
      var values = Array.prototype.slice.call(arguments, 0, -1);
      values = values.filter(Boolean);
      return new Handlebars.SafeString('<div class="aria-label relative">' + values.join(' ') + '</div>');
    },

    /**
        * Creates a div styled with tiny, transparent text and `role"=img"`.
        * It is used for representing an image to a screen reader user in an
        * order which cannot be represented in the DOM in a way that achieves the
        * styling objectives.
        * It it absolutely positioned.
        * The text is not visibly readable but is read by screen readers.
        *
        * @param {string} texts Aria label texts.
        * @returns {string}
        */
    a11y_aria_image: function a11y_aria_image(texts) {
      var values = Array.prototype.slice.call(arguments, 0, -1);
      values = values.filter(Boolean);
      return new Handlebars.SafeString('<div class="aria-label" role="img" aria-label="' + values.join(' ') + '"></div>');
    },

    /**
        * Returns an `a` tag which when receiving focus causes the focus to wrap
        * to the top of the readable document.
        *
        * @returns {string}
        */
    a11y_wrap_focus: function a11y_wrap_focus() {
      var cfg = Adapt.config.get('_accessibility');
      if (cfg._isPopupWrapFocusEnabled === false) return '';
      return new Handlebars.SafeString('<a class="a11y-focusguard a11y-ignore a11y-ignore-focus" role="presentation">&nbsp;</a>');
    },

    /**
        * Creates the attributes for a subject heading text. `role="heading"` and
        * `aria-level="#"`. It will use the `_ariaLevel` attribute from the current
        * context if specified, a number if given as the `levelOrType` parameter,
        * or a name from the configured aria levels hash.
        *
        * @param {number|string} levelOrType
        * @returns {string}
        */
    a11y_attrs_heading: function a11y_attrs_heading(levelOrType) {
      // get the global configuration from config.json
      var cfg = Adapt.config.get('_accessibility');
      // default level to use if nothing overrides it
      var level = 1;

      // first check to see if the Handlebars context has an override
      if (this._ariaLevel) {
        levelOrType = this._ariaLevel;
      }

      if (isNaN(levelOrType) === false) {
        // if a number is passed just use this
        level = levelOrType;
      } else if (_.isString(levelOrType)) {
        // if a string is passed check if it is defined in global configuration
        cfg._ariaLevels = cfg._ariaLevels || defaultAriaLevels;
        if (cfg._ariaLevels && cfg._ariaLevels['_' + levelOrType] !== undefined) {
          level = cfg._ariaLevels['_' + levelOrType];
        }
      }

      return new Handlebars.SafeString(' role="heading" aria-level="' + level + '" ');
    },

    a11y_attrs_tabbable: function a11y_attrs_tabbable() {
      Adapt.a11y.log.deprecated('a11y_attrs_tabbable should not be used. tabbable elements should be natively tabbable.');
      return new Handlebars.SafeString(' role="region" tabindex="0" ');
    },

    /**
        * Produce display text with alternative screen reader version.
        * @param {string} visible Text that will be displayed on screen
        * @param {string} alternatives Text that will be read by the screen reader (instead of what's displayed on screen)
        * @example {{a11y_alt_text '$5bn' 'five billion dollars'}} or {{a11y_alt_text 'Here are some bits to read' 'There are' _items.length 'items to read'}}
        */
    a11y_alt_text: function a11y_alt_text(visible, alternatives) {
      var values = Array.prototype.slice.call(arguments, 1, -1);
      values = values.filter(Boolean);
      return new Handlebars.SafeString('<span aria-hidden="true">' + visible + '</span><span class="aria-label">' + values.join(' ') + '</span>');
    } };



  // Compatibility references
  _.extend(helpers, {

    if_value_equals: function if_value_equals() {
      Adapt.a11y.log.deprecated('if_value_equals, use equals instead.');
      return helpers.equals.apply(this, arguments);
    },

    numbers: function numbers() {
      Adapt.a11y.log.deprecated('numbers, use inc instead.');
      return helpers.inc.apply(this, arguments);
    },

    lowerCase: function lowerCase() {
      Adapt.a11y.log.deprecated('lowerCase, use lowercase instead.');
      return helpers.lowercase.apply(this, arguments);
    } });



  for (var name in helpers) {
    if (!helpers.hasOwnProperty(name)) continue;
    Handlebars.registerHelper(name, helpers[name]);
  }

  return helpers;

});

define('core/js/scrolling', [
'core/js/adapt'],
function (Adapt) {var

  Scrolling = /*#__PURE__*/function (_Backbone$Controller7) {"use strict";_inherits(Scrolling, _Backbone$Controller7);var _super29 = _createSuper(Scrolling);function Scrolling() {_classCallCheck(this, Scrolling);return _super29.apply(this, arguments);}_createClass(Scrolling, [{ key: "initialize", value: function initialize()

      {
        this.$html = null;
        this.$app = null;
        this.isLegacyScrolling = true;
        this._checkApp();
        Adapt.once('configModel:dataLoaded', this._loadConfig.bind(this));
      } }, { key: "_checkApp", value: function _checkApp()

      {
        this.$html = $('html');
        this.$app = $('#app');
        if (this.$app.length) return;
        this.$app = $('<div id="app">');
        $('body').append(this.$app);
        this.$app.append($('#wrapper'));
        Adapt.log.warn('UPDATE - Your html file needs to have #app adding. See https://github.com/adaptlearning/adapt_framework/issues/2168');
      } }, { key: "_loadConfig", value: function _loadConfig()

      {
        var config = Adapt.config.get('_scrollingContainer');
        if (!config || !config._isEnabled) return;
        var limitTo = config._limitToSelector;
        var isIncluded = !limitTo || this.$html.is(limitTo) || this.$html.hasClass(limitTo);
        if (!isIncluded) return;
        this.isLegacyScrolling = false;
        this._addStyling();
        this._fixJQuery();
        this._fixScrollTo();
        this._fixBrowser();
      } }, { key: "_addStyling", value: function _addStyling()

      {
        this.$html.addClass('adapt-scrolling');
      } }, { key: "_fixJQuery", value: function _fixJQuery()

      {
        var selectorScrollTop = $.fn.scrollTop;
        var $app = Adapt.scrolling.$app;
        $.fn.scrollTop = function () {
          if (this[0] === window || this[0] === document.body) {
            return selectorScrollTop.apply($app, arguments);
          }
          return selectorScrollTop.apply(this, arguments);
        };
        var selectorOffset = $.fn.offset;
        $.fn.offset = function (coordinates) {
          if (coordinates) {
            return selectorOffset.apply(this, arguments);
          }
          var $app = Adapt.scrolling.$app;
          var $element = this;
          var elementOffset = selectorOffset.call($element);
          var isCorrectedContainer = $element.is('html, body, #app') ||
          $element.parents().is('#app');
          if (!isCorrectedContainer) {
            // Do not adjust the offset measurement as not in $app container and isn't html or body
            return elementOffset;
          }
          // Adjust measurement by scrolling and offset of $app container
          var scrollTop = parseInt($app.scrollTop());
          var scrollLeft = parseInt($app.scrollLeft());
          var appOffset = selectorOffset.call($app);
          elementOffset.top += scrollTop - appOffset.top;
          elementOffset.left += scrollLeft - appOffset.left;
          return elementOffset;
        };
      } }, { key: "_fixScrollTo", value: function _fixScrollTo()

      {
        var selectorScrollTo = $.fn.scrollTo;
        var scrollTo = $.scrollTo;
        var $app = Adapt.scrolling.$app;
        $.fn.scrollTo = function (target, duration, settings) {
          if (this[0] === window || this[0] === document.body) {
            return selectorScrollTo.apply($app, arguments);
          }
          return selectorScrollTo.apply(this, arguments);
        };
        $.scrollTo = function (target, duration, settings) {
          return selectorScrollTo.apply($app, arguments);
        };
        Object.assign($.scrollTo, scrollTo);
      } }, { key: "_fixBrowser", value: function _fixBrowser()

      {var _this73 = this;
        var app = Adapt.scrolling.$app[0];
        window.scrollTo = function (x, y) {
          app.scrollTop = y || 0;
          app.scrollLeft = x || 0;
        };
        var $window = $(window);
        this.$app.on('scroll', function () {_newArrowCheck(this, _this73);
          $window.scroll();
        }.bind(this));
      }

      /**
         * Allows a selector to be passed in and Adapt will scroll to this element. Resolves
         * asynchronously when the element has been navigated/scrolled to.
         * Backend for Adapt.scrollTo
         * @param {string} selector CSS selector of the Adapt element you want to navigate to e.g. `".co-05"`
         * @param {Object} [settings={}] The settings for the `$.scrollTo` function (See https://github.com/flesler/jquery.scrollTo#settings).
         * @param {Object} [settings.replace=false] Set to `true` if you want to update the URL without creating an entry in the browser's history.
         */ }, { key: "scrollTo", value: function () {var _scrollTo2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21(
        selector) {var settings,_args21 = arguments;return regeneratorRuntime.wrap(function _callee21$(_context21) {while (1) {switch (_context21.prev = _context21.next) {case 0:settings = _args21.length > 1 && _args21[1] !== undefined ? _args21[1] : {};
                  Adapt.log.deprecated('Adapt.scrollTo and Adapt.scrolling.scrollTo, use Adapt.navigateToElement instead.');return _context21.abrupt("return",
                  Adapt.router.navigateToElement(selector, settings));case 3:case "end":return _context21.stop();}}}, _callee21);}));function scrollTo(_x14) {return _scrollTo2.apply(this, arguments);}return scrollTo;}() }]);return Scrolling;}(Backbone.Controller);




  Adapt.scrolling = new Scrolling();

  Adapt.scrollTo = Adapt.scrolling.scrollTo.bind(Adapt.scrolling);

  return Adapt.scrolling;

});

define('core/js/views/headingView', [
'core/js/adapt'],
function (Adapt) {

  var HeadingView = Backbone.View.extend({

    initialize: function initialize() {
      this.listenTo(Adapt.parentView, 'postRemove', this.remove);
      this.listenTo(this.model, 'change:_isComplete', this.render);
      this.render();
    },

    render: function render() {
      var template = Handlebars.templates[this.constructor.template];
      var data = this.model.toJSON();
      var customHeadingType = this.$el.attr('data-a11y-heading-type');
      if (customHeadingType) data._type = customHeadingType;
      this.$el.html(template(data));
      this.checkCompletion();
    },

    checkCompletion: function checkCompletion() {
      var isComplete = this.model.get('_isComplete');
      this.$el.
      toggleClass('is-complete', isComplete).
      toggleClass('is-incomplete', !isComplete);
    } },

  {
    template: 'heading' });


  return HeadingView;

});

define('core/js/headings', [
'./adapt',
'./views/headingView'],
function (Adapt, HeadingView) {

  var Headings = Backbone.Controller.extend({

    initialize: function initialize() {
      this.listenTo(Adapt, 'view:render', this.onViewRender);
    },

    onViewRender: function onViewRender(view) {
      var $headingSeats = view.$('.js-heading');
      $headingSeats.each(function (index, el) {
        new HeadingView({
          el: el,
          model: view.model });

      });
    } });



  return new Headings();

});

define('core/js/views/navigationView', [
'core/js/adapt'],
function (Adapt) {var

  NavigationView = /*#__PURE__*/function (_Backbone$View3) {"use strict";_inherits(NavigationView, _Backbone$View3);var _super30 = _createSuper(NavigationView);function NavigationView() {_classCallCheck(this, NavigationView);return _super30.apply(this, arguments);}_createClass(NavigationView, [{ key: "className", value: function className()

      {
        return 'nav';
      } }, { key: "events", value: function events()

      {
        return {
          'click [data-event]': 'triggerEvent' };

      } }, { key: "attributes", value: function attributes()

      {
        return {
          'role': 'navigation' };

      } }, { key: "initialize", value: function initialize()

      {
        this.listenToOnce(Adapt, {
          'courseModel:dataLoading': this.remove });

        this.listenTo(Adapt, 'router:menu router:page', this.hideNavigationButton);
        this.preRender();
      } }, { key: "preRender", value: function preRender()

      {
        Adapt.trigger('navigationView:preRender', this);
        this.render();
      } }, { key: "render", value: function render()

      {var _this74 = this;
        var template = Handlebars.templates[this.constructor.template];
        this.$el.html(template({
          _globals: Adapt.course.get('_globals'),
          _accessibility: Adapt.config.get('_accessibility') })).
        insertBefore('#app');

        _.defer(function () {_newArrowCheck(this, _this74);
          Adapt.trigger('navigationView:postRender', this);
        }.bind(this));

        return this;
      } }, { key: "triggerEvent", value: function triggerEvent(

      event) {
        event.preventDefault();
        var currentEvent = $(event.currentTarget).attr('data-event');
        Adapt.trigger('navigation:' + currentEvent);
        switch (currentEvent) {
          case 'backButton':
            Adapt.router.navigateToPreviousRoute();
            break;
          case 'homeButton':
            Adapt.router.navigateToHomeRoute();
            break;
          case 'parentButton':
            Adapt.router.navigateToParent();
            break;
          case 'skipNavigation':
            this.skipNavigation();
            break;
          case 'returnToStart':
            Adapt.startController.returnToStartLocation();
            break;}

      } }, { key: "skipNavigation", value: function skipNavigation()

      {
        Adapt.a11y.focusFirst('.' + Adapt.location._contentType);
      } }, { key: "hideNavigationButton", value: function hideNavigationButton(

      model) {
        var shouldHide = model.get('_type') === 'course';
        this.$('.nav__back-btn, .nav__home-btn').toggleClass('u-display-none', shouldHide);
      } }, { key: "showNavigationButton", value: function showNavigationButton()

      {
        this.$('.nav__back-btn, .nav__home-btn').removeClass('u-display-none');
      } }]);return NavigationView;}(Backbone.View);



  NavigationView.template = 'nav';

  return NavigationView;

});

define('core/js/navigation', [
'core/js/adapt',
'core/js/views/navigationView'],
function (Adapt, NavigationView) {

  var NavigationController = Backbone.Controller.extend({

    initialize: function initialize() {
      this.listenTo(Adapt, 'adapt:preInitialize', this.addNavigationBar);
    },

    addNavigationBar: function addNavigationBar() {
      var adaptConfig = Adapt.course.get('_navigation');

      if (adaptConfig && adaptConfig._isDefaultNavigationDisabled) {
        Adapt.trigger('navigation:initialize');
        return;
      }

      Adapt.navigation = new NavigationView(); // This should be triggered after 'app:dataReady' as plugins might want to manipulate the navigation
    } });



  return new NavigationController();

});

define('core/js/models/itemModel', [], function () {var

  ItemModel = /*#__PURE__*/function (_Backbone$Model6) {"use strict";_inherits(ItemModel, _Backbone$Model6);var _super31 = _createSuper(ItemModel);function ItemModel() {_classCallCheck(this, ItemModel);return _super31.apply(this, arguments);}_createClass(ItemModel, [{ key: "defaults", value: function defaults()

      {
        return {
          _isActive: false,
          _isVisited: false };

      } }, { key: "reset", value: function reset()

      {
        this.set({ _isActive: false, _isVisited: false });
      } }, { key: "toggleActive", value: function toggleActive()

      {var isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.get('_isActive');
        this.set('_isActive', isActive);
      } }, { key: "toggleVisited", value: function toggleVisited()

      {var isVisited = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.get('_isVisited');
        this.set('_isVisited', isVisited);
      } }]);return ItemModel;}(Backbone.Model);



  return ItemModel;

});

define('core/js/models/itemsComponentModel', [
'core/js/models/componentModel',
'core/js/models/itemModel'],
function (ComponentModel, ItemModel) {var

  ItemsComponentModel = /*#__PURE__*/function (_ComponentModel) {"use strict";_inherits(ItemsComponentModel, _ComponentModel);var _super32 = _createSuper(ItemsComponentModel);function ItemsComponentModel() {_classCallCheck(this, ItemsComponentModel);return _super32.apply(this, arguments);}_createClass(ItemsComponentModel, [{ key: "toJSON", value: function toJSON()

      {
        var json = _get(_getPrototypeOf(ItemsComponentModel.prototype), "toJSON", this).call(this);
        // Make sure _items is updated from child collection
        json._items = this.getChildren().toJSON();
        return json;
      } }, { key: "init", value: function init()

      {
        this.setUpItems();
        this.listenTo(this.getChildren(), {
          'all': this.onAll,
          'change:_isVisited': this.checkCompletionStatus });

        _get(_getPrototypeOf(ItemsComponentModel.prototype), "init", this).call(this);
      } }, { key: "restoreUserAnswers", value: function restoreUserAnswers()

      {var _this75 = this;
        var booleanArray = this.get('_userAnswer');
        if (!booleanArray) return;
        this.getChildren().forEach(function (child, index) {_newArrowCheck(this, _this75);return child.set('_isVisited', booleanArray[index]);}.bind(this));
      } }, { key: "storeUserAnswer", value: function storeUserAnswer()

      {var _this76 = this;
        var booleanArray = this.getChildren().map(function (child) {_newArrowCheck(this, _this76);return child.get('_isVisited');}.bind(this));
        this.set('_userAnswer', booleanArray);
      } }, { key: "setUpItems", value: function setUpItems()

      {var _this77 = this;
        // see https://github.com/adaptlearning/adapt_framework/issues/2480
        var items = this.get('_items') || [];
        items.forEach(function (item, index) {_newArrowCheck(this, _this77);return item._index = index;}.bind(this));
        this.setChildren(new Backbone.Collection(items, { model: ItemModel }));
      } }, { key: "getItem", value: function getItem(

      index) {
        return this.getChildren().findWhere({ _index: index });
      } }, { key: "getVisitedItems", value: function getVisitedItems()

      {
        return this.getChildren().where({ _isVisited: true });
      } }, { key: "getActiveItems", value: function getActiveItems()

      {
        return this.getChildren().where({ _isActive: true });
      } }, { key: "getActiveItem", value: function getActiveItem()

      {
        return this.getChildren().findWhere({ _isActive: true });
      } }, { key: "areAllItemsCompleted", value: function areAllItemsCompleted()

      {
        return this.getVisitedItems().length === this.getChildren().length;
      } }, { key: "checkCompletionStatus", value: function checkCompletionStatus()

      {
        this.storeUserAnswer();
        if (!this.areAllItemsCompleted()) return;
        this.setCompletionStatus();
      } }, { key: "reset", value: function reset(

      type, force) {var _this78 = this;
        this.getChildren().each(function (item) {_newArrowCheck(this, _this78);return item.reset();}.bind(this));
        _get(_getPrototypeOf(ItemsComponentModel.prototype), "reset", this).call(this, type, force);
      } }, { key: "resetActiveItems", value: function resetActiveItems()

      {var _this79 = this;
        this.getChildren().each(function (item) {_newArrowCheck(this, _this79);return item.toggleActive(false);}.bind(this));
      } }, { key: "setActiveItem", value: function setActiveItem(

      index) {
        var item = this.getItem(index);
        if (!item) return;

        var activeItem = this.getActiveItem();
        if (activeItem) activeItem.toggleActive(false);
        item.toggleActive(true);
      } }]);return ItemsComponentModel;}(ComponentModel);



  return ItemsComponentModel;

});

define('components/adapt-contrib-accordion/js/accordionModel', [
'core/js/models/itemsComponentModel'],
function (ItemsComponentModel) {var

  AccordionModel = /*#__PURE__*/function (_ItemsComponentModel) {"use strict";_inherits(AccordionModel, _ItemsComponentModel);var _super33 = _createSuper(AccordionModel);function AccordionModel() {_classCallCheck(this, AccordionModel);return _super33.apply(this, arguments);}_createClass(AccordionModel, [{ key: "defaults", value: function defaults()

      {
        return ItemsComponentModel.resultExtend('defaults', {
          _shouldCollapseItems: true,
          _toggleSpeed: 200 },
        this);
      } }, { key: "toggleItemsState", value: function toggleItemsState(

      index) {
        var item = this.getItem(index);
        var previousActiveItem = this.getActiveItem();

        item.toggleActive();
        item.toggleVisited(true);

        if (previousActiveItem && this.get('_shouldCollapseItems')) {
          previousActiveItem.toggleActive(false);
        }
      } }]);return AccordionModel;}(ItemsComponentModel);



  return AccordionModel;

});

define('core/js/views/componentView', [
'core/js/adapt',
'core/js/views/adaptView'],
function (Adapt, AdaptView) {var

  ComponentView = /*#__PURE__*/function (_AdaptView4) {"use strict";_inherits(ComponentView, _AdaptView4);var _super34 = _createSuper(ComponentView);function ComponentView() {_classCallCheck(this, ComponentView);return _super34.apply(this, arguments);}_createClass(ComponentView, [{ key: "attributes", value: function attributes()

      {
        if (!this.model.get('_isA11yRegionEnabled')) {
          return AdaptView.resultExtend('attributes', {}, this);
        }
        return AdaptView.resultExtend('attributes', {
          'aria-labelledby': this.model.get('_id') + '-heading',
          'role': 'region' },
        this);
      } }, { key: "className", value: function className()

      {
        return [
        'component',
        this.model.get('_component').toLowerCase(),
        this.model.get('_id'),
        this.model.get('_classes'),
        this.setVisibility(),
        this.setHidden(),
        'is-' + this.model.get('_layout'),
        this.model.get('_isComplete') ? 'is-complete' : '',
        this.model.get('_isOptional') ? 'is-optional' : ''].
        join(' ');
      } }, { key: "renderState", value: function renderState()

      {
        Adapt.log.removed('renderState is removed and moved to item title');
      }

      /**
         * Allows components that want to use inview for completion to set that up
         * @param {string} [inviewElementSelector] Allows to you to specify (via a selector) which DOM element to use for inview.
         * Defaults to `'.component__inner'` if not supplied.
         * @param {function} [callback] Allows you to specify what function is called when the component has been viewed, should
         * you want to perform additional checks before setting the component to completed - see adapt-contrib-assessmentResults
         * for an example. Defaults to `view.setCompletionStatus` if not specified.
         */ }, { key: "setupInviewCompletion", value: function setupInviewCompletion()
      {var inviewElementSelector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.component__inner';var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.setCompletionStatus;
        this.$inviewElement = this.$(inviewElementSelector);
        this.inviewCallback = callback;

        this.$inviewElement.on('inview.componentView', this.onInview.bind(this));
      } }, { key: "removeInviewListener", value: function removeInviewListener()

      {
        if (!this.$inviewElement) return;
        this.$inviewElement.off('inview.componentView');
        this.$inviewElement = null;
      } }, { key: "onInview", value: function onInview(

      event, visible, visiblePartX, visiblePartY) {
        if (!visible) return;

        switch (visiblePartY) {
          case 'top':
            this.hasSeenTop = true;
            break;
          case 'bottom':
            this.hasSeenBottom = true;
            break;
          case 'both':
            this.hasSeenTop = this.hasSeenBottom = true;}


        if (!this.hasSeenTop || !this.hasSeenBottom) return;

        this.inviewCallback();

        if (this.model.get('_isComplete')) {
          this.removeInviewListener();
        }
      } }, { key: "postRender", value: function postRender()

      {} }, { key: "remove", value: function remove()

      {
        this.removeInviewListener();
        _get(_getPrototypeOf(ComponentView.prototype), "remove", this).call(this);
      } }]);return ComponentView;}(AdaptView);



  ComponentView.type = 'component';

  return ComponentView;

});

define('components/adapt-contrib-accordion/js/accordionView', [
'core/js/views/componentView'],
function (ComponentView) {var

  AccordionView = /*#__PURE__*/function (_ComponentView) {"use strict";_inherits(AccordionView, _ComponentView);var _super35 = _createSuper(AccordionView);function AccordionView() {_classCallCheck(this, AccordionView);return _super35.apply(this, arguments);}_createClass(AccordionView, [{ key: "events", value: function events()

      {
        return {
          'click .js-toggle-item': 'onClick' };

      } }, { key: "preRender", value: function preRender()

      {
        this.checkIfResetOnRevisit();

        this.model.resetActiveItems();

        this.listenTo(this.model.get('_children'), {
          'change:_isActive': this.onItemsActiveChange,
          'change:_isVisited': this.onItemsVisitedChange });

      } }, { key: "postRender", value: function postRender()

      {
        this.setReadyStatus();

        if (this.model.get('_setCompletionOn') === 'inview') {
          this.setupInviewCompletion();
        }
      } }, { key: "checkIfResetOnRevisit", value: function checkIfResetOnRevisit()

      {
        var isResetOnRevisit = this.model.get('_isResetOnRevisit');

        // If reset is enabled set defaults
        if (isResetOnRevisit) {
          this.model.reset(isResetOnRevisit);
        }
      } }, { key: "onClick", value: function onClick(

      event) {
        this.model.toggleItemsState($(event.currentTarget).parent().data('index'));
      } }, { key: "onItemsActiveChange", value: function onItemsActiveChange(

      item, isActive) {
        this.toggleItem(item, isActive);
      } }, { key: "onItemsVisitedChange", value: function onItemsVisitedChange(

      item, isVisited) {
        if (!isVisited) return;

        var $item = this.getItemElement(item);

        $item.children('.accordion__item-btn').addClass('is-visited');
      } }, { key: "toggleItem", value: function toggleItem(

      item, shouldExpand) {
        var $item = this.getItemElement(item);
        var $body = $item.children('.accordion__item-content').stop(true, true);

        $item.children('.accordion__item-btn').
        toggleClass('is-selected is-open', shouldExpand).
        toggleClass('is-closed', !shouldExpand).
        attr('aria-expanded', shouldExpand);

        if (!shouldExpand) {
          $body.slideUp(this.model.get('_toggleSpeed'));
          return;
        }

        $body.slideDown(this.model.get('_toggleSpeed'));
      } }, { key: "getItemElement", value: function getItemElement(

      item) {
        var index = item.get('_index');

        return this.$('.accordion__item').filter("[data-index=\"".concat(index, "\"]"));
      } }]);return AccordionView;}(ComponentView);



  AccordionView.template = 'accordion';

  return AccordionView;

});

define('components/adapt-contrib-accordion/js/adapt-contrib-accordion', [
'core/js/adapt',
'./accordionModel',
'./accordionView'],
function (Adapt, AccordionModel, AccordionView) {

  return Adapt.register('accordion', {
    model: AccordionModel,
    view: AccordionView });


});

define('components/adapt-contrib-assessmentResults/js/assessmentResultsModel', [
'core/js/adapt',
'core/js/models/componentModel'],
function (Adapt, ComponentModel) {var

  AssessmentResultsModel = /*#__PURE__*/function (_ComponentModel2) {"use strict";_inherits(AssessmentResultsModel, _ComponentModel2);var _super36 = _createSuper(AssessmentResultsModel);function AssessmentResultsModel() {_classCallCheck(this, AssessmentResultsModel);return _super36.apply(this, arguments);}_createClass(AssessmentResultsModel, [{ key: "init", value: function init()

      {var _get3;
        this.set('originalBody', this.get('body')); // save the original body text so we can restore it when the assessment is reset

        this.listenTo(Adapt, {
          'assessments:complete': this.onAssessmentComplete,
          'assessments:reset': this.onAssessmentReset });for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {args[_key15] = arguments[_key15];}


        (_get3 = _get(_getPrototypeOf(AssessmentResultsModel.prototype), "init", this)).call.apply(_get3, [this].concat(args));
      }

      /**
         * Checks to see if the assessment was completed in a previous session or not
         */ }, { key: "checkIfAssessmentComplete", value: function checkIfAssessmentComplete()
      {
        if (!Adapt.assessment || this.get('_assessmentId') === undefined) {
          return;
        }

        var assessmentModel = Adapt.assessment.get(this.get('_assessmentId'));
        if (!assessmentModel || assessmentModel.length === 0) return;

        var state = assessmentModel.getState();
        var isResetOnRevisit = assessmentModel.get('_assessment')._isResetOnRevisit;
        if (state.isComplete && (!state.allowResetIfPassed || !isResetOnRevisit)) {
          this.onAssessmentComplete(state);
          return;
        }

        this.setVisibility();
      } }, { key: "onAssessmentComplete", value: function onAssessmentComplete(

      state) {
        if (this.get('_assessmentId') === undefined ||
        this.get('_assessmentId') != state.id) return;

        /*
                                                       make shortcuts to some of the key properties in the state object so that
                                                       content developers can just use {{attemptsLeft}} in json instead of {{state.attemptsLeft}}
                                                       */
        this.set({
          _state: state,
          attempts: state.attempts,
          attemptsSpent: state.attemptsSpent,
          attemptsLeft: state.attemptsLeft,
          score: state.score,
          scoreAsPercent: state.scoreAsPercent,
          maxScore: state.maxScore,
          isPass: state.isPass });


        this.setFeedbackBand(state);

        this.checkRetryEnabled(state);

        this.setFeedbackText();

        this.toggleVisibility(true);
      } }, { key: "setFeedbackBand", value: function setFeedbackBand(

      state) {
        var scoreProp = state.isPercentageBased ? 'scoreAsPercent' : 'score';
        var bands = _.sortBy(this.get('_bands'), '_score');

        for (var i = bands.length - 1; i >= 0; i--) {
          var isScoreInBandRange = state[scoreProp] >= bands[i]._score;
          if (!isScoreInBandRange) continue;

          this.set('_feedbackBand', bands[i]);
          break;
        }
      } }, { key: "checkRetryEnabled", value: function checkRetryEnabled(

      state) {
        var assessmentModel = Adapt.assessment.get(state.id);
        if (!assessmentModel.canResetInPage()) return false;

        var feedbackBand = this.get('_feedbackBand');
        var isRetryEnabled = (feedbackBand && feedbackBand._allowRetry) !== false;
        var isAttemptsLeft = state.attemptsLeft > 0 || state.attemptsLeft === 'infinite';
        var showRetry = isRetryEnabled && isAttemptsLeft && (!state.isPass || state.allowResetIfPassed);

        this.set({
          _isRetryEnabled: showRetry,
          retryFeedback: showRetry ? this.get('_retry').feedback : '' });

      } }, { key: "setFeedbackText", value: function setFeedbackText()

      {
        var feedbackBand = this.get('_feedbackBand');

        // ensure any handlebars expressions in the .feedback are handled...
        var feedback = feedbackBand ? Handlebars.compile(feedbackBand.feedback)(this.toJSON()) : '';

        this.set({
          feedback: feedback,
          body: this.get('_completionBody') });

      } }, { key: "setVisibility", value: function setVisibility()

      {
        if (!Adapt.assessment) return;

        var isVisibleBeforeCompletion = this.get('_isVisibleBeforeCompletion') || false;
        var wasVisible = this.get('_isVisible');

        var assessmentModel = Adapt.assessment.get(this.get('_assessmentId'));
        if (!assessmentModel || assessmentModel.length === 0) return;

        var state = assessmentModel.getState();
        var isComplete = state.isComplete;
        var isAttemptInProgress = state.attemptInProgress;
        var attemptsSpent = state.attemptsSpent;
        var hasHadAttempt = !isAttemptInProgress && attemptsSpent > 0;

        var isVisible = isVisibleBeforeCompletion && !isComplete || hasHadAttempt;

        if (!wasVisible && isVisible) isVisible = (_readOnlyError("isVisible"), false);

        this.toggleVisibility(isVisible);
      } }, { key: "toggleVisibility", value: function toggleVisibility(

      isVisible) {
        if (isVisible === undefined) {
          isVisible = !this.get('_isVisible');
        }

        this.set('_isVisible', isVisible, { pluginName: 'assessmentResults' });
      } }, { key: "checkCompletion", value: function checkCompletion()

      {
        if (this.get('_setCompletionOn') === 'pass' && !this.get('isPass')) {
          return;
        }

        this.setCompletionStatus();
      }

      /**
         * Handles resetting the component whenever its corresponding assessment is reset
         * The component can either inherit the assessment's reset type or define its own
         */ }, { key: "onAssessmentReset", value: function onAssessmentReset(
      state) {
        if (this.get('_assessmentId') === undefined ||
        this.get('_assessmentId') != state.id) return;

        var resetType = this.get('_resetType');
        if (!resetType || resetType === 'inherit') {
          resetType = state.resetType || 'hard'; // backwards compatibility - state.resetType was only added in assessment v2.3.0
        }
        this.reset(resetType, true);
      } }, { key: "reset", value: function reset()

      {var _get4;
        this.set({
          body: this.get('originalBody'),
          state: null,
          feedback: '',
          _feedbackBand: null,
          retryFeedback: '',
          _isRetryEnabled: false });for (var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {args[_key16] = arguments[_key16];}


        (_get4 = _get(_getPrototypeOf(AssessmentResultsModel.prototype), "reset", this)).call.apply(_get4, [this].concat(args));
      } }]);return AssessmentResultsModel;}(ComponentModel);


  return AssessmentResultsModel;

});

define('components/adapt-contrib-assessmentResults/js/assessmentResultsView', [
'core/js/adapt',
'core/js/views/componentView'],
function (Adapt, ComponentView) {var

  AssessmentResultsView = /*#__PURE__*/function (_ComponentView2) {"use strict";_inherits(AssessmentResultsView, _ComponentView2);var _super37 = _createSuper(AssessmentResultsView);function AssessmentResultsView() {_classCallCheck(this, AssessmentResultsView);return _super37.apply(this, arguments);}_createClass(AssessmentResultsView, [{ key: "events", value: function events()

      {
        return {
          'click .js-assessment-retry-btn': 'onRetryClicked' };

      } }, { key: "preRender", value: function preRender()

      {
        this.model.setLocking('_isVisible', false);

        this.listenTo(Adapt.parentView, 'preRemove', function () {
          this.model.unsetLocking('_isVisible');
        });

        this.listenTo(this.model, {
          'change:_feedbackBand': this.addClassesToArticle,
          'change:body': this.render });

      } }, { key: "postRender", value: function postRender()

      {
        this.model.checkIfAssessmentComplete();
        this.setReadyStatus();
        this.setupInviewCompletion('.component__inner', this.model.checkCompletion.bind(this.model));
      }

      /**
         * Resets the state of the assessment and optionally redirects the user
         * back to the assessment for another attempt.
         */ }, { key: "onRetryClicked", value: function onRetryClicked()
      {var _this80 = this;
        var state = this.model.get('_state');

        Adapt.assessment.get(state.id).reset(null, function (wasReset) {_newArrowCheck(this, _this80);
          if (!wasReset) {
            return;
          }
          if (this.model.get('_retry')._routeToAssessment === true) {
            Adapt.navigateToElement('.' + state.articleId);
          }
        }.bind(this));
      }

      /**
         * If there are classes specified for the feedback band, apply them to the containing article
         * This allows for custom styling based on the band the user's score falls into
         */ }, { key: "addClassesToArticle", value: function addClassesToArticle(
      model, value) {
        if (!value || !value._classes) return;

        this.$el.parents('.article').addClass(value._classes);
      } }]);return AssessmentResultsView;}(ComponentView);



  AssessmentResultsView.template = 'assessmentResults';

  return AssessmentResultsView;

});

define('components/adapt-contrib-assessmentResults/js/adapt-contrib-assessmentResults', [
'core/js/adapt',
'./assessmentResultsModel',
'./assessmentResultsView'],
function (Adapt, AssessmentResultsModel, AssessmentResultsView) {

  return Adapt.register("assessmentResults", {
    model: AssessmentResultsModel,
    view: AssessmentResultsView });


});

define('components/adapt-contrib-blank/js/adapt-contrib-blank', [
'core/js/adapt',
'core/js/views/componentView',
'core/js/models/componentModel'],
function (Adapt, ComponentView, ComponentModel) {var

  BlankView = /*#__PURE__*/function (_ComponentView3) {"use strict";_inherits(BlankView, _ComponentView3);var _super38 = _createSuper(BlankView);function BlankView() {_classCallCheck(this, BlankView);return _super38.apply(this, arguments);}_createClass(BlankView, [{ key: "preRender", value: function preRender()

      {
        this.checkIfResetOnRevisit();
      } }, { key: "postRender", value: function postRender()

      {
        this.setReadyStatus();
        this.setupInviewCompletion();
      } }, { key: "checkIfResetOnRevisit", value: function checkIfResetOnRevisit()

      {
        var isResetOnRevisit = this.model.get('_isResetOnRevisit');

        if (isResetOnRevisit) {
          this.model.reset(isResetOnRevisit);
        }
      } }]);return BlankView;}(ComponentView);


  BlankView.template = 'blank';

  return Adapt.register('blank', {
    model: ComponentModel.extend({}), // create a new class in the inheritance chain so it can be extended per component type if necessary later
    view: BlankView });


});

define('core/js/enums/buttonStateEnum', [], function () {

  var BUTTON_STATE = ENUM([
  'SUBMIT',
  'CORRECT',
  'INCORRECT',
  'SHOW_CORRECT_ANSWER',
  'HIDE_CORRECT_ANSWER',
  'SHOW_FEEDBACK',
  'RESET']);


  return BUTTON_STATE;

});

define('core/js/views/buttonsView', [
'core/js/adapt',
'core/js/enums/buttonStateEnum'],
function (Adapt, BUTTON_STATE) {

  // convert BUTTON_STATE to property name
  var textPropertyName = {
    'SUBMIT': 'submit',
    'CORRECT': 'correct',
    'INCORRECT': 'incorrect',
    'SHOW_CORRECT_ANSWER': 'showCorrectAnswer',
    'HIDE_CORRECT_ANSWER': 'hideCorrectAnswer',
    'SHOW_FEEDBACK': 'showFeedback',
    'RESET': 'reset' };


  var ButtonsView = Backbone.View.extend({

    initialize: function initialize(options) {
      this.parent = options.parent;
      this.listenTo(Adapt.parentView, 'postRemove', this.remove);
      this.listenTo(this.model, {
        'change:_buttonState': this.onButtonStateChanged,
        'change:feedbackMessage': this.onFeedbackMessageChanged,
        'change:_attemptsLeft': this.onAttemptsChanged,
        'change:_canSubmit': this.onCanSubmitChange });

      this.render();
    },

    events: {
      'click .js-btn-action': 'onActionClicked',
      'click .js-btn-feedback': 'onFeedbackClicked' },


    render: function render() {
      var data = this.model.toJSON();
      var template = Handlebars.templates['buttons'];
      _.defer(_.bind(function () {
        this.postRender();
        Adapt.trigger('buttonsView:postRender', this);
      }, this));
      this.$el.html(template(data));
    },

    postRender: function postRender() {
      this.refresh();
    },

    checkResetSubmittedState: function checkResetSubmittedState() {
      var isSubmitted = this.model.get('_isSubmitted');

      if (!isSubmitted) {
        this.$('.js-btn-marking').removeClass('is-incorrect is-correct').addClass('u-display-none');
        this.$el.removeClass('is-submitted');
        this.model.set('feedbackMessage', undefined);
        Adapt.a11y.toggleAccessibleEnabled(this.$('.js-btn-feedback'), false);
      } else {
        this.$el.addClass('is-submitted');
      }
    },

    onActionClicked: function onActionClicked() {
      var buttonState = this.model.get('_buttonState');
      this.trigger('buttons:stateUpdate', BUTTON_STATE(buttonState));
      this.checkResetSubmittedState();
    },

    onFeedbackClicked: function onFeedbackClicked() {
      this.trigger('buttons:stateUpdate', BUTTON_STATE.SHOW_FEEDBACK);
    },

    onFeedbackMessageChanged: function onFeedbackMessageChanged(model, changedAttribute) {
      if (changedAttribute && this.model.get('_canShowFeedback')) {
        // enable feedback button
        Adapt.a11y.toggleAccessibleEnabled(this.$('.js-btn-feedback'), true);
      } else {
        // disable feedback button
        Adapt.a11y.toggleAccessibleEnabled(this.$('.js-btn-feedback'), false);
      }
    },

    onCanSubmitChange: function onCanSubmitChange() {
      this.onButtonStateChanged(this.model, this.model.get('_buttonState'));
    },

    onButtonStateChanged: function onButtonStateChanged(model, changedAttribute) {

      this.updateAttemptsCount();

      // Use 'correct' instead of 'complete' to signify button state
      var $buttonsAction = this.$('.js-btn-action');
      var buttonState = BUTTON_STATE(changedAttribute);
      if (changedAttribute === BUTTON_STATE.CORRECT || changedAttribute === BUTTON_STATE.INCORRECT) {
        // Both 'correct' and 'incorrect' states have no model answer, so disable the submit button

        Adapt.a11y.toggleAccessibleEnabled($buttonsAction, false);

      } else {

        var propertyName = textPropertyName[buttonState.asString];
        var ariaLabel = this.model.get('_buttons')['_' + propertyName].ariaLabel;
        var buttonText = this.model.get('_buttons')['_' + propertyName].buttonText;

        // Enable the button, make accessible and update aria labels and text

        Adapt.a11y.toggleAccessibleEnabled($buttonsAction, this.model.get('_canSubmit'));
        $buttonsAction.html(buttonText).attr('aria-label', ariaLabel);

        // Make model answer button inaccessible (but still enabled) for visual users due to
        // the inability to represent selected incorrect/correct answers to a screen reader, may need revisiting
        switch (changedAttribute) {
          case BUTTON_STATE.SHOW_CORRECT_ANSWER:
          case BUTTON_STATE.HIDE_CORRECT_ANSWER:

            Adapt.a11y.toggleAccessible($buttonsAction, false);}


      }
    },

    checkFeedbackState: function checkFeedbackState() {
      var canShowFeedback = this.model.get('_canShowFeedback');

      this.$('.js-btn-action').toggleClass('is-full-width', !canShowFeedback);
      this.$('.js-btn-feedback').toggleClass('u-display-none', !canShowFeedback);
      this.$('.js-btn-marking').toggleClass('is-full-width u-display-none', !canShowFeedback);
    },

    updateAttemptsCount: function updateAttemptsCount(model, changedAttribute) {
      var isInteractionComplete = this.model.get('_isInteractionComplete');
      var attemptsLeft = this.model.get('_attemptsLeft') ? this.model.get('_attemptsLeft') : this.model.get('_attempts');
      var shouldDisplayAttempts = this.model.get('_shouldDisplayAttempts');
      var attemptsString;

      this.checkResetSubmittedState();

      if (!isInteractionComplete && attemptsLeft !== 0) {
        attemptsString = attemptsLeft + ' ';
        if (attemptsLeft > 1) {
          attemptsString += this.model.get('_buttons').remainingAttemptsText;
        } else if (attemptsLeft === 1) {
          attemptsString += this.model.get('_buttons').remainingAttemptText;
        }

      } else {
        this.$('.js-display-attempts').addClass('u-visibility-hidden');
        this.showMarking();
      }

      if (shouldDisplayAttempts) {
        this.$('.js-insert-attempts-string').html(attemptsString);
      }

    },

    showMarking: function showMarking() {
      if (!this.model.shouldShowMarking) return;

      var isCorrect = this.model.get('_isCorrect');
      var ariaLabels = Adapt.course.get('_globals')._accessibility._ariaLabels;

      this.$('.js-btn-marking').
      removeClass('u-display-none').
      addClass(isCorrect ? 'is-correct' : 'is-incorrect').
      attr('aria-label', isCorrect ? ariaLabels.answeredCorrectly : ariaLabels.answeredIncorrectly);
    },

    refresh: function refresh() {
      this.updateAttemptsCount();
      this.checkResetSubmittedState();
      this.checkFeedbackState();
      this.onButtonStateChanged(null, this.model.get('_buttonState'));
      this.onFeedbackMessageChanged(null, this.model.get('feedbackMessage'));
    } });



  return ButtonsView;

});

define('core/js/models/questionModel', [
'core/js/adapt',
'core/js/models/componentModel',
'core/js/enums/buttonStateEnum'],
function (Adapt, ComponentModel, BUTTON_STATE) {var

  QuestionModel = /*#__PURE__*/function (_ComponentModel3) {"use strict";_inherits(QuestionModel, _ComponentModel3);var _super39 = _createSuper(QuestionModel);function QuestionModel() {_classCallCheck(this, QuestionModel);return _super39.apply(this, arguments);}_createClass(QuestionModel, [{ key: "defaults",

      /// ///
      // Setup question types
      /// /

      // Used to set model defaults
      value: function defaults() {
        // Extend from the ComponentModel defaults
        return ComponentModel.resultExtend('defaults', {
          _isQuestionType: true,
          _shouldDisplayAttempts: false,
          _canShowModelAnswer: true,
          _canShowFeedback: true,
          _canShowMarking: true,
          _canSubmit: true,
          _isSubmitted: false,
          _questionWeight: Adapt.config.get('_questionWeight'),
          _items: [] });

      }

      // Extend from the ComponentModel trackable
    }, { key: "trackable", value: function trackable() {
        return ComponentModel.resultExtend('trackable', [
        '_isSubmitted',
        '_score',
        '_isCorrect',
        '_attemptsLeft']);

      } }, { key: "trackableType", value: function trackableType()

      {
        return ComponentModel.resultExtend('trackableType', [
        Boolean,
        Number,
        Boolean,
        Number]);

      }

      /**
         * Returns a string of the model type group.
         * @returns {string}
         */ }, { key: "getTypeGroup", value: function getTypeGroup()
      {
        return 'question';
      } }, { key: "init", value: function init()

      {
        this.setupDefaultSettings();
        this.setLocking('_canSubmit', true);
        _get(_getPrototypeOf(QuestionModel.prototype), "init", this).call(this);
      }

      // Calls default methods to setup on questions
    }, { key: "setupDefaultSettings", value: function setupDefaultSettings() {
        // Not sure this is needed anymore, keeping to maintain API
        this.setupWeightSettings();
        this.setupButtonSettings();
      }

      // Used to setup either global or local button text
    }, { key: "setupButtonSettings", value: function setupButtonSettings() {
        var globalButtons = Adapt.course.get('_buttons');

        // Check if  '_buttons' attribute exists and if not use the globally defined buttons.
        if (!this.has('_buttons')) {
          this.set('_buttons', globalButtons);
        } else {
          // Check all the components buttons.
          // If they are empty use the global defaults.
          var componentButtons = this.get('_buttons');

          for (var key in componentButtons) {
            if (_typeof(componentButtons[key]) === 'object') {
              // Button text.
              if (!componentButtons[key].buttonText && globalButtons[key].buttonText) {
                componentButtons[key].buttonText = globalButtons[key].buttonText;
              }

              // ARIA labels.
              if (!componentButtons[key].ariaLabel && globalButtons[key].ariaLabel) {
                componentButtons[key].ariaLabel = globalButtons[key].ariaLabel;
              }
            }

            if (!componentButtons[key] && globalButtons[key]) {
              componentButtons[key] = globalButtons[key];
            }
          }
        }
      }

      // Used to setup either global or local question weight/score
    }, { key: "setupWeightSettings", value: function setupWeightSettings() {

      } // Not needed as handled by model defaults, keeping to maintain API

      /// ///
      // Submit process
      /// /

      // Use to check if the user is allowed to submit the question
      // Maybe the user has to select an item?
    }, { key: "canSubmit", value: function canSubmit() {} }, { key: "checkCanSubmit", value: function checkCanSubmit()

      {
        this.set('_canSubmit', this.canSubmit(), { pluginName: 'adapt' });
      }

      // Used to update the amount of attempts the user has left
    }, { key: "updateAttempts", value: function updateAttempts() {
        if (!this.get('_attemptsLeft')) {
          this.set('_attemptsLeft', this.get('_attempts'));
        }
        this.set('_attemptsLeft', this.get('_attemptsLeft') - 1);
      }

      // Used to set _isEnabled and _isSubmitted on the model
    }, { key: "setQuestionAsSubmitted", value: function setQuestionAsSubmitted() {
        this.set({
          _isEnabled: false,
          _isSubmitted: true });

      }

      // Sets _isCorrect:true/false based upon isCorrect method below
    }, { key: "markQuestion", value: function markQuestion() {

        if (this.isCorrect()) {
          this.set('_isCorrect', true);
        } else {
          this.set('_isCorrect', false);
        }

      }

      // Should return a boolean based upon whether to question is correct or not
    }, { key: "isCorrect", value: function isCorrect() {}

      // Used to set the score based upon the _questionWeight
    }, { key: "setScore", value: function setScore() {}

      // Checks if the question should be set to complete
      // Calls setCompletionStatus and adds complete classes
    }, { key: "checkQuestionCompletion", value: function checkQuestionCompletion() {

        var isComplete = this.get('_isCorrect') || this.get('_attemptsLeft') === 0;

        if (isComplete) {
          this.setCompletionStatus();
        }

        return isComplete;

      }

      // Updates buttons based upon question state by setting
      // _buttonState on the model which buttonsView listens to
    }, { key: "updateButtons", value: function updateButtons() {

        var isInteractionComplete = this.get('_isInteractionComplete');
        var isCorrect = this.get('_isCorrect');
        var isEnabled = this.get('_isEnabled');
        var buttonState = this.get('_buttonState');
        var canShowModelAnswer = this.get('_canShowModelAnswer');

        if (isInteractionComplete) {

          if (isCorrect || !canShowModelAnswer) {
            // Use correct instead of complete to signify button state
            this.set('_buttonState', BUTTON_STATE.CORRECT);

          } else {

            switch (buttonState) {
              case BUTTON_STATE.SUBMIT:
              case BUTTON_STATE.HIDE_CORRECT_ANSWER:
                this.set('_buttonState', BUTTON_STATE.SHOW_CORRECT_ANSWER);
                break;
              default:
                this.set('_buttonState', BUTTON_STATE.HIDE_CORRECT_ANSWER);}


          }

        } else {

          if (isEnabled) {
            this.set('_buttonState', BUTTON_STATE.SUBMIT);
          } else {
            this.set('_buttonState', BUTTON_STATE.RESET);
          }
        }

      }

      // Used to setup the correct, incorrect and partly correct feedback
    }, { key: "setupFeedback", value: function setupFeedback() {
        if (!this.has('_feedback')) return;

        if (this.get('_isCorrect')) {
          this.setupCorrectFeedback();
        } else if (this.isPartlyCorrect()) {
          this.setupPartlyCorrectFeedback();
        } else {
          this.setupIncorrectFeedback();
        }
      }

      // Used by the question to determine if the question is incorrect or partly correct
      // Should return a boolean
    }, { key: "isPartlyCorrect", value: function isPartlyCorrect() {} }, { key: "setupCorrectFeedback", value: function setupCorrectFeedback()

      {
        this.set({
          feedbackTitle: this.getFeedbackTitle(),
          feedbackMessage: this.get('_feedback').correct });

      } }, { key: "setupPartlyCorrectFeedback", value: function setupPartlyCorrectFeedback()

      {
        var feedback = this.get('_feedback')._partlyCorrect;

        if (feedback && feedback.final) {
          this.setAttemptSpecificFeedback(feedback);
        } else {
          this.setupIncorrectFeedback();
        }
      } }, { key: "setupIncorrectFeedback", value: function setupIncorrectFeedback()

      {
        this.setAttemptSpecificFeedback(this.get('_feedback')._incorrect);
      } }, { key: "setAttemptSpecificFeedback", value: function setAttemptSpecificFeedback(

      feedback) {
        var body = this.get('_attemptsLeft') && feedback.notFinal || feedback.final;

        this.set({
          feedbackTitle: this.getFeedbackTitle(),
          feedbackMessage: body });

      } }, { key: "getFeedbackTitle", value: function getFeedbackTitle()

      {
        return this.get('_feedback').title || this.get('displayTitle') || this.get('title') || '';
      }

      /**
         * Used to determine whether the learner is allowed to interact with the question component or not.
         * @return {Boolean}
         */ }, { key: "isInteractive", value: function isInteractive()
      {
        return !this.get('_isComplete') || this.get('_isEnabled') && !this.get('_isSubmitted');
      }

      // Reset the model to let the user have another go (not the same as attempts)
    }, { key: "reset", value: function reset(type, force) {
        if (!this.get('_canReset') && !force) return;

        type = type || true; // hard reset by default, can be "soft", "hard"/true

        _get(_getPrototypeOf(QuestionModel.prototype), "reset", this).call(this, type, force);

        var attempts = this.get('_attempts');
        this.set({
          _attemptsLeft: attempts,
          _isCorrect: undefined,
          _isSubmitted: false,
          _buttonState: BUTTON_STATE.SUBMIT });

      }

      // Reset question for subsequent attempts
    }, { key: "setQuestionAsReset", value: function setQuestionAsReset() {
        this.set({
          _isEnabled: true,
          _isSubmitted: false });

      } }, { key: "refresh", value: function refresh()

      {
        this.trigger('question:refresh');
      } }, { key: "getButtonState", value: function getButtonState()

      {
        if (this.get('_isCorrect')) {
          return BUTTON_STATE.CORRECT;
        }

        if (this.get('_attemptsLeft') === 0) {
          return this.get('_canShowModelAnswer') ? BUTTON_STATE.SHOW_CORRECT_ANSWER : BUTTON_STATE.INCORRECT;
        }

        return this.get('_isSubmitted') ? BUTTON_STATE.RESET : BUTTON_STATE.SUBMIT;
      }

      // Returns an object specific to the question type, e.g. if the question
      // is a 'choice' this should contain an object with:
      // - correctResponsesPattern[]
      // - choices[]
    }, { key: "getInteractionObject", value: function getInteractionObject() {
        return {};
      }

      // Returns a string detailing how the user answered the question.
    }, { key: "getResponse", value: function getResponse() {}

      // Returns a string describing the type of interaction: "choice" and "matching" supported (see scorm wrapper)
    }, { key: "getResponseType", value: function getResponseType() {}

      /**
                                                                       * Called at the end of the onSubmitClicked view function.
                                                                       */ }, { key: "onSubmitted", value: function onSubmitted()
      {
        // Stores the current attempt state
        this.addAttemptObject();
      }

      /** @type {boolean} */ }, { key: "shouldShowMarking", get: function get()
      {
        if (!this.get('_canShowMarking')) {
          return false;
        }

        return this.get('_isInteractionComplete');
      } }]);return QuestionModel;}(ComponentModel);



  // This abstract model needs to registered to support deprecated view-only questions
  Adapt.register('question', { model: QuestionModel });

  return QuestionModel;

});

define('core/js/views/questionView', [
'core/js/adapt',
'core/js/views/componentView',
'core/js/views/buttonsView',
'core/js/models/questionModel',
'core/js/enums/buttonStateEnum'],
function (Adapt, ComponentView, ButtonsView, QuestionModel, BUTTON_STATE) {

  var useQuestionModelOnly = false;var

  QuestionView = /*#__PURE__*/function (_ComponentView4) {"use strict";_inherits(QuestionView, _ComponentView4);var _super40 = _createSuper(QuestionView);function QuestionView() {_classCallCheck(this, QuestionView);return _super40.apply(this, arguments);}_createClass(QuestionView, [{ key: "className", value: function className()

      {
        return [
        'component',
        'is-question',
        this.model.get('_component').toLowerCase(),
        this.model.get('_id'),
        this.model.get('_classes'),
        this.setVisibility(),
        'is-' + this.model.get('_layout'),
        this.model.get('_isComplete') ? 'is-complete' : '',
        this.model.get('_isOptional') ? 'is-optional' : '',
        this.model.get('_canShowModelAnswer') ? 'can-show-model-answer' : '',
        this.model.get('_canShowFeedback') ? 'can-show-feedback' : '',
        this.model.get('_canShowMarking') ? 'can-show-marking' : ''].
        join(' ');
      } }, { key: "preRender", value: function preRender()

      {
        // Setup listener for _isEnabled
        this.listenTo(this.model, 'change:_isEnabled', this.onEnabledChanged);

        this.listenTo(this.model, 'question:refresh', this.refresh);

        // Checks to see if the question should be reset on revisit
        this.checkIfResetOnRevisit();
        // This method helps setup default settings on the model
        this._runModelCompatibleFunction('setupDefaultSettings');
        // Blank method for setting up questions before rendering
        this.setupQuestion();
      }

      // Used in the question view to disabled the question when _isEnabled has been set to false
    }, { key: "onEnabledChanged", value: function onEnabledChanged(model, changedAttribute) {

        // If isEnabled == false add disabled class
        // else remove disabled class
        if (!changedAttribute) {
          this.$('.component__widget').addClass('is-disabled');
          this.disableQuestion();
        } else {
          this.$('.component__widget').removeClass('is-disabled');
          this.enableQuestion();
        }

      }

      // Used by the question to disable the question during submit and complete stages
    }, { key: "disableQuestion", value: function disableQuestion() {}

      // Used by the question to enable the question during interactions
    }, { key: "enableQuestion", value: function enableQuestion() {}

      // Used to check if the question should reset on revisit
    }, { key: "checkIfResetOnRevisit", value: function checkIfResetOnRevisit() {var _this81 = this;

        var isResetOnRevisit = this.model.get('_isResetOnRevisit');

        // Convert AAT "false" string to boolean
        isResetOnRevisit = isResetOnRevisit === "false" ?
        false :
        isResetOnRevisit;

        // If reset is enabled set defaults
        // Call blank method for question to handle
        if (isResetOnRevisit) {

          this.model.reset(isResetOnRevisit, true);

          // Defer is added to allow the component to render
          _.defer(function () {_newArrowCheck(this, _this81);
            this.resetQuestionOnRevisit(isResetOnRevisit);
          }.bind(this));

        } else {

          // If complete - display users answer
          // or reset the question if not complete
          var isInteractionComplete = this.model.get('_isInteractionComplete');

          if (isInteractionComplete) {
            this.model.set('_buttonState', BUTTON_STATE.HIDE_CORRECT_ANSWER);
            // Defer is added to allow the component to render
            _.defer(function () {_newArrowCheck(this, _this81);
              this.onHideCorrectAnswerClicked();
            }.bind(this));

          } else {
            this.model.set('_buttonState', BUTTON_STATE.SUBMIT);
            // Defer is added to allow the component to render
            _.defer(function () {_newArrowCheck(this, _this81);
              this.onResetClicked();
            }.bind(this));
          }

        }

      }

      // Used by the question to reset the question when revisiting the component
    }, { key: "resetQuestionOnRevisit", value: function resetQuestionOnRevisit(type) {}

      // Left blank for question setup - should be used instead of preRender
    }, { key: "setupQuestion", value: function setupQuestion() {}

      // Calls default methods to setup after the question is rendered
    }, { key: "postRender", value: function postRender() {
        this.addButtonsView();
        this.onQuestionRendered();
      }

      // Used to setup buttonsView and sets up the internal events for the question
    }, { key: "addButtonsView", value: function addButtonsView() {
        this.buttonsView = new ButtonsView({ model: this.model, el: this.$('.btn__container') });

        this.listenTo(this.buttonsView, 'buttons:stateUpdate', this.onButtonStateUpdate);

      } }, { key: "onButtonStateUpdate", value: function onButtonStateUpdate(

      buttonState) {

        switch (buttonState) {
          case BUTTON_STATE.SUBMIT:
            this.onSubmitClicked();
            break;
          case BUTTON_STATE.RESET:
            this.onResetClicked();
            break;
          case BUTTON_STATE.SHOW_CORRECT_ANSWER:
            this.onShowCorrectAnswerClicked();
            break;
          case BUTTON_STATE.HIDE_CORRECT_ANSWER:
            this.onHideCorrectAnswerClicked();
            break;
          case BUTTON_STATE.SHOW_FEEDBACK:
            this.showFeedback();
            break;}


      }

      // Blank method used just like postRender is for presentational components
    }, { key: "onQuestionRendered", value: function onQuestionRendered() {}

      // Triggered when the submit button is clicked
    }, { key: "onSubmitClicked", value: function onSubmitClicked() {
        // canSubmit is setup in questions and should return a boolean
        // If the question stops the user form submitting - show instruction error
        // and give a blank method, onCannotSubmit to the question
        var canSubmit = this._runModelCompatibleFunction('canSubmit');

        if (!canSubmit) {
          this.showInstructionError();
          this.onCannotSubmit();
          return;
        }

        // Used to update the amount of attempts the question has
        this._runModelCompatibleFunction('updateAttempts');

        // Used to set attributes on the model after being submitted
        // Also adds a class of submitted
        this._runModelCompatibleFunction('setQuestionAsSubmitted');

        // Used to remove instruction error that is set when
        // the user has interacted in the wrong way
        this.removeInstructionError();

        // Used to store the users answer for later
        // This is a blank method given to the question
        this._runModelCompatibleFunction('storeUserAnswer');

        // Used to set question as correct:true/false
        // Calls isCorrect which is blank for the question
        // to fill out and return a boolean
        this._runModelCompatibleFunction('markQuestion', 'isCorrect');

        // Used by the question to set the score on the model
        this._runModelCompatibleFunction('setScore');

        // Used to check if the question is complete
        // Triggers setCompletionStatus and adds class to widget
        this._runModelCompatibleFunction('checkQuestionCompletion');

        // Used by the question to display markings on the component
        if (this.model.shouldShowMarking) {
          this.showMarking();
        }

        this.recordInteraction();

        // Used to setup the feedback by checking against
        // question isCorrect or isPartlyCorrect
        this._runModelCompatibleFunction('setupFeedback');

        // Used to trigger an event so plugins can display feedback
        // Do this before updating the buttons so that the focus can be
        // shifted immediately
        this.showFeedback();

        // Force height re-calculations before the submit button
        // becomes disabled.
        $(window).resize();

        // Used to update buttonsView based upon question state
        // Update buttons happens before showFeedback to preserve tabindexes and after setupFeedback to allow buttons to use feedback attribute
        this._runModelCompatibleFunction('updateButtons');

        this.model.onSubmitted();
        this.onSubmitted();
      } }, { key: "showInstructionError", value: function showInstructionError()

      {
        Adapt.trigger('questionView:showInstructionError', this);
      }

      // Blank method for question to fill out when the question cannot be submitted
    }, { key: "onCannotSubmit", value: function onCannotSubmit() {}

      // Blank method for question to fill out when the question was successfully submitted
    }, { key: "onSubmitted", value: function onSubmitted() {}

      // Used to set _isEnabled and _isSubmitted on the model
      // Also adds a 'submitted' class to the widget
    }, { key: "setQuestionAsSubmitted", value: function setQuestionAsSubmitted() {
        this.model.setQuestionAsSubmitted();
        this.$('.component__widget').addClass('is-submitted');
      }

      // Removes validation error class when the user canSubmit
    }, { key: "removeInstructionError", value: function removeInstructionError() {
        this.$('.component__instruction-inner').removeClass('validation-error');
      }

      // This is important and should give the user feedback on how they answered the question
      // Normally done through ticks and crosses by adding classes
    }, { key: "showMarking", value: function showMarking() {}

      // Checks if the question should be set to complete
      // Calls setCompletionStatus and adds complete classes
    }, { key: "checkQuestionCompletion", value: function checkQuestionCompletion() {

        var isComplete = this.model.checkQuestionCompletion();

        if (isComplete) {
          this.$('.component__widget').addClass('is-complete show-user-answer');
        }

      } }, { key: "recordInteraction", value: function recordInteraction()

      {
        if (this.model.get('_recordInteraction') === true || !this.model.has('_recordInteraction')) {
          Adapt.trigger('questionView:recordInteraction', this);
        }
      }

      // Used to show feedback based upon whether _canShowFeedback is true
    }, { key: "showFeedback", value: function showFeedback() {

        if (this.model.get('_canShowFeedback')) {
          Adapt.trigger('questionView:showFeedback', this);
        } else {
          Adapt.trigger('questionView:disabledFeedback', this);
        }

      } }, { key: "onResetClicked", value: function onResetClicked()

      {
        this.setQuestionAsReset();

        this._runModelCompatibleFunction('resetUserAnswer');

        this.resetQuestion();

        this.model.checkCanSubmit();

        this._runModelCompatibleFunction('updateButtons');

        // onResetClicked is called as part of the checkIfResetOnRevisit
        // function and as a button click. if the view is already rendered,
        // then the button was clicked, focus on the first tabbable element
        if (!this.model.get('_isReady')) return;
        // Attempt to get the current page location
        var currentModel = Adapt.findById(Adapt.location._currentId);
        // Make sure the page is ready
        if (!currentModel || !currentModel.get('_isReady')) return;
        // Focus on the first readable item in this element
        Adapt.a11y.focusNext(this.$el);

      } }, { key: "setQuestionAsReset", value: function setQuestionAsReset()

      {
        this.model.setQuestionAsReset();
        this.$('.component__widget').removeClass('is-submitted');
      }

      // Used by the question view to reset the look and feel of the component.
      // This could also include resetting item data
      // This is triggered when the reset button is clicked so it shouldn't
      // be a full reset
    }, { key: "resetQuestion", value: function resetQuestion() {} }, { key: "refresh", value: function refresh()

      {
        this.model.set('_buttonState', this.model.getButtonState());

        if (this.model.shouldShowMarking && this.model.get('_isSubmitted')) {
          this.showMarking();
        }

        if (this.buttonsView) {
          _.defer(this.buttonsView.refresh.bind(this.buttonsView));
        }
      } }, { key: "onShowCorrectAnswerClicked", value: function onShowCorrectAnswerClicked()

      {
        this.setQuestionAsShowCorrect();

        this._runModelCompatibleFunction('updateButtons');

        this.showCorrectAnswer();
      } }, { key: "setQuestionAsShowCorrect", value: function setQuestionAsShowCorrect()

      {
        this.$('.component__widget').
        addClass('is-submitted show-correct-answer').
        removeClass('show-user-answer');
      }

      // Used by the question to display the correct answer to the user
    }, { key: "showCorrectAnswer", value: function showCorrectAnswer() {} }, { key: "onHideCorrectAnswerClicked", value: function onHideCorrectAnswerClicked()

      {
        this.setQuestionAsHideCorrect();

        this._runModelCompatibleFunction('updateButtons');

        this.hideCorrectAnswer();
      } }, { key: "setQuestionAsHideCorrect", value: function setQuestionAsHideCorrect()

      {
        this.$('.component__widget').
        addClass('is-submitted show-user-answer').
        removeClass('show-correct-answer');
      }

      // Used by the question to display the users answer and
      // hide the correct answer
      // Should use the values stored in storeUserAnswer
    }, { key: "hideCorrectAnswer", value: function hideCorrectAnswer() {}

      // Time elapsed between the time the interaction was made available to the learner for response and the time of the first response
    }, { key: "getLatency", value: function getLatency() {
        return null;
      }

      // This function is overridden if useQuestionModeOnly: false. see below.
    }, { key: "_runModelCompatibleFunction", value: function _runModelCompatibleFunction(name, lookForViewOnlyFunction) {
        return this.model[name](); // questionModel Only
      } }]);return QuestionView;}(ComponentView);


  QuestionView._isQuestionType = true;

  // allows us to turn on and off the questionView style and use the separated questionModel+questionView style only
  if (useQuestionModelOnly) return QuestionView;

  /* BACKWARDS COMPATIBILITY SECTION
                                                 * This section below is only for compatibility between the separated questionView+questionModel and the old questionView
                                                 * Remove this section in when all components use questionModel and there is no need to have model behaviour in the questionView
                                                 */var

  ViewOnlyQuestionViewCompatibilityLayer = /*#__PURE__*/function (_QuestionView) {"use strict";_inherits(ViewOnlyQuestionViewCompatibilityLayer, _QuestionView);var _super41 = _createSuper(ViewOnlyQuestionViewCompatibilityLayer);function ViewOnlyQuestionViewCompatibilityLayer() {_classCallCheck(this, ViewOnlyQuestionViewCompatibilityLayer);return _super41.apply(this, arguments);}_createClass(ViewOnlyQuestionViewCompatibilityLayer, [{ key: "getInteractionObject",

      /* All of these functions have been moved to the questionModel.js file.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * On the rare occasion that they have not been overridden by the component and
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          that they call the view only questionView version,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          these functions are included as redirects to the new Question Model.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          It is very unlikely that these are needed but they are included to ensure compatibility.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * If you need to override these in your component you should now make and register a component model.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Please remove them from your question component's view.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  */

      // Returns an object specific to the question type.
      value: function getInteractionObject() {
        Adapt.log.deprecated('QuestionView.getInteractionObject, please use QuestionModel.getInteractionObject');
        return this.model.getInteractionObject();
      }

      // Retturns a string detailing how the user answered the question.
    }, { key: "getResponse", value: function getResponse() {
        Adapt.log.deprecated('QuestionView.getInteractionObject, please use QuestionModel.getInteractionObject');
        return this.model.getResponse();
      }

      // Returns a string describing the type of interaction: "choice" and "matching" supported (see scorm wrapper)
    }, { key: "getResponseType", value: function getResponseType() {
        Adapt.log.deprecated('QuestionView.getResponseType, please use QuestionModel.getResponseType');
        return this.model.getResponseType();
      }

      // Calls default methods to setup on questions
    }, { key: "setupDefaultSettings", value: function setupDefaultSettings() {
        Adapt.log.deprecated('QuestionView.setupDefaultSettings, please use QuestionModel.setupDefaultSettings');
        return this.model.setupDefaultSettings();
      }

      // Used to setup either global or local button text
    }, { key: "setupButtonSettings", value: function setupButtonSettings() {
        Adapt.log.deprecated('QuestionView.setupButtonSettings, please use QuestionModel.setupButtonSettings');
        return this.model.setupButtonSettings();
      }

      // Used to setup either global or local question weight/score
    }, { key: "setupWeightSettings", value: function setupWeightSettings() {
        Adapt.log.deprecated('QuestionView.setupWeightSettings, please use QuestionModel.setupWeightSettings');
        return this.model.setupWeightSettings();
      }

      // Use to check if the user is allowed to submit the question
      // Maybe the user has to select an item?
    }, { key: "canSubmit", value: function canSubmit() {
        Adapt.log.deprecated('QuestionView.canSubmit, please use QuestionModel.canSubmit');
        return this.model.canSubmit();
      }

      // Used to update the amount of attempts the user has left
    }, { key: "updateAttempts", value: function updateAttempts() {
        Adapt.log.deprecated('QuestionView.updateAttempts, please use QuestionModel.updateAttempts');
        return this.model.updateAttempts();
      }

      // This is important for returning or showing the users answer
      // This should preserve the state of the users answers
    }, { key: "storeUserAnswer", value: function storeUserAnswer() {
        Adapt.log.deprecated('QuestionView.storeUserAnswer, please use QuestionModel.storeUserAnswer');
        return this.model.storeUserAnswer();
      }

      // Used by the question view to reset the stored user answer
    }, { key: "resetUserAnswer", value: function resetUserAnswer() {
        Adapt.log.deprecated('QuestionView.resetUserAnswer, please use QuestionModel.resetUserAnswer');
        return this.model.resetUserAnswer();
      }

      // Sets _isCorrect:true/false based upon isCorrect method below
    }, { key: "markQuestion", value: function markQuestion() {

        if (this._isInViewOnlyCompatibleMode('isCorrect')) {

          if (this.isCorrect()) {
            this.model.set('_isCorrect', true);
          } else {
            this.model.set('_isCorrect', false);
          }

        } else {
          return this.model.markQuestion();
        }
      }

      // Should return a boolean based upon whether to question is correct or not
    }, { key: "isCorrect", value: function isCorrect() {
        Adapt.log.deprecated('QuestionView.isCorrect, please use QuestionModel.isCorrect');
        return this.model.isCorrect();
      }

      // Used to set the score based upon the _questionWeight
    }, { key: "setScore", value: function setScore() {
        Adapt.log.deprecated('QuestionView.setScore, please use QuestionModel.setScore');
        return this.model.setScore();
      }

      // Updates buttons based upon question state by setting
      // _buttonState on the model which buttonsView listens to
    }, { key: "updateButtons", value: function updateButtons() {
        Adapt.log.deprecated('QuestionView.updateButtons, please use QuestionModel.updateButtons');
        return this.model.updateButtons();
      }

      // Used to setup the correct, incorrect and partly correct feedback
    }, { key: "setupFeedback", value: function setupFeedback() {

        if (this._isInViewOnlyCompatibleMode('isPartlyCorrect')) {

          // Use view based feedback where necessary
          if (this.model.get('_isCorrect')) {
            this._runModelCompatibleFunction('setupCorrectFeedback');
          } else if (this.isPartlyCorrect()) {
            this._runModelCompatibleFunction('setupPartlyCorrectFeedback');
          } else {
            this._runModelCompatibleFunction('setupIncorrectFeedback');
          }

        } else {
          // Use model based feedback
          this.model.setupFeedback();
        }

      }

      // Used by the question to determine if the question is incorrect or partly correct
      // Should return a boolean
    }, { key: "isPartlyCorrect", value: function isPartlyCorrect() {
        Adapt.log.deprecated('QuestionView.isPartlyCorrect, please use QuestionModel.isPartlyCorrect');
        return this.model.isPartlyCorrect();
      } }, { key: "setupCorrectFeedback", value: function setupCorrectFeedback()

      {
        Adapt.log.deprecated('QuestionView.setupCorrectFeedback, please use QuestionModel.setupCorrectFeedback');
        return this.model.setupCorrectFeedback();
      } }, { key: "setupPartlyCorrectFeedback", value: function setupPartlyCorrectFeedback()

      {
        Adapt.log.deprecated('QuestionView.setupPartlyCorrectFeedback, please use QuestionModel.setupPartlyCorrectFeedback');
        return this.model.setupPartlyCorrectFeedback();
      } }, { key: "setupIncorrectFeedback", value: function setupIncorrectFeedback()

      {
        Adapt.log.deprecated('QuestionView.setupIncorrectFeedback, please use QuestionModel.setupIncorrectFeedback');
        return this.model.setupIncorrectFeedback();
      }

      // Helper functions for compatibility layer
    }, { key: "_runModelCompatibleFunction", value: function _runModelCompatibleFunction(name, lookForViewOnlyFunction) {
        if (this._isInViewOnlyCompatibleMode(name, lookForViewOnlyFunction)) {
          return this[name](); // questionView
        } else {
          return this.model[name](); // questionModel
        }
      } }, { key: "_isInViewOnlyCompatibleMode", value: function _isInViewOnlyCompatibleMode(

      name, lookForViewOnlyFunction) {
        // return false uses the model function questionModel
        // return true uses the view only function questionView

        var checkForFunction = lookForViewOnlyFunction || name;

        // if the function does NOT exist on the view at all, use the model only
        if (!this.constructor.prototype[checkForFunction]) return false; // questionModel

        // if the function DOES exist on the view and MATCHES the compatibility function above, use the model only
        var hasCompatibleVersion = ViewOnlyQuestionViewCompatibilityLayer.prototype.hasOwnProperty(checkForFunction);
        var usingCompatibleVersion = this.constructor.prototype[checkForFunction] === ViewOnlyQuestionViewCompatibilityLayer.prototype[checkForFunction];
        if (hasCompatibleVersion && usingCompatibleVersion) {
          switch (checkForFunction) {
            case 'setupFeedback':
            case 'markQuestion':
              return true; // questionView
          }
          return false; // questionModel
        }

        // if the function DOES exist on the view and does NOT match the compatibility function above, use the view function
        return true; // questionView
      } }]);return ViewOnlyQuestionViewCompatibilityLayer;}(QuestionView);

  ;

  // return question view class extended with the compatibility layer
  return ViewOnlyQuestionViewCompatibilityLayer;

  /* END OF BACKWARDS COMPATIBILITY SECTION */

});

define('components/adapt-contrib-mcq/js/mcqView', [
'core/js/adapt',
'core/js/views/questionView'],
function (Adapt, QuestionView) {

  var McqView = QuestionView.extend({

    events: {
      'focus .js-item-input': 'onItemFocus',
      'blur .js-item-input': 'onItemBlur',
      'change .js-item-input': 'onItemSelect',
      'keyup .js-item-input': 'onKeyPress' },


    isCorrectAnswerShown: false,

    initialize: function initialize() {
      QuestionView.prototype.initialize.apply(this, arguments);
      this.update = _.debounce(this.update.bind(this), 1);
      this.listenTo(this.model, {
        "change:_isEnabled change:_isComplete change:_isSubmitted": this.update });

      this.listenTo(this.model.getChildren(), {
        "change:_isActive": this.update });

    },

    resetQuestionOnRevisit: function resetQuestionOnRevisit() {
      this.resetQuestion();
    },

    setupQuestion: function setupQuestion() {
      this.model.setupRandomisation();
    },

    onQuestionRendered: function onQuestionRendered() {
      this.setReadyStatus();
      this.update();
    },

    onKeyPress: function onKeyPress(event) {
      if (event.which !== 13) return;
      //<ENTER> keypress
      this.onItemSelect(event);
    },

    onItemFocus: function onItemFocus(event) {
      if (!this.model.isInteractive()) return;

      this.$('.js-item-label[for=' + $(event.currentTarget).attr('id') + ']').addClass('is-highlighted');
    },

    onItemBlur: function onItemBlur(event) {
      this.$('.js-item-label[for=' + $(event.currentTarget).attr('id') + ']').removeClass('is-highlighted');
    },

    onItemSelect: function onItemSelect(event) {
      if (!this.model.isInteractive()) return;

      var index = $(event.currentTarget).data('adapt-index');
      var itemModel = this.model.getItem(index);
      var shouldSelect = !itemModel.get("_isActive");

      if (this.model.isSingleSelect()) {
        // Assume a click is always a selection
        shouldSelect = true;
        this.model.resetActiveItems();
      } else if (shouldSelect && this.model.isAtActiveLimit()) {
        // At the selection limit, deselect the last item
        this.model.getLastActiveItem().toggleActive(false);
      }

      // Select or deselect accordingly
      itemModel.toggleActive(shouldSelect);
    },

    // Blank method to add functionality for when the user cannot submit
    // Could be used for a popup or explanation dialog/hint
    onCannotSubmit: function onCannotSubmit() {},

    // This is important and should give the user feedback on how they answered the question
    // Normally done through ticks and crosses by adding classes
    showMarking: function showMarking() {
      this.update();
    },

    // Used by the question view to reset the look and feel of the component.
    resetQuestion: function resetQuestion() {
      this.model.resetActiveItems();
      this.model.resetItems();
    },

    showCorrectAnswer: function showCorrectAnswer() {
      this.isCorrectAnswerShown = true;
      this.update();
    },

    hideCorrectAnswer: function hideCorrectAnswer() {
      this.isCorrectAnswerShown = false;
      this.update();
    },

    update: function update() {
      this.updateSelection();
      this.updateMarking();
    },

    updateSelection: function updateSelection() {

      var isEnabled = this.model.get("_isEnabled");

      this.model.getChildren().each(function (itemModel) {

        var isSelected = this.isCorrectAnswerShown ?
        itemModel.get("_shouldBeSelected") :
        itemModel.get("_isActive");

        var index = itemModel.get('_index');
        this.$('.js-item-label').filter('[data-adapt-index="' + index + '"]').
        toggleClass('is-selected', isSelected).
        toggleClass('is-disabled', !isEnabled);

        this.$('.js-item-input').filter('[data-adapt-index="' + index + '"]').
        prop('checked', isSelected).
        prop('disabled', !isEnabled);

      }.bind(this));

    },

    updateMarking: function updateMarking() {

      var isInteractive = this.model.isInteractive();
      var canShowMarking = this.model.get('_canShowMarking');
      var ariaLabels = Adapt.course.get('_globals')._accessibility._ariaLabels;

      this.model.getChildren().each(function (itemModel) {

        var index = itemModel.get('_index');
        var $itemInput = this.$('.js-item-input').filter('[data-adapt-index="' + index + '"]');
        var $item = $itemInput.parents('.js-mcq-item');

        if (isInteractive || !canShowMarking) {
          // Remove item marking
          $item.removeClass('is-correct is-incorrect');
          $itemInput.attr('aria-label', $.a11y_normalize(itemModel.get("text")));
          return;
        }

        // Mark item
        var shouldBeSelected = itemModel.get("_shouldBeSelected");
        var isCorrect = Boolean(itemModel.get("_isCorrect"));
        var isActive = Boolean(itemModel.get("_isActive"));

        $item.
        toggleClass('is-correct', isCorrect).
        toggleClass('is-incorrect', !isCorrect);

        $itemInput.attr('aria-label', [
        shouldBeSelected ? ariaLabels.correct : ariaLabels.incorrect,
        ", ",
        isActive ? ariaLabels.selectedAnswer : ariaLabels.unselectedAnswer,
        ". ",
        $.a11y_normalize(itemModel.get("text"))].
        join(""));

      }.bind(this));

    } });



  return McqView;

});

define('core/js/models/itemsQuestionModel', [
'core/js/adapt',
'core/js/models/questionModel',
'core/js/models/itemsComponentModel'],
function (Adapt, QuestionModel, ItemsComponentModel) {var _this82 = this;var

  BlendedItemsComponentQuestionModel = /*#__PURE__*/function (_QuestionModel) {"use strict";_inherits(BlendedItemsComponentQuestionModel, _QuestionModel);var _super42 = _createSuper(BlendedItemsComponentQuestionModel);function BlendedItemsComponentQuestionModel() {_classCallCheck(this, BlendedItemsComponentQuestionModel);return _super42.apply(this, arguments);}_createClass(BlendedItemsComponentQuestionModel, [{ key: "init", value: function init()

      {
        ItemsComponentModel.prototype.init.call(this);
        _get(_getPrototypeOf(BlendedItemsComponentQuestionModel.prototype), "init", this).call(this);
      } }, { key: "reset", value: function reset(

      type, force) {
        ItemsComponentModel.prototype.reset.call(this, type, force);
        _get(_getPrototypeOf(BlendedItemsComponentQuestionModel.prototype), "reset", this).call(this, type, force);
      } }]);return BlendedItemsComponentQuestionModel;}(QuestionModel);


  // extend BlendedItemsComponentQuestionModel with ItemsComponentModel
  Object.getOwnPropertyNames(ItemsComponentModel.prototype).forEach(function (name) {_newArrowCheck(this, _this82);
    if (name === 'constructor' || name === 'init' || name === 'reset') return;
    Object.defineProperty(BlendedItemsComponentQuestionModel.prototype, name, {
      value: ItemsComponentModel.prototype[name] });

  }.bind(this));var

  ItemsQuestionModel = /*#__PURE__*/function (_BlendedItemsComponen) {"use strict";_inherits(ItemsQuestionModel, _BlendedItemsComponen);var _super43 = _createSuper(ItemsQuestionModel);function ItemsQuestionModel() {_classCallCheck(this, ItemsQuestionModel);return _super43.apply(this, arguments);}_createClass(ItemsQuestionModel, [{ key: "init", value: function init()

      {
        _get(_getPrototypeOf(ItemsQuestionModel.prototype), "init", this).call(this);
        this.set('_isRadio', this.isSingleSelect());
        this.listenTo(this.getChildren(), 'change:_isActive', this.checkCanSubmit);
        this.checkCanSubmit();
      } }, { key: "restoreUserAnswers", value: function restoreUserAnswers()

      {var _this83 = this;
        if (!this.get('_isSubmitted')) return;

        var itemModels = this.getChildren();
        var userAnswer = this.get('_userAnswer');
        itemModels.each(function (item) {_newArrowCheck(this, _this83);
          item.toggleActive(userAnswer[item.get('_index')]);
        }.bind(this));

        this.setQuestionAsSubmitted();
        this.markQuestion();
        this.setScore();
        this.setupFeedback();
      } }, { key: "setupRandomisation", value: function setupRandomisation()

      {
        if (!this.get('_isRandom') || !this.get('_isEnabled')) return;
        var children = this.getChildren();
        children.set(children.shuffle());
      }

      // check if the user is allowed to submit the question
    }, { key: "canSubmit", value: function canSubmit() {
        var activeItems = this.getActiveItems();
        return activeItems.length > 0;
      }

      // This is important for returning or showing the users answer
      // This should preserve the state of the users answers
    }, { key: "storeUserAnswer", value: function storeUserAnswer() {var _this84 = this;
        var items = this.getChildren().slice(0);
        items.sort(function (a, b) {_newArrowCheck(this, _this84);return a.get('_index') - b.get('_index');}.bind(this));
        var userAnswer = items.map(function (itemModel) {_newArrowCheck(this, _this84);return itemModel.get('_isActive');}.bind(this));
        this.set('_userAnswer', userAnswer);
      } }, { key: "isCorrect", value: function isCorrect()

      {var _this85 = this;

        var props = {
          _numberOfRequiredAnswers: 0,
          _numberOfIncorrectAnswers: 0,
          _isAtLeastOneCorrectSelection: false,
          _numberOfCorrectAnswers: 0 };


        this.getChildren().each(function (itemModel) {_newArrowCheck(this, _this85);
          var itemShouldBeActive = itemModel.get('_shouldBeSelected');
          if (itemShouldBeActive) {
            props._numberOfRequiredAnswers++;
          }

          if (!itemModel.get('_isActive')) return;

          if (!itemShouldBeActive) {
            props._numberOfIncorrectAnswers++;
            return;
          }

          props._isAtLeastOneCorrectSelection = true;
          props._numberOfCorrectAnswers++;
          itemModel.set('_isCorrect', true);
        }.bind(this));

        this.set(props);

        var hasRightNumberOfCorrectAnswers = props._numberOfCorrectAnswers === props._numberOfRequiredAnswers;
        var hasNoIncorrectAnswers = !props._numberOfIncorrectAnswers;

        return hasRightNumberOfCorrectAnswers && hasNoIncorrectAnswers;
      }

      // Sets the score based upon the questionWeight
      // Can be overwritten if the question needs to set the score in a different way
    }, { key: "setScore", value: function setScore() {
        var questionWeight = this.get('_questionWeight');
        var answeredCorrectly = this.get('_isCorrect');
        var score = answeredCorrectly ? questionWeight : 0;
        this.set('_score', score);
      } }, { key: "setupFeedback", value: function setupFeedback()

      {
        if (!this.has('_feedback')) return;

        if (this.get('_isCorrect')) {
          this.setupCorrectFeedback();
          return;
        }

        if (this.isPartlyCorrect()) {
          this.setupPartlyCorrectFeedback();
          return;
        }

        // apply individual item feedback
        var activeItem = this.getActiveItem();
        if (this.isSingleSelect() && activeItem.get('feedback')) {
          this.setupIndividualFeedback(activeItem);
          return;
        }

        this.setupIncorrectFeedback();
      } }, { key: "setupIndividualFeedback", value: function setupIndividualFeedback(

      selectedItem) {
        this.set({
          feedbackTitle: this.getFeedbackTitle(this.get('_feedback')),
          feedbackMessage: selectedItem.get('feedback') });

      } }, { key: "isPartlyCorrect", value: function isPartlyCorrect()

      {
        return this.get('_isAtLeastOneCorrectSelection');
      } }, { key: "resetUserAnswer", value: function resetUserAnswer()

      {
        this.set('_userAnswer', []);
      } }, { key: "isAtActiveLimit", value: function isAtActiveLimit()

      {
        var selectedItems = this.getActiveItems();
        return selectedItems.length === this.get('_selectable');
      } }, { key: "isSingleSelect", value: function isSingleSelect()

      {
        return this.get('_selectable') === 1;
      } }, { key: "getLastActiveItem", value: function getLastActiveItem()

      {
        var selectedItems = this.getActiveItems();
        return selectedItems[selectedItems.length - 1];
      } }, { key: "resetItems", value: function resetItems()

      {
        this.resetActiveItems();
        this.set('_isAtLeastOneCorrectSelection', false);
      } }, { key: "getInteractionObject", value: function getInteractionObject()

      {var _this86 = this;
        var interactions = {
          correctResponsesPattern: [],
          choices: [] };


        interactions.choices = this.getChildren().map(function (itemModel) {_newArrowCheck(this, _this86);
          return {
            id: (itemModel.get('_index') + 1).toString(),
            description: itemModel.get('text') };

        }.bind(this));

        var correctItems = this.getChildren().filter(function (itemModel) {_newArrowCheck(this, _this86);
          return itemModel.get('_shouldBeSelected');
        }.bind(this));

        interactions.correctResponsesPattern = [
        correctItems.map(function (itemModel) {_newArrowCheck(this, _this86);
          // indexes are 0-based, we need them to be 1-based for cmi.interactions
          return String(itemModel.get('_index') + 1);
        }.bind(this)).join('[,]')];


        return interactions;
      }

      /**
        * used by adapt-contrib-spoor to get the user's answers in the format required by the cmi.interactions.n.student_response data field
        * returns the user's answers as a string in the format '1,5,2'
        */ }, { key: "getResponse", value: function getResponse()
      {var _this87 = this;
        var activeItems = this.getActiveItems();
        var activeIndexes = activeItems.map(function (itemModel) {_newArrowCheck(this, _this87);
          // indexes are 0-based, we need them to be 1-based for cmi.interactions
          return itemModel.get('_index') + 1;
        }.bind(this));
        return activeIndexes.join(',');
      }

      /**
        * used by adapt-contrib-spoor to get the type of this question in the format required by the cmi.interactions.n.type data field
        */ }, { key: "getResponseType", value: function getResponseType()
      {
        return 'choice';
      } }]);return ItemsQuestionModel;}(BlendedItemsComponentQuestionModel);



  return ItemsQuestionModel;

});

define('components/adapt-contrib-mcq/js/adapt-contrib-mcq', [
'core/js/adapt',
'./mcqView',
'core/js/models/itemsQuestionModel'],
function (Adapt, McqView, ItemsQuestionModel) {

  return Adapt.register("mcq", {
    view: McqView,
    // Extend ItemsQuestionModel to distinguish McqModel in
    // the inheritance chain and allow targeted model extensions.
    model: ItemsQuestionModel.extend({}) });


});

define('components/adapt-contrib-gmcq/js/adapt-contrib-gmcq', [
'core/js/adapt',
'components/adapt-contrib-mcq/js/adapt-contrib-mcq'],
function (Adapt, Mcq) {

  var Gmcq = Mcq.view.extend({

    setupQuestion: function setupQuestion() {
      Mcq.view.prototype.setupQuestion.call(this);

      this.listenTo(Adapt, {
        'device:changed': this.resizeImage,
        'device:resize': this.onDeviceResize });


    },

    onQuestionRendered: function onQuestionRendered() {

      this.resizeImage(Adapt.device.screenSize);
      this.setUpColumns();

      this.$('.js-item-label').imageready(this.setReadyStatus.bind(this));

    },

    onDeviceResize: function onDeviceResize() {
      this.setUpColumns();
    },

    resizeImage: function resizeImage(width) {
      var imageWidth = width === 'medium' ? 'small' : width;

      this.$('.js-item-label').each(function (index) {
        var $img = $(this).find('img');
        var newSrc = $img.attr('data-' + imageWidth);
        if (!newSrc) return;
        $img.attr('src', newSrc);
      });

    },

    setUpColumns: function setUpColumns() {
      var columns = this.model.get('_columns');

      if (!columns) return;

      var isLarge = Adapt.device.screenSize === 'large';

      this.$el.toggleClass('has-column-layout', isLarge);
      this.$('.js-mcq-item').css('width', isLarge ? 100 / columns + '%' : '');
    } },

  {
    template: 'gmcq' });


  return Adapt.register("gmcq", {
    view: Gmcq,
    model: Mcq.model.extend({}) });


});

define('components/adapt-contrib-graphic/js/adapt-contrib-graphic', [
'core/js/adapt',
'core/js/views/componentView',
'core/js/models/componentModel'],
function (Adapt, ComponentView, ComponentModel) {var

  GraphicView = /*#__PURE__*/function (_ComponentView5) {"use strict";_inherits(GraphicView, _ComponentView5);var _super44 = _createSuper(GraphicView);function GraphicView() {_classCallCheck(this, GraphicView);return _super44.apply(this, arguments);}_createClass(GraphicView, [{ key: "preRender", value: function preRender()

      {
        this.listenTo(Adapt, 'device:changed', this.resizeImage);

        this.checkIfResetOnRevisit();
      } }, { key: "postRender", value: function postRender()

      {
        this.resizeImage(Adapt.device.screenSize, true);
      } }, { key: "checkIfResetOnRevisit", value: function checkIfResetOnRevisit()

      {
        var isResetOnRevisit = this.model.get('_isResetOnRevisit');

        if (isResetOnRevisit) {
          this.model.reset(isResetOnRevisit);
        }
      } }, { key: "resizeImage", value: function resizeImage(

      width, setupInView) {var _this88 = this;
        var imageWidth = width === 'medium' ? 'small' : width;
        var imageSrc = this.model.get('_graphic') ? this.model.get('_graphic')[imageWidth] : '';
        this.$('.js-graphic-set-image-src').attr('src', imageSrc);

        this.$('.graphic__widget').imageready(function () {_newArrowCheck(this, _this88);
          this.setReadyStatus();

          if (setupInView) {
            this.setupInviewCompletion('.graphic__widget');
          }
        }.bind(this));
      } }]);return GraphicView;}(ComponentView);


  GraphicView.template = 'graphic';

  return Adapt.register('graphic', {
    model: ComponentModel.extend({}), // create a new class in the inheritance chain so it can be extended per component type if necessary later
    view: GraphicView });


});

define('components/adapt-contrib-hotgraphic/js/hotgraphicPopupView', [
'core/js/adapt'],
function (Adapt) {var

  HotgraphicPopupView = /*#__PURE__*/function (_Backbone$View4) {"use strict";_inherits(HotgraphicPopupView, _Backbone$View4);var _super45 = _createSuper(HotgraphicPopupView);function HotgraphicPopupView() {_classCallCheck(this, HotgraphicPopupView);return _super45.apply(this, arguments);}_createClass(HotgraphicPopupView, [{ key: "className", value: function className()

      {
        return 'hotgraphic-popup';
      } }, { key: "events", value: function events()

      {
        return {
          'click .js-hotgraphic-popup-close': 'closePopup',
          'click .js-hotgraphic-controls-click': 'onControlClick' };

      } }, { key: "initialize", value: function initialize()

      {var _get5;for (var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++) {args[_key17] = arguments[_key17];}
        (_get5 = _get(_getPrototypeOf(HotgraphicPopupView.prototype), "initialize", this)).call.apply(_get5, [this].concat(args));
        // Debounce required as a second (bad) click event is dispatched on iOS causing a jump of two items.
        this.onControlClick = _.debounce(this.onControlClick.bind(this), 100);
        this.listenToOnce(Adapt, 'notify:opened', this.onOpened);
        this.listenTo(this.model.get('_children'), {
          'change:_isActive': this.onItemsActiveChange,
          'change:_isVisited': this.onItemsVisitedChange });

        this.render();
      } }, { key: "onOpened", value: function onOpened()

      {
        this.applyNavigationClasses(this.model.getActiveItem().get('_index'));
        this.updatePageCount();
        this.handleTabs();
      } }, { key: "applyNavigationClasses", value: function applyNavigationClasses(

      index) {
        var itemCount = this.model.get('_items').length;
        var canCycleThroughPagination = this.model.get('_canCycleThroughPagination');

        var shouldEnableBack = index > 0 || canCycleThroughPagination;
        var shouldEnableNext = index < itemCount - 1 || canCycleThroughPagination;
        var $controls = this.$('.hotgraphic-popup__controls');

        this.$('hotgraphic-popup__nav').
        toggleClass('first', !shouldEnableBack).
        toggleClass('last', !shouldEnableNext);

        Adapt.a11y.toggleAccessibleEnabled($controls.filter('.back'), shouldEnableBack);
        Adapt.a11y.toggleAccessibleEnabled($controls.filter('.next'), shouldEnableNext);
      } }, { key: "updatePageCount", value: function updatePageCount()

      {
        var template = Adapt.course.get('_globals')._components._hotgraphic.popupPagination || '{{itemNumber}} / {{totalItems}}';
        var labelText = Handlebars.compile(template)({
          itemNumber: this.model.getActiveItem().get('_index') + 1,
          totalItems: this.model.get('_items').length });

        this.$('.hotgraphic-popup__count').html(labelText);
      } }, { key: "handleTabs", value: function handleTabs()

      {
        Adapt.a11y.toggleHidden(this.$('.hotgraphic-popup__item:not(.is-active) *'), true);
        Adapt.a11y.toggleHidden(this.$('.hotgraphic-popup__item.is-active *'), false);
      } }, { key: "onItemsActiveChange", value: function onItemsActiveChange(

      item, _isActive) {
        if (!_isActive) return;
        var index = item.get('_index');
        this.updatePageCount();
        this.applyItemClasses(index);
        this.handleTabs();
        this.handleFocus(index);
      } }, { key: "applyItemClasses", value: function applyItemClasses(

      index) {
        this.$(".hotgraphic-popup__item[data-index=\"".concat(index, "\"]")).addClass('is-active').removeAttr('aria-hidden');
        this.$(".hotgraphic-popup__item[data-index=\"".concat(index, "\"] .hotgraphic-popup__item-title")).attr('id', 'notify-heading');
        this.$(".hotgraphic-popup__item:not([data-index=\"".concat(index, "\"])")).removeClass('is-active').attr('aria-hidden', 'true');
        this.$(".hotgraphic-popup__item:not([data-index=\"".concat(index, "\"]) .hotgraphic-popup__item-title")).removeAttr('id');
      } }, { key: "handleFocus", value: function handleFocus(

      index) {
        Adapt.a11y.focusFirst(this.$('.hotgraphic-popup__inner .is-active'));
        this.applyNavigationClasses(index);
      } }, { key: "onItemsVisitedChange", value: function onItemsVisitedChange(

      item, _isVisited) {
        if (!_isVisited) return;

        this.$('.hotgraphic-popup__item').
        filter("[data-index=\"".concat(item.get('_index'), "\"]")).
        addClass('is-visited');
      } }, { key: "render", value: function render()

      {
        var data = this.model.toJSON();
        data.view = this;
        var template = Handlebars.templates[this.constructor.template];
        this.$el.html(template(data));
      } }, { key: "closePopup", value: function closePopup()

      {
        Adapt.trigger('notify:close');
      } }, { key: "onControlClick", value: function onControlClick(

      event) {
        var direction = $(event.currentTarget).data('direction');
        var index = this.getNextIndex(direction);
        if (index === -1) return;

        this.setItemState(index);
      } }, { key: "getNextIndex", value: function getNextIndex(

      direction) {
        var index = this.model.getActiveItem().get('_index');
        var lastIndex = this.model.get('_items').length - 1;

        switch (direction) {
          case 'back':
            if (index > 0) return --index;
            if (this.model.get('_canCycleThroughPagination')) return lastIndex;
            break;
          case 'next':
            if (index < lastIndex) return ++index;
            if (this.model.get('_canCycleThroughPagination')) return 0;}

        return -1;
      } }, { key: "setItemState", value: function setItemState(

      index) {
        this.model.getActiveItem().toggleActive();

        var nextItem = this.model.getItem(index);
        nextItem.toggleActive();
        nextItem.toggleVisited(true);
      } }]);return HotgraphicPopupView;}(Backbone.View);

  ;

  HotgraphicPopupView.template = 'hotgraphicPopup';

  return HotgraphicPopupView;

});

define('components/adapt-contrib-hotgraphic/js/hotgraphicView', [
'core/js/adapt',
'core/js/views/componentView',
'./hotgraphicPopupView'],
function (Adapt, ComponentView, HotgraphicPopupView) {var

  HotGraphicView = /*#__PURE__*/function (_ComponentView6) {"use strict";_inherits(HotGraphicView, _ComponentView6);var _super46 = _createSuper(HotGraphicView);function HotGraphicView() {_classCallCheck(this, HotGraphicView);return _super46.apply(this, arguments);}_createClass(HotGraphicView, [{ key: "events", value: function events()

      {
        return {
          'click .js-hotgraphic-item-click': 'onPinClicked' };

      } }, { key: "initialize", value: function initialize()

      {var _get6;for (var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {args[_key18] = arguments[_key18];}
        (_get6 = _get(_getPrototypeOf(HotGraphicView.prototype), "initialize", this)).call.apply(_get6, [this].concat(args));

        this.setUpViewData();
        this.setUpModelData();
        this.setUpEventListeners();
        this.checkIfResetOnRevisit();
      } }, { key: "setUpViewData", value: function setUpViewData()

      {
        this.popupView = null;
        this._isPopupOpen = false;
      } }, { key: "setUpModelData", value: function setUpModelData()

      {
        if (this.model.get('_canCycleThroughPagination') === undefined) {
          this.model.set('_canCycleThroughPagination', false);
        }
      } }, { key: "setUpEventListeners", value: function setUpEventListeners()

      {
        this.listenTo(Adapt, 'device:changed', this.reRender);

        this.listenTo(this.model.get('_children'), {
          'change:_isActive': this.onItemsActiveChange,
          'change:_isVisited': this.onItemsVisitedChange });

      } }, { key: "reRender", value: function reRender()

      {
        if (Adapt.device.screenSize === 'large' || this.model.get('_isNarrativeOnMobile') === false) return;

        this.replaceWithNarrative();
      } }, { key: "replaceWithNarrative", value: function replaceWithNarrative()

      {var _this89 = this;
        var NarrativeView = Adapt.getViewClass('narrative');
        if (!NarrativeView) return;

        var model = this.prepareNarrativeModel();
        var newNarrative = new NarrativeView({ model: model });
        // NOTE: if this component is doing its inital render in 'narrative mode',
        // this.$el.parents() won't exist at this point - which is why the following is
        // written the way it is, instead of (what would appear to be) the more efficient
        // this.$el.parents('.component__container')
        var $container = Adapt.findViewByModelId(model.get('_parentId')).$el.find('.component__container');
        $container.append(newNarrative.$el);

        this.remove();
        _.defer(function () {_newArrowCheck(this, _this89);
          Adapt.trigger('device:resize');
        }.bind(this));
      } }, { key: "prepareNarrativeModel", value: function prepareNarrativeModel()

      {
        this.model.set({
          _component: 'narrative',
          _wasHotgraphic: true,
          originalBody: this.model.get('body'),
          originalInstruction: this.model.get('instruction') });


        // Check if active item exists, default to 0
        var activeItem = this.model.getActiveItem();
        if (!activeItem) {
          this.model.getItem(0).toggleActive(true);
        }

        // Swap mobile body and instructions for desktop variants.
        if (this.model.get('mobileBody')) {
          this.model.set('body', this.model.get('mobileBody'));
        }
        if (this.model.get('mobileInstruction')) {
          this.model.set('instruction', this.model.get('mobileInstruction'));
        }

        return this.model;
      } }, { key: "onItemsActiveChange", value: function onItemsActiveChange(

      model, _isActive) {
        this.getItemElement(model).toggleClass('is-active', _isActive);
      } }, { key: "getItemElement", value: function getItemElement(

      model) {
        var index = model.get('_index');
        return this.$('.js-hotgraphic-item-click').filter("[data-index=\"".concat(index, "\"]"));
      } }, { key: "onItemsVisitedChange", value: function onItemsVisitedChange(

      model, _isVisited) {
        if (!_isVisited) return;

        var $pin = this.getItemElement(model);
        // Append the word 'visited.' to the pin's aria-label
        var visitedLabel = " ".concat(this.model.get('_globals')._accessibility._ariaLabels.visited, ".");
        $pin.find('.aria-label').each(function (index, el) {
          el.innerHTML += visitedLabel;
        });

        $pin.addClass('is-visited');
      } }, { key: "checkIfResetOnRevisit", value: function checkIfResetOnRevisit()

      {
        var isResetOnRevisit = this.model.get('_isResetOnRevisit');

        // If reset is enabled set defaults
        if (isResetOnRevisit) {
          this.model.reset(isResetOnRevisit);
        }
      } }, { key: "preRender", value: function preRender()

      {
        if (Adapt.device.screenSize === 'large') {
          this.render();
          return;
        }

        this.reRender();
      } }, { key: "postRender", value: function postRender()

      {
        this.$('.hotgraphic__widget').imageready(this.setReadyStatus.bind(this));
        if (this.model.get('_setCompletionOn') === 'inview') {
          this.setupInviewCompletion('.component__widget');
        }
      } }, { key: "onPinClicked", value: function onPinClicked(

      event) {
        var item = this.model.getItem($(event.currentTarget).data('index'));
        item.toggleActive(true);
        item.toggleVisited(true);

        this.openPopup();
      } }, { key: "openPopup", value: function openPopup()

      {
        if (this._isPopupOpen) return;

        this._isPopupOpen = true;

        this.popupView = new HotgraphicPopupView({
          model: this.model });


        Adapt.notify.popup({
          _view: this.popupView,
          _isCancellable: true,
          _showCloseButton: false,
          _classes: 'hotgraphic ' + this.model.get('_classes') });


        this.listenToOnce(Adapt, {
          'popup:closed': this.onPopupClosed });

      } }, { key: "onPopupClosed", value: function onPopupClosed()

      {
        this.model.getActiveItem().toggleActive();
        this._isPopupOpen = false;
      } }]);return HotGraphicView;}(ComponentView);



  HotGraphicView.template = 'hotgraphic';

  return HotGraphicView;

});

define('components/adapt-contrib-hotgraphic/js/adapt-contrib-hotgraphic', [
'core/js/adapt',
'./hotgraphicView',
'core/js/models/itemsComponentModel'],
function (Adapt, HotgraphicView, ItemsComponentModel) {

  return Adapt.register('hotgraphic', {
    model: ItemsComponentModel.extend({}),
    view: HotgraphicView });


});

define('components/adapt-contrib-matching/js/dropdownOption', [], function () {

  var DropDownItem = Backbone.View.extend({

    events: {
      'click': 'onClick',
      'click *': 'onClick' },


    initialize: function initialize(settings) {
      this.settings = settings;
      this.$inner = this.$('.js-dropdown-list-item-inner');
    },

    isPlaceholder: function isPlaceholder() {
      return this.$el.is('[hidden]');
    },

    parent: function parent() {
      return this.settings.parent;
    },

    onClick: function onClick(event) {
      var parent = this.parent();
      event.preventDefault();
      this.select().scrollTo();
      parent.$button.focus();
    },

    getValue: function getValue() {
      return this.$el.attr('value').trim();
    },

    select: function select() {
      var parent = this.parent();
      parent.deselectAll();
      parent.setActiveDescendantId(this.el.id);
      this.$el.attr({
        selected: '',
        'aria-selected': 'true' });

      parent.$inner.html(this.$el.attr('text'));
      var value = this.isPlaceholder() ? '' : this.getValue();
      parent.$input.val(value).trigger('change');
      parent.trigger('change', parent);
      return this;
    },

    deselect: function deselect() {
      if (!this.isSelected()) return this;
      var parent = this.parent();
      parent.removeActiveDescendantId();
      this.$el.removeAttr('selected');
      this.$el.attr('aria-selected', 'false');
      parent.$inner.html('');
      parent.$input.val('').trigger('change');
      parent.trigger('change', parent);
      return this;
    },

    reselect: function reselect() {
      var parent = this.parent();
      parent.setActiveDescendantId(this.$el[0].id);
      if (this.isSelected()) return this;
      this.select();
      return this;
    },

    isSelected: function isSelected() {
      return Boolean(this.$el.attr('selected'));
    },

    getIndex: function getIndex() {
      var parent = this.parent();
      return _.findIndex(parent.options, function (option) {
        return option === this;
      }.bind(this));
    },

    getNext: function getNext() {
      var parent = this.parent();
      return parent.options[this.getIndex() + 1];
    },

    getPrevious: function getPrevious() {
      var parent = this.parent();
      return parent.options[this.getIndex() - 1];
    },

    getFirst: function getFirst() {
      var parent = this.parent();
      return parent.options[0];
    },

    getLast: function getLast() {
      var parent = this.parent();
      return parent.options[parent.options.length - 1];
    },

    scrollTo: function scrollTo() {
      var parent = this.parent();
      parent.settings.scrollToItem.call(parent, this);
    },

    destroy: function destroy() {
      var parent = this.parent();
      this.remove();
      if (this.isPlaceholder()) {
        parent.placeholder = null;
      } else {
        for (var i = 0, l = parent.options.length; i < l; i++) {
          var item = parent.options[i];
          if (item !== this) continue;
          parent.options.splice(i, 1);
          break;
        }
      }
      delete this.settings;
    } });



  return DropDownItem;

});

define('components/adapt-contrib-matching/js/dropdown', [
'./dropdownOption'],
function (DropDownOption) {

  var DropDown = Backbone.View.extend({

    initialize: function initialize(settings) {
      _.bindAll(this, 'onStartInteraction', 'onButtonClick', 'onListBlur', 'onKeyDown');
      this.settings = _.defaults(settings, this.getDefaults());
      this.placeholder = null;
      this.options = [];
      this.setUpElements();
      this.setUpItems();
      this.select(this.settings.value);
      this.addEventListeners();
      this.toggleOpen(false);
      this.settings.load.call(this, this);
      this.trigger('load', this);
    },

    getDefaults: function getDefaults() {
      return {
        load: DropDown.defaults.load,
        openList: DropDown.defaults.openList,
        closeList: DropDown.defaults.closeList,
        scrollToItem: DropDown.defaults.scrollToItem };

    },

    setUpElements: function setUpElements() {
      this.$list = this.$('.js-dropdown-list');
      this.$button = this.$('.js-dropdown-btn');
      this.$inner = this.$button.find('.js-dropdown-inner');
      this.$input = this.$('.js-data-output');
    },

    setUpItems: function setUpItems() {
      var $options = this.$('.js-dropdown-list-item');
      $options.each(function (index, el) {
        var option = new DropDownOption({
          parent: this,
          el: el });

        if (option.isPlaceholder()) {
          this.placeholder = option;
          return;
        }
        this.options.push(option);
      }.bind(this));
    },

    addEventListeners: function addEventListeners() {
      this.$button.on({
        'mousedown touchstart': this.onStartInteraction,
        click: this.onButtonClick });

      this.$list.on('blur', this.onListBlur);
      $(document).on('keydown', this.onKeyDown);
    },

    onStartInteraction: function onStartInteraction() {
      this.wasOpen = this.isOpen();
    },

    deselectAll: function deselectAll() {
      this.placeholder.deselect();
      this.options.forEach(function (option) {
        option.deselect();
      });
    },

    onButtonClick: function onButtonClick(event) {
      if (this.wasOpen || this.isOpen()) {
        // click toggle list:
        // if the list is open and the button is clicked
        // the blur event will fire first closing the list.
        // this code is to prevent the list from reopening
        // in that situation
        this.wasOpen = false;
        return;
      }
      this.toggleOpen();
      var option = this.getFirstSelectedItem() || this.placeholder;
      if (!option) return;
      option.reselect();
      option.scrollTo();
      this.$list.focus();
    },

    isOpen: function isOpen() {
      return !this.$list.hasClass('u-display-none');
    },

    toggleOpen: function toggleOpen(open) {
      if (open === undefined) open = !this.isOpen();
      if (open) clearTimeout(this.blurTimeout);
      this.$button.attr('aria-expanded', open ? 'true' : 'false');
      var name = open ? 'openList' : 'closeList';
      this.settings[name].call(this, this);
      this.trigger(name, this);
    },

    onListBlur: function onListBlur(event) {
      // IE11: Allow option click handler to execute before blur and close list
      var handleBlur = function () {
        this.toggleOpen(false);
        this.removeActiveDescendantId();
      }.bind(this);
      this.blurTimeout = setTimeout(handleBlur, 100);
    },

    onKeyDown: function onKeyDown(event) {
      if (!this.isOpen()) return;
      var option = this.getFirstSelectedItem() || this.placeholder;
      switch (event.keyCode) {
        case 38: // UP
          event.preventDefault();
          option = option.getPrevious() || option.getLast();
          break;
        case 40: // DOWN
          event.preventDefault();
          option = option.getNext() || option.getFirst();
          break;
        case 13: // ENTER
        case 32: // SPACE
        case 27: // ESCAPE
          event.preventDefault();
          this.$button.focus();
          return;
        default:
          return;}

      option.select().scrollTo();
    },

    getFirstSelectedItem: function getFirstSelectedItem() {
      return _.find(this.options, function (option) {
        return option.isSelected();
      });
    },

    setActiveDescendantId: function setActiveDescendantId(id) {
      this.$list.attr('aria-activedescendant', id);
    },

    removeActiveDescendantId: function removeActiveDescendantId() {
      this.$list.removeAttr('aria-activedescendant');
    },

    select: function select(value) {
      value = String(value);
      var option = _.find(this.options, function (option) {
        return option.getValue() === value;
      });
      if (option) {
        option.select();
        return;
      }
      this.placeholder.select();
    },

    toggleDisabled: function toggleDisabled(value) {
      if (value === undefined) {
        value = !this.$input.attr('disabled');
      }
      if (value === false) {
        this.$input.removeAttr('disabled');
        this.$button.
        removeAttr('disabled').
        removeClass('is-disabled');
        this.$el.removeAttr('disabled');
        return;
      }
      this.$input.attr('disabled', '');
      this.$button.
      attr('disabled', '').
      addClass('is-disabled');
      this.$el.attr('disabled', '');
    },

    isEmpty: function isEmpty() {
      return !this.getFirstSelectedItem();
    },

    val: function val() {
      return this.$input.val();
    },

    destroy: function destroy() {
      this.removeEventListeners();
      this.$el.remove();
      delete this.options;
      delete this.$input;
      delete this.$inner;
      delete this.$button;
      delete this.$list;
      delete this.$el;
    },

    removeEventListeners: function removeEventListeners() {
      this.$button.off({
        'mousedown touchstart': this.onStartInteraction,
        click: this.onButtonClick });

      this.$list.off('blur', this.onListBlur);
      $(document).off('keydown', this.onKeyDown);
    } },

  {

    defaults: {

      load: function load() {},

      openList: function openList() {
        this.$list.
        css({
          top: '',
          left: this.$button[0].offsetLeft,
          width: this.$button.outerWidth() }).

        addClass('u-visibility-hidden').
        removeClass('u-display-none');

        var offset = this.$list[0].getBoundingClientRect();
        var height = this.$list.height();
        var windowHeight = $(window).height();
        var isOffscreen = offset.top + height > windowHeight;

        this.$list.
        css('top', isOffscreen ? -height : '').
        removeClass('u-visibility-hidden').
        focus();

      },

      closeList: function closeList() {
        this.$list.
        removeClass('u-visibility-hidden').
        addClass('u-display-none').
        css('top', '');
      },

      scrollToItem: function scrollToItem(option) {
        var height = this.$list[0].clientHeight;
        var pos = option.$el[0].offsetTop - height / 2;
        this.$list[0].scrollTop = pos;
      } } });





  return DropDown;

});

define('components/adapt-contrib-matching/js/matchingView', [
'core/js/adapt',
'core/js/views/questionView',
'./dropdown'],
function (Adapt, QuestionView, DropDown) {

  var MatchingView = QuestionView.extend({

    dropdowns: null,

    disableQuestion: function disableQuestion() {
      this.dropdowns.forEach(function (dropdown) {
        dropdown.toggleDisabled(true);
      });
    },

    enableQuestion: function enableQuestion() {
      this.dropdowns.forEach(function (dropdown) {
        dropdown.toggleDisabled(false);
      });
    },

    resetQuestionOnRevisit: function resetQuestionOnRevisit() {
      this.resetQuestion();
    },

    setupQuestion: function setupQuestion() {
      this.listenToOnce(Adapt.parentView, 'postRemove', this.onPostRemove);
      this.model.setupRandomisation();
    },

    onPostRemove: function onPostRemove() {
      this.dropdowns.forEach(function (dropdown) {
        dropdown.off('change', this.onOptionSelected);
        dropdown.destroy();
      }, this);
    },

    onQuestionRendered: function onQuestionRendered() {
      this.setReadyStatus();
      this.setUpDropdowns();
    },

    setUpDropdowns: function setUpDropdowns() {
      _.bindAll(this, 'onOptionSelected');
      this.dropdowns = [];
      var items = this.model.get('_items');
      this.$('.matching__item').each(function (i, el) {
        var item = items[i];
        var selectedOption = _.find(item._options, function (option) {
          return option._isSelected;
        });
        var value = selectedOption ? selectedOption._index : null;
        var dropdown = new DropDown({
          el: $(el).find('.dropdown')[0],
          placeholder: this.model.get('placeholder'),
          value: value });

        this.dropdowns.push(dropdown);
        dropdown.on('change', this.onOptionSelected);
      }.bind(this));
      this.enableQuestion();
      if (this.model.get('_isEnabled') !== true) {
        this.disableQuestion();
      }
    },

    onCannotSubmit: function onCannotSubmit() {
      this.dropdowns.forEach(function (dropdown) {
        if (!dropdown.isEmpty()) return;
        dropdown.$el.parents('.matching__select-container').addClass('has-error');
      });
    },

    onOptionSelected: function onOptionSelected(dropdown) {
      if (this.model.get('_isInteractionComplete')) return;
      var $container = dropdown.$el.parents('.matching__select-container');
      $container.removeClass('error');
      var itemIndex = dropdown.$el.parents('.matching__item').index();
      if (dropdown.isEmpty()) return;
      var optionIndex = parseInt(dropdown.val());
      this.model.setOptionSelected(itemIndex, optionIndex, true);
    },

    showMarking: function showMarking() {
      if (!this.model.get('_canShowMarking')) return;

      this.model.get('_items').forEach(function (item, i) {
        var $item = this.$('.matching__item').eq(i);
        $item.removeClass('is-correct is-incorrect').addClass(item._isCorrect ? 'is-correct' : 'is-incorrect');
      }, this);
    },

    resetQuestion: function resetQuestion() {
      this.$('.matching__item').removeClass('is-correct is-incorrect');
      this.model.set('_isAtLeastOneCorrectSelection', false);
      var resetAll = this.model.get('_shouldResetAllAnswers');

      this.model.get('_items').forEach(function (item, index) {
        if (item._isCorrect && resetAll === false) return;
        this.selectValue(index, null);
        item._options.forEach(function (option, index) {
          option._isSelected = false;
        });
        item._selected = null;
      }, this);
    },

    showCorrectAnswer: function showCorrectAnswer() {
      this.model.get('_items').forEach(function (item, index) {
        var correctOption = _.findWhere(item._options, { _isCorrect: true });
        this.selectValue(index, correctOption._index);
      }, this);
    },

    hideCorrectAnswer: function hideCorrectAnswer() {
      var answerArray = this.model.has('_tempUserAnswer') ?
      this.model.get('_tempUserAnswer') :
      this.model.get('_userAnswer');

      this.model.get('_items').forEach(function (item, index) {
        var key = answerArray[index];
        var value = item._options[key]._index;
        this.selectValue(index, value);
      }, this);
    },

    /**
        * Sets the selected item of a dropdown
        * @param {number} index The index (0-based) of the dropdown
        * @param {string} value The option _index
        * @example
        * // Sets the third dropdown to option _index 1
        * this.selectValue(2, 1);
        */
    selectValue: function selectValue(index, optionIndex) {
      if (!this.dropdowns) return;
      var dropdown = this.dropdowns[index];
      if (!dropdown) return;
      dropdown.select(optionIndex);
    } });



  return MatchingView;
});

define('components/adapt-contrib-matching/js/matchingModel', [
'core/js/models/questionModel'],
function (QuestionModel) {

  var MatchingModel = QuestionModel.extend({

    init: function init() {
      QuestionModel.prototype.init.call(this);

      this.setupQuestionItemIndexes();
    },

    setupQuestionItemIndexes: function setupQuestionItemIndexes() {

      this.get('_items').forEach(function (item, index) {
        if (item._index === undefined) {
          item._index = index;
          item._selected = false;
        }
        item._options.forEach(function (option, index) {
          if (option._index === undefined) {
            option._index = index;
            option._isSelected = false;
          }
        });
      });
    },

    setupRandomisation: function setupRandomisation() {
      if (!this.get('_isRandom') || !this.get('_isEnabled')) return;

      this.get('_items').forEach(function (item) {
        item._options = _.shuffle(item._options);
      });
    },

    restoreUserAnswers: function restoreUserAnswers() {
      if (!this.get('_isSubmitted')) return;

      var userAnswer = this.get('_userAnswer');

      this.get('_items').forEach(function (item, index) {
        item._options.forEach(function (option, index) {
          if (option._index === userAnswer[item._index]) {
            option._isSelected = true;
            item._selected = option;
          }
        });
      });

      this.setQuestionAsSubmitted();
      this.checkCanSubmit();
      this.markQuestion();
      this.setScore();
      this.setupFeedback();
    },

    canSubmit: function canSubmit() {
      // can submit if every item has a selection
      var canSubmit = _.every(this.get('_items'), function (item) {
        return _.findWhere(item._options, { '_isSelected': true }) !== undefined;
      });

      return canSubmit;
    },

    setOptionSelected: function setOptionSelected(itemIndex, optionIndex, isSelected) {
      var item = this.get('_items')[itemIndex];
      var option = _.findWhere(item._options, { '_index': optionIndex });
      option._isSelected = isSelected;
      item._selected = option;
      this.checkCanSubmit();
    },

    storeUserAnswer: function storeUserAnswer() {

      var userAnswer = new Array(this.get('_items').length);
      var tempUserAnswer = new Array(this.get('_items').length);

      this.get('_items').forEach(function (item, index) {
        var optionIndex = _.findIndex(item._options, function (o) {return o._isSelected;});

        tempUserAnswer[item._index] = optionIndex;
        userAnswer[item._index] = item._options[optionIndex]._index;
      }, this);

      this.set({
        _userAnswer: userAnswer,
        _tempUserAnswer: tempUserAnswer });

    },

    isCorrect: function isCorrect() {
      var numberOfCorrectAnswers = 0;

      this.get('_items').forEach(function (item, index) {

        var isCorrect = item._selected && item._selected._isCorrect;

        if (!isCorrect) {
          item._isCorrect = false;
          return;
        }

        numberOfCorrectAnswers++;
        item._isCorrect = true;
        this.set({
          _numberOfCorrectAnswers: numberOfCorrectAnswers,
          _isAtLeastOneCorrectSelection: true });


      }, this);

      this.set('_numberOfCorrectAnswers', numberOfCorrectAnswers);

      if (numberOfCorrectAnswers === this.get('_items').length) {
        return true;
      }

      return false;
    },

    setScore: function setScore() {
      var questionWeight = this.get('_questionWeight');

      if (this.get('_isCorrect')) {
        this.set('_score', questionWeight);
        return;
      }

      var numberOfCorrectAnswers = this.get('_numberOfCorrectAnswers');
      var itemLength = this.get('_items').length;

      var score = questionWeight * numberOfCorrectAnswers / itemLength;

      this.set('_score', score);
    },

    isPartlyCorrect: function isPartlyCorrect() {
      return this.get('_isAtLeastOneCorrectSelection');
    },

    resetUserAnswer: function resetUserAnswer() {
      this.set('_userAnswer', []);
    },

    /**
       * Used by tracking extensions to return an object containing the component's specific interactions.
       */
    getInteractionObject: function getInteractionObject() {
      var interactions = {
        correctResponsesPattern: null,
        source: null,
        target: null };

      var items = this.get('_items');
      // This contains an array with a single string value, matching the source 'id' with the correct
      // matching target 'id' value. An example is as follows:
      // [ "1[.]1_2[,]2[.]2_3" ]
      interactions.correctResponsesPattern = [
      items.map(function (item, questionIndex) {
        // Offset the item index and use it as a group identifier.
        questionIndex = questionIndex + 1;
        return [
        questionIndex,
        item._options.filter(function (item) {
          // Get the correct item(s).
          return item._isCorrect;
        }).map(function (item) {
          // Prefix the option's index and offset by 1.
          return questionIndex + '_' + (item._index + 1).toString();
        })].
        join('[.]');
      }).join('[,]')];

      // The 'source' property contains an array of all the stems/questions, e.g.
      // [{id: "1", description: "First question"}, {id: "2", description: "Second question"}]
      interactions.source = _.flatten(items.map(function (item) {
        return {
          // Offset by 1.
          id: (item._index + 1).toString(),
          description: item.text };

      }));
      // The 'target' property contains an array of all the option responses, with the 'id'
      // prefixed to indicate the grouping, e.g.
      // [  {id: "1_1": description: "First option, group 1"},
      //    {id: "1_2": description: "Second option, group 1"}
      //    {id: "2_1": description: "First option, group 2"}  ]
      interactions.target = _.flatten(items.map(function (item, index) {
        // Offset by 1, as these values are not zero-indexed.
        index = index + 1;
        return item._options.map(function (option) {
          return {
            id: index + '_' + (option._index + 1),
            description: option.text };

        });
      }));
      return interactions;
    },

    /**
       * Used by adapt-contrib-spoor to get the user's answers in the format required by the cmi.interactions.n.student_response data field
       * @return {string} the user's answers as a string in the format "1.1#2.3#3.2" assuming user selected option 1 in drop-down 1,
       * option 3 in drop-down 2 and option 2 in drop-down 3. The '#' character will be changed to either ',' or '[,]' by adapt-contrib-spoor,
       * depending on which SCORM version is being used.
       */
    getResponse: function getResponse() {
      var responses = [];

      this.get('_userAnswer').forEach(function (userAnswer, index) {
        responses.push(index + 1 + '.' + (userAnswer + 1)); // convert from 0-based to 1-based counting
      });

      return responses.join('#');
    },

    /**
       * Used by adapt-contrib-spoor to get the type of this question in the format required by the cmi.interactions.n.type data field
       * @return {string}
       */
    getResponseType: function getResponseType() {
      return 'matching';
    } });


  return MatchingModel;
});

define('components/adapt-contrib-matching/js/adapt-contrib-matching', [
'core/js/adapt',
'./matchingView',
'./matchingModel'],
function (Adapt, MatchingView, MatchingModel) {

  return Adapt.register('matching', {
    view: MatchingView,
    model: MatchingModel });


});

define('components/adapt-contrib-media/js/adapt-contrib-media', [
'core/js/adapt',
'core/js/views/componentView',
'core/js/models/componentModel',
'libraries/mediaelement-and-player',
'libraries/mediaelement-fullscreen-hook'],
function (Adapt, ComponentView, ComponentModel) {

  var froogaloopAdded = false;

  // The following function is used to to prevent a memory leak in Internet Explorer
  // See: http://javascript.crockford.com/memory/leak.html
  function purge(d) {
    var a = d.attributes,i,l,n;
    if (a) {
      for (i = a.length - 1; i >= 0; i -= 1) {
        n = a[i].name;
        if (typeof d[n] === 'function') {
          d[n] = null;
        }
      }
    }
    a = d.childNodes;
    if (a) {
      l = a.length;
      for (i = 0; i < l; i += 1) {
        purge(d.childNodes[i]);
      }
    }
  }

  /*
     * Default shortcut keys trap a screen reader user inside the player once in focus. These keys are unnecessary
     * as one may traverse the player in a linear fashion without needing to know or use shortcut keys. Below is
     * the removal of the default shortcut keys.
     *
     * The default seek interval functions are passed two different data types from mejs which they handle incorrectly. One
     * is a duration integer the other is the player object. The default functions error on slider key press and so break
     * accessibility. Below is a correction.
     */
  _.extend(mejs.MepDefaults, {
    keyActions: [],
    defaultSeekForwardInterval: function defaultSeekForwardInterval(duration) {
      if (_typeof(duration) === "object") return duration.duration * 0.05;
      return duration * 0.05;
    },
    defaultSeekBackwardInterval: function defaultSeekBackwardInterval(duration) {
      if (_typeof(duration) === "object") return duration.duration * 0.05;
      return duration * 0.05;
    } });


  var MediaView = ComponentView.extend({

    events: {
      "click .js-media-inline-transcript-toggle": "onToggleInlineTranscript",
      "click .js-media-external-transcript-click": "onExternalTranscriptClicked",
      "click .js-skip-to-transcript": "onSkipToTranscript" },


    className: function className() {
      var classes = ComponentView.prototype.className.call(this);
      var playerOptions = this.model.get('_playerOptions');
      if (playerOptions && playerOptions.toggleCaptionsButtonWhenOnlyOne) {
        classes += " toggle-captions";
      }
      return classes;
    },

    preRender: function preRender() {
      this.listenTo(Adapt, {
        'device:resize': this.onScreenSizeChanged,
        'device:changed': this.onDeviceChanged,
        'media:stop': this.onMediaStop });


      _.bindAll(this, 'onMediaElementPlay', 'onMediaElementPause', 'onMediaElementEnded', 'onMediaElementTimeUpdate', 'onMediaElementSeeking');

      // set initial player state attributes
      this.model.set({
        '_isMediaEnded': false,
        '_isMediaPlaying': false });


      if (this.model.get('_media').source) {
        var media = this.model.get('_media');

        // Avoid loading of Mixed Content (insecure content on a secure page)
        if (window.location.protocol === 'https:' && media.source.indexOf('http:') === 0) {
          media.source = media.source.replace(/^http\:/, 'https:');
        }

        this.model.set('_media', media);
      }

      this.checkIfResetOnRevisit();
    },

    postRender: function postRender() {
      this.setupPlayer();
      this.addMejsButtonClass();
    },

    addMejsButtonClass: function addMejsButtonClass() {
      this.$('.mejs-overlay-button').addClass('icon');
    },

    setupPlayer: function setupPlayer() {
      if (!this.model.get('_playerOptions')) this.model.set('_playerOptions', {});

      var modelOptions = this.model.get('_playerOptions');

      if (modelOptions.pluginPath === undefined) {
        // on the off-chance anyone still needs to use the Flash-based player...
        _.extend(modelOptions, {
          pluginPath: 'https://cdnjs.cloudflare.com/ajax/libs/mediaelement/2.21.2/',
          flashName: 'flashmediaelement-cdn.swf',
          flashScriptAccess: 'always' });

      }

      if (modelOptions.features === undefined) {
        modelOptions.features = ['playpause', 'progress', 'current', 'duration'];
        if (this.model.get('_useClosedCaptions')) {
          modelOptions.features.unshift('tracks');
        }
        if (this.model.get("_allowFullScreen")) {
          modelOptions.features.push('fullscreen');
        }
        if (this.model.get('_showVolumeControl')) {
          modelOptions.features.push('volume');
        }
      }

      /*
        Unless we are on Android/iOS and using native controls, when MediaElementJS initializes the player
        it will invoke the success callback prior to performing one last call to setPlayerSize.
        This call to setPlayerSize is deferred by 50ms so we add a delay of 100ms here to ensure that
        we don't invoke setReadyStatus until the player is definitely finished rendering.
        */
      modelOptions.success = _.debounce(this.onPlayerReady.bind(this), 100);

      if (this.model.get('_useClosedCaptions')) {
        var startLanguage = this.model.get('_startLanguage') || 'en';
        if (!Adapt.offlineStorage.get('captions')) {
          Adapt.offlineStorage.set('captions', startLanguage);
        }
        modelOptions.startLanguage = this.checkForSupportedCCLanguage(Adapt.offlineStorage.get('captions'));
      }

      if (modelOptions.alwaysShowControls === undefined) {
        modelOptions.alwaysShowControls = false;
      }
      if (modelOptions.hideVideoControlsOnLoad === undefined) {
        modelOptions.hideVideoControlsOnLoad = true;
      }

      this.addMediaTypeClass();

      this.addThirdPartyFixes(modelOptions, function createPlayer() {
        // create the player
        this.$('audio, video').mediaelementplayer(modelOptions);
        this.cleanUpPlayer();

        var _media = this.model.get('_media');
        // if no media is selected - set ready now, as success won't be called
        if (!_media.mp3 && !_media.mp4 && !_media.ogv && !_media.webm && !_media.source) {
          Adapt.log.warn("ERROR! No media is selected in components.json for component " + this.model.get('_id'));
          this.setReadyStatus();
          return;
        }
        // Check if we're streaming
        if (_media.source) {
          this.$('.media-widget').addClass('external-source');
        }
      }.bind(this));
    },

    addMediaTypeClass: function addMediaTypeClass() {
      var media = this.model.get("_media");
      if (media && media.type) {
        var typeClass = media.type.replace(/\//, "-");
        this.$(".media__widget").addClass(typeClass);
      }
    },

    addThirdPartyFixes: function addThirdPartyFixes(modelOptions, callback) {
      var media = this.model.get("_media");
      if (!media) return callback();

      switch (media.type) {
        case "video/vimeo":
          modelOptions.alwaysShowControls = false;
          modelOptions.hideVideoControlsOnLoad = true;
          modelOptions.features = [];
          if (froogaloopAdded) return callback();
          $.getScript("assets/froogaloop.js").
          done(function () {
            froogaloopAdded = true;
            callback();
          }).
          fail(function () {
            froogaloopAdded = false;
            console.log('Could not load froogaloop.js');
          });
          break;
        default:
          callback();}

    },

    cleanUpPlayer: function cleanUpPlayer() {
      this.$('.media__widget').children('.mejs-offscreen').remove();
      this.$('[role=application]').removeAttr('role tabindex');
      this.$('[aria-controls]').removeAttr('aria-controls');
    },

    setupEventListeners: function setupEventListeners() {
      this.completionEvent = this.model.get('_setCompletionOn') || 'play';

      if (this.completionEvent === 'inview') {
        this.setupInviewCompletion('.component__widget');
      }

      // wrapper to check if preventForwardScrubbing is turned on.
      if (this.model.get('_preventForwardScrubbing') && !this.model.get('_isComplete')) {
        $(this.mediaElement).on({
          'seeking': this.onMediaElementSeeking,
          'timeupdate': this.onMediaElementTimeUpdate });

      }

      // handle other completion events in the event Listeners
      $(this.mediaElement).on({
        'play': this.onMediaElementPlay,
        'pause': this.onMediaElementPause,
        'ended': this.onMediaElementEnded });


      // occasionally the mejs code triggers a click of the captions language
      // selector during setup, this slight delay ensures we skip that
      _.delay(this.listenForCaptionsChange.bind(this), 250);
    },

    /**
        * Sets up the component to detect when the user has changed the captions so that it can store the user's
        * choice in offlineStorage and notify other media components on the same page of the change
        * Also sets the component up to listen for this event from other media components on the same page
        */
    listenForCaptionsChange: function listenForCaptionsChange() {
      if (!this.model.get('_useClosedCaptions')) return;

      var selector = this.model.get('_playerOptions').toggleCaptionsButtonWhenOnlyOne ?
      '.mejs-captions-button button' :
      '.mejs-captions-selector';

      this.$(selector).on('click.mediaCaptionsChange', _.debounce(function () {
        var srclang = this.mediaElement.player.selectedTrack ? this.mediaElement.player.selectedTrack.srclang : 'none';
        Adapt.offlineStorage.set('captions', srclang);
        Adapt.trigger('media:captionsChange', this, srclang);
      }.bind(this), 250)); // needs debouncing because the click event fires twice

      this.listenTo(Adapt, 'media:captionsChange', this.onCaptionsChanged);
    },

    /**
        * Handles updating the captions in this instance when learner changes captions in another
        * media component on the same page
        * @param {Backbone.View} view The view instance that triggered the event
        * @param {string} lang The captions language the learner chose in the other media component
        */
    onCaptionsChanged: function onCaptionsChanged(view, lang) {
      if (view && view.cid === this.cid) return; //ignore the event if we triggered it

      lang = this.checkForSupportedCCLanguage(lang);

      this.mediaElement.player.setTrack(lang);

      // because calling player.setTrack doesn't update the cc button's languages popup...
      var $inputs = this.$('.mejs-captions-selector input');
      $inputs.filter(':checked').prop('checked', false);
      $inputs.filter('[value="' + lang + '"]').prop('checked', true);
    },

    /**
        * When the learner selects a captions language in another media component, that language may not be available
        * in this instance, in which case default to the `_startLanguage` if that's set - or "none" if it's not
        * @param {string} lang The language we're being asked to switch to e.g. "de"
        * @return {string} The language we're actually going to switch to - or "none" if there's no good match
        */
    checkForSupportedCCLanguage: function checkForSupportedCCLanguage(lang) {
      if (!lang || lang === 'none') return 'none';

      if (_.findWhere(this.model.get('_media').cc, { srclang: lang })) return lang;

      return this.model.get('_startLanguage') || 'none';
    },

    onMediaElementPlay: function onMediaElementPlay(event) {
      this.queueGlobalEvent('play');

      Adapt.trigger("media:stop", this);

      if (this.model.get('_pauseWhenOffScreen')) $(this.mediaElement).on('inview', this.onMediaElementInview);

      this.model.set({
        '_isMediaPlaying': true,
        '_isMediaEnded': false });


      if (this.completionEvent === 'play') {
        this.setCompletionStatus();
      }
    },

    onMediaElementPause: function onMediaElementPause(event) {
      this.queueGlobalEvent('pause');

      $(this.mediaElement).off('inview', this.onMediaElementInview);

      this.model.set('_isMediaPlaying', false);
    },

    onMediaElementEnded: function onMediaElementEnded(event) {
      this.queueGlobalEvent('ended');

      this.model.set('_isMediaEnded', true);

      if (this.completionEvent === 'ended') {
        this.setCompletionStatus();
      }
    },

    onMediaElementInview: function onMediaElementInview(event, isInView) {
      if (!isInView && !event.currentTarget.paused) event.currentTarget.pause();
    },

    onMediaElementSeeking: function onMediaElementSeeking(event) {
      var maxViewed = this.model.get("_maxViewed");
      if (!maxViewed) {
        maxViewed = 0;
      }
      if (event.target.currentTime > maxViewed) {
        event.target.currentTime = maxViewed;
      }
    },

    onMediaElementTimeUpdate: function onMediaElementTimeUpdate(event) {
      var maxViewed = this.model.get("_maxViewed");
      if (!maxViewed) {
        maxViewed = 0;
      }
      if (event.target.currentTime > maxViewed) {
        this.model.set("_maxViewed", event.target.currentTime);
      }
    },

    // Overrides the default play/pause functionality to stop accidental playing on touch devices
    setupPlayPauseToggle: function setupPlayPauseToggle() {
      // bit sneaky, but we don't have a this.mediaElement.player ref on iOS devices
      var player = this.mediaElement.player;

      if (!player) {
        console.log("Media.setupPlayPauseToggle: OOPS! there's no player reference.");
        return;
      }

      // stop the player dealing with this, we'll do it ourselves
      player.options.clickToPlayPause = false;

      this.onOverlayClick = this.onOverlayClick.bind(this);
      this.onMediaElementClick = this.onMediaElementClick.bind(this);

      // play on 'big button' click
      this.$('.mejs-overlay-button').on("click", this.onOverlayClick);

      // pause on player click
      this.$('.mejs-mediaelement').on("click", this.onMediaElementClick);
    },

    onMediaStop: function onMediaStop(view) {

      // Make sure this view isn't triggering media:stop
      if (view && view.cid === this.cid) return;

      if (!this.mediaElement || !this.mediaElement.player) return;

      this.mediaElement.player.pause();

    },

    onOverlayClick: function onOverlayClick() {
      var player = this.mediaElement.player;
      if (!player) return;

      player.play();
    },

    onMediaElementClick: function onMediaElementClick(event) {
      var player = this.mediaElement.player;
      if (!player) return;

      var isPaused = player.media.paused;
      if (!isPaused) player.pause();
    },

    checkIfResetOnRevisit: function checkIfResetOnRevisit() {
      var isResetOnRevisit = this.model.get('_isResetOnRevisit');

      if (isResetOnRevisit) {
        this.model.reset(isResetOnRevisit);
      }
    },

    remove: function remove() {
      this.$('.mejs-overlay-button').off("click", this.onOverlayClick);
      this.$('.mejs-mediaelement').off("click", this.onMediaElementClick);

      if (this.model.get('_useClosedCaptions')) {
        var selector = this.model.get('_playerOptions').toggleCaptionsButtonWhenOnlyOne ?
        '.mejs-captions-button button' :
        '.mejs-captions-selector';
        this.$(selector).off('click.mediaCaptionsChange');
      }

      var modelOptions = this.model.get('_playerOptions');
      delete modelOptions.success;

      var media = this.model.get("_media");
      if (media) {
        switch (media.type) {
          case "video/vimeo":
            this.$("iframe")[0].isRemoved = true;}

      }

      if (this.mediaElement && this.mediaElement.player) {
        var player_id = this.mediaElement.player.id;

        purge(this.$el[0]);
        this.mediaElement.player.remove();

        if (mejs.players[player_id]) {
          delete mejs.players[player_id];
        }
      }

      if (this.mediaElement) {
        $(this.mediaElement).off({
          'play': this.onMediaElementPlay,
          'pause': this.onMediaElementPause,
          'ended': this.onMediaElementEnded,
          'seeking': this.onMediaElementSeeking,
          'timeupdate': this.onMediaElementTimeUpdate,
          'inview': this.onMediaElementInview });


        this.mediaElement.src = "";
        $(this.mediaElement.pluginElement).remove();
        delete this.mediaElement;
      }

      ComponentView.prototype.remove.call(this);
    },

    onDeviceChanged: function onDeviceChanged() {
      if (this.model.get('_media').source) {
        this.$('.mejs-container').width(this.$('.component__widget').width());
      }
    },

    onPlayerReady: function onPlayerReady(mediaElement, domObject) {
      this.mediaElement = mediaElement;

      var player = this.mediaElement.player;
      if (!player) player = mejs.players[this.$('.mejs-container').attr('id')];

      var hasTouch = mejs.MediaFeatures.hasTouch;
      if (hasTouch) {
        this.setupPlayPauseToggle();
      }

      this.addThirdPartyAfterFixes();
      this.cleanUpPlayerAfter();

      if (player && this.model.has('_startVolume')) {
        // Setting the start volume only works with the Flash-based player if you do it here rather than in setupPlayer
        player.setVolume(parseInt(this.model.get('_startVolume')) / 100);
      }

      this.setReadyStatus();
      this.setupEventListeners();
    },

    addThirdPartyAfterFixes: function addThirdPartyAfterFixes() {
      var media = this.model.get("_media");
      switch (media.type) {
        case "video/vimeo":
          this.$(".mejs-container").attr("tabindex", 0);}

    },

    cleanUpPlayerAfter: function cleanUpPlayerAfter() {
      this.$("[aria-valuemax='NaN']").attr("aria-valuemax", 0);
    },

    onScreenSizeChanged: function onScreenSizeChanged() {
      this.$('audio, video').width(this.$('.component__widget').width());
    },

    onSkipToTranscript: function onSkipToTranscript() {
      // need slight delay before focussing button to make it work when JAWS is running
      // see https://github.com/adaptlearning/adapt_framework/issues/2427
      _.delay(function () {
        this.$('.media__transcript-btn').a11y_focus();
      }.bind(this), 250);
    },

    onToggleInlineTranscript: function onToggleInlineTranscript(event) {
      if (event) event.preventDefault();
      var $transcriptBodyContainer = this.$(".media__transcript-body-inline");
      var $button = this.$(".media__transcript-btn-inline");
      var $buttonText = this.$(".media__transcript-btn-inline .media__transcript-btn-text");

      if ($transcriptBodyContainer.hasClass("inline-transcript-open")) {
        $transcriptBodyContainer.stop(true, true).slideUp(function () {
          $(window).resize();
        });
        $button.attr('aria-expanded', false);
        $transcriptBodyContainer.removeClass("inline-transcript-open");
        $buttonText.html(this.model.get("_transcript").inlineTranscriptButton);
      } else {
        $transcriptBodyContainer.stop(true, true).slideDown(function () {
          $(window).resize();
        });
        $button.attr('aria-expanded', true);
        $transcriptBodyContainer.addClass("inline-transcript-open");
        $buttonText.html(this.model.get("_transcript").inlineTranscriptCloseButton);

        if (this.model.get('_transcript')._setCompletionOnView !== false) {
          this.setCompletionStatus();
        }
      }
    },

    onExternalTranscriptClicked: function onExternalTranscriptClicked(event) {
      if (this.model.get('_transcript')._setCompletionOnView !== false) {
        this.setCompletionStatus();
      }
    },

    /**
        * Queue firing a media event to prevent simultaneous events firing, and provide a better indication of how the
        * media  player is behaving
        * @param {string} eventType
        */
    queueGlobalEvent: function queueGlobalEvent(eventType) {
      var t = Date.now();
      var lastEvent = this.lastEvent || { time: 0 };
      var timeSinceLastEvent = t - lastEvent.time;
      var debounceTime = 500;

      this.lastEvent = {
        time: t,
        type: eventType };


      // Clear any existing timeouts
      clearTimeout(this.eventTimeout);

      // Always trigger 'ended' events
      if (eventType === 'ended') {
        return this.triggerGlobalEvent(eventType);
      }

      // Fire the event after a delay, only if another event has not just been fired
      if (timeSinceLastEvent > debounceTime) {
        this.eventTimeout = setTimeout(this.triggerGlobalEvent.bind(this, eventType), debounceTime);
      }
    },

    triggerGlobalEvent: function triggerGlobalEvent(eventType) {
      var player = this.mediaElement.player;

      var eventObj = {
        type: eventType,
        src: this.mediaElement.src,
        platform: this.mediaElement.pluginType };


      if (player) eventObj.isVideo = player.isVideo;

      Adapt.trigger('media', eventObj);
    } });



  return Adapt.register('media', {
    model: ComponentModel.extend({}), // create a new class in the inheritance chain so it can be extended per component type if necessary later
    view: MediaView });


});

define('components/adapt-contrib-narrative/js/modeEnum', [], function () {

  return new ENUM([
  'SMALL',
  'LARGE']);


});

define('components/adapt-contrib-narrative/js/narrativeView', [
'core/js/adapt',
'core/js/views/componentView',
'./modeEnum'],
function (Adapt, ComponentView, MODE) {var

  NarrativeView = /*#__PURE__*/function (_ComponentView7) {"use strict";_inherits(NarrativeView, _ComponentView7);var _super47 = _createSuper(NarrativeView);function NarrativeView() {_classCallCheck(this, NarrativeView);return _super47.apply(this, arguments);}_createClass(NarrativeView, [{ key: "events", value: function events()

      {
        return {
          'click .js-narrative-strapline-open-popup': 'openPopup',
          'click .js-narrative-controls-click': 'onNavigationClicked',
          'click .js-narrative-progress-click': 'onProgressClicked' };

      } }, { key: "initialize", value: function initialize()

      {var _get7;for (var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++) {args[_key19] = arguments[_key19];}
        (_get7 = _get(_getPrototypeOf(NarrativeView.prototype), "initialize", this)).call.apply(_get7, [this].concat(args));

        this._isInitial = true;
      } }, { key: "preRender", value: function preRender()

      {
        this.listenTo(Adapt, {
          'device:changed device:resize': this.reRender,
          'notify:closed': this.closeNotify });

        this.renderMode();

        this.listenTo(this.model.getChildren(), {
          'change:_isActive': this.onItemsActiveChange,
          'change:_isVisited': this.onItemsVisitedChange });


        this.checkIfResetOnRevisit();
        this.calculateWidths();
      } }, { key: "onItemsActiveChange", value: function onItemsActiveChange(

      item, _isActive) {
        if (!_isActive) return;
        this.setStage(item);
      } }, { key: "onItemsVisitedChange", value: function onItemsVisitedChange(

      item, _isVisited) {
        if (!_isVisited) return;
        this.$("[data-index=\"".concat(item.get('_index'), "\"]")).addClass('is-visited');
      } }, { key: "calculateMode", value: function calculateMode()

      {
        var mode = Adapt.device.screenSize === 'large' ? MODE.LARGE : MODE.SMALL;
        this.model.set('_mode', mode);
      } }, { key: "renderMode", value: function renderMode()

      {
        this.calculateMode();

        var isLargeMode = this.isLargeMode();
        this.$el.toggleClass('mode-large', isLargeMode).toggleClass('mode-small', !isLargeMode);
      } }, { key: "isLargeMode", value: function isLargeMode()

      {
        return this.model.get('_mode') === MODE.LARGE;
      } }, { key: "postRender", value: function postRender()

      {
        this.renderMode();
        this.setupNarrative();

        this.$('.narrative__slider').imageready(this.setReadyStatus.bind(this));

        if (Adapt.config.get('_disableAnimation')) {
          this.$el.addClass('disable-animation');
        }
      } }, { key: "checkIfResetOnRevisit", value: function checkIfResetOnRevisit()

      {
        var isResetOnRevisit = this.model.get('_isResetOnRevisit');
        // If reset is enabled set defaults
        if (isResetOnRevisit) {
          this.model.reset(isResetOnRevisit);
        }
      } }, { key: "setupNarrative", value: function setupNarrative()

      {
        this.renderMode();
        var items = this.model.getChildren();
        if (!items || !items.length) return;

        var activeItem = this.model.getActiveItem();
        if (!activeItem) {
          activeItem = this.model.getItem(0);
          activeItem.toggleActive(true);
        } else {
          // manually trigger change as it is not fired on reentry
          items.trigger('change:_isActive', activeItem, true);
        }

        this.calculateWidths();

        if (!this.isLargeMode() && !this.model.get('_wasHotgraphic')) {
          this.replaceInstructions();
        }
        this.setupEventListeners();
        this._isInitial = false;
      } }, { key: "calculateWidths", value: function calculateWidths()

      {
        var itemCount = this.model.getChildren().length;
        this.model.set({
          _totalWidth: 100 * itemCount,
          _itemWidth: 100 / itemCount });

      } }, { key: "resizeControl", value: function resizeControl()

      {
        var previousMode = this.model.get('_mode');
        this.renderMode();
        if (previousMode !== this.model.get('_mode')) this.replaceInstructions();
        this.evaluateNavigation();
        var activeItem = this.model.getActiveItem();
        if (activeItem) this.setStage(activeItem);
      } }, { key: "reRender", value: function reRender()

      {
        if (this.model.get('_wasHotgraphic') && this.isLargeMode()) {
          this.replaceWithHotgraphic();
          return;
        }
        this.resizeControl();
      } }, { key: "closeNotify", value: function closeNotify()

      {
        this.evaluateCompletion();
      } }, { key: "replaceInstructions", value: function replaceInstructions()

      {
        if (this.isLargeMode()) {
          this.$('.narrative__instruction-inner').html(this.model.get('instruction'));
          return;
        }

        if (this.model.get('mobileInstruction') && !this.model.get('_wasHotgraphic')) {
          this.$('.narrative__instruction-inner').html(this.model.get('mobileInstruction'));
        }
      } }, { key: "replaceWithHotgraphic", value: function replaceWithHotgraphic()

      {var _this90 = this;
        var HotgraphicView = Adapt.getViewClass('hotgraphic');
        if (!HotgraphicView) return;

        var model = this.prepareHotgraphicModel();
        var newHotgraphic = new HotgraphicView({ model: model });

        this.$el.parents('.component__container').append(newHotgraphic.$el);
        this.remove();
        _.defer(function () {_newArrowCheck(this, _this90);
          Adapt.trigger('device:resize');
        }.bind(this));
      } }, { key: "prepareHotgraphicModel", value: function prepareHotgraphicModel()

      {
        var model = this.model;
        model.resetActiveItems();
        model.set({
          _isPopupOpen: false,
          _component: 'hotgraphic',
          body: model.get('originalBody'),
          instruction: model.get('originalInstruction') });


        return model;
      } }, { key: "moveSliderToIndex", value: function moveSliderToIndex(

      itemIndex) {
        var offset = this.model.get('_itemWidth') * itemIndex;
        if (Adapt.config.get('_defaultDirection') === 'ltr') {
          offset *= -1;
        }
        var cssValue = "translateX(".concat(offset, "%)");
        var $sliderElm = this.$('.narrative__slider');
        var $straplineHeaderElm = this.$('.narrative__strapline-header-inner');

        $sliderElm.css('transform', cssValue);
        $straplineHeaderElm.css('transform', cssValue);

        if (this._isInitial) return;

        var $elementToFocus = this.isLargeMode() ? this.$(".narrative__content-item[data-index=\"".concat(itemIndex, "\"]")) : this.$('.narrative__strapline-btn');
        Adapt.a11y.focusFirst($elementToFocus);
      } }, { key: "setStage", value: function setStage(

      item) {
        var index = item.get('_index');
        var indexSelector = "[data-index=\"".concat(index, "\"]");

        if (this.isLargeMode()) {
          // Set the visited attribute for large screen devices
          item.toggleVisited(true);
        }

        this.$('.narrative__progress').removeClass('is-selected').filter(indexSelector).addClass('is-selected');

        var $slideGraphics = this.$('.narrative__slider-image-container');
        Adapt.a11y.toggleAccessibleEnabled($slideGraphics.children('.controls'), false);
        Adapt.a11y.toggleAccessibleEnabled($slideGraphics.filter(indexSelector).children('.controls'), true);

        var $narrativeItems = this.$('.narrative__content-item');
        $narrativeItems.addClass('u-visibility-hidden u-display-none');
        Adapt.a11y.toggleAccessible($narrativeItems, false);
        Adapt.a11y.toggleAccessible($narrativeItems.filter(indexSelector).removeClass('u-visibility-hidden u-display-none'), true);

        var $narrativeStraplineButtons = this.$('.narrative__strapline-btn');
        Adapt.a11y.toggleAccessibleEnabled($narrativeStraplineButtons, false);
        Adapt.a11y.toggleAccessibleEnabled($narrativeStraplineButtons.filter(indexSelector), true);

        this.evaluateNavigation();
        this.evaluateCompletion();
        this.moveSliderToIndex(index);
      } }, { key: "evaluateNavigation", value: function evaluateNavigation()

      {
        var active = this.model.getActiveItem();
        if (!active) return;

        var index = active.get('_index');
        var itemCount = this.model.getChildren().length;

        var isAtStart = index === 0;
        var isAtEnd = index === itemCount - 1;

        var $left = this.$('.narrative__controls-left');
        var $right = this.$('.narrative__controls-right');

        var globals = Adapt.course.get('_globals');

        var ariaLabelsGlobals = globals._accessibility._ariaLabels;
        var narrativeGlobals = globals._components._narrative;

        var ariaLabelPrevious = narrativeGlobals.previous || ariaLabelsGlobals.previous;
        var ariaLabelNext = narrativeGlobals.next || ariaLabelsGlobals.next;

        var prevTitle = isAtStart ? '' : this.model.getItem(index - 1).get('title');
        var nextTitle = isAtEnd ? '' : this.model.getItem(index + 1).get('title');

        $left.toggleClass('u-visibility-hidden', isAtStart);
        $right.toggleClass('u-visibility-hidden', isAtEnd);

        $left.attr('aria-label', Handlebars.compile(ariaLabelPrevious)({
          title: prevTitle,
          _globals: globals,
          itemNumber: isAtStart ? null : index,
          totalItems: itemCount }));

        $right.attr('aria-label', Handlebars.compile(ariaLabelNext)({
          title: nextTitle,
          _globals: globals,
          itemNumber: isAtEnd ? null : index + 2,
          totalItems: itemCount }));

      } }, { key: "evaluateCompletion", value: function evaluateCompletion()

      {
        if (this.model.areAllItemsCompleted()) {
          this.trigger('allItems');
        }
      } }, { key: "openPopup", value: function openPopup()

      {
        var currentItem = this.model.getActiveItem();
        Adapt.notify.popup({
          title: currentItem.get('title'),
          body: currentItem.get('body') });


        Adapt.on('popup:opened', function () {
          // Set the visited attribute for small and medium screen devices
          currentItem.toggleVisited(true);
        });
      } }, { key: "onNavigationClicked", value: function onNavigationClicked(

      event) {
        var $btn = $(event.currentTarget);
        var index = this.model.getActiveItem().get('_index');
        $btn.data('direction') === 'right' ? index++ : index--;
        this.model.setActiveItem(index);
      } }, { key: "onProgressClicked", value: function onProgressClicked(

      event) {
        var index = $(event.target).data('index');
        this.model.setActiveItem(index);
      } }, { key: "setupEventListeners", value: function setupEventListeners()

      {
        if (this.model.get('_setCompletionOn') === 'inview') {
          this.setupInviewCompletion('.component__widget');
        }
      } }]);return NarrativeView;}(ComponentView);



  NarrativeView.template = 'narrative';

  return NarrativeView;

});

define('components/adapt-contrib-narrative/js/adapt-contrib-narrative', [
'core/js/adapt',
'./narrativeView',
'core/js/models/itemsComponentModel'],
function (Adapt, NarrativeView, ItemsComponentModel) {

  return Adapt.register('narrative', {
    model: ItemsComponentModel.extend({}),
    view: NarrativeView });


});

define('components/adapt-contrib-slider/js/sliderView', [
'core/js/adapt',
'core/js/views/questionView'],
function (Adapt, QuestionView) {

  var SliderView = QuestionView.extend({

    events: {
      'click .js-slider-number-click': 'onNumberSelected',
      'focus .js-slider-item-input': 'onHandleFocus',
      'blur .js-slider-item-input': 'onHandleBlur' },


    // Used by the question to reset the question when revisiting the component
    resetQuestionOnRevisit: function resetQuestionOnRevisit() {
      this.setAllItemsEnabled();
      this.model.deselectAllItems();
      this.resetQuestion();
    },

    // Used by question to setup itself just before rendering
    setupQuestion: function setupQuestion() {
      if (this.model.get('_isSubmitted')) return;

      this.selectItem(this.getIndexFromValue(this.model.get('_selectedItem').value), true);
    },

    setupRangeslider: function setupRangeslider() {
      this.$sliderScaleMarker = this.$('.js-slider-number-selection');
      this.$slider = this.$('.js-slider-item-input');
      if (this.model.has('_scaleStep')) {
        this.$slider.attr({ "step": this.model.get('_scaleStep') });
      }

      this.$slider.rangeslider({
        polyfill: false,
        onSlide: _.bind(this.handleSlide, this) });

      this.oldValue = 0;

      if (this._deferEnable) {
        this.setAllItemsEnabled();
      }
    },

    handleSlide: function handleSlide(position, value) {
      if (this.oldValue === value) {
        return;
      }
      var itemIndex = this.getIndexFromValue(value);
      var pixels = this.mapIndexToPixels(itemIndex);
      this.selectItem(itemIndex, false);
      this.animateToPosition(pixels);
      this.oldValue = value;
    },

    disableQuestion: function disableQuestion() {
      this.setAllItemsEnabled();
    },

    enableQuestion: function enableQuestion() {
      this.setAllItemsEnabled();
    },

    setAllItemsEnabled: function setAllItemsEnabled() {
      var isEnabled = this.model.get('_isEnabled');

      if (!this.$slider) {
        this._deferEnable = true; // slider is not yet ready
        return;
      }

      if (!isEnabled) {
        this.$('.slider__widget').addClass('is-disabled');
        this.$slider.prop('disabled', true).rangeslider('update', true);
        return;
      }

      this.$('.slider__widget').removeClass('is-disabled');
      this.$slider.prop('disabled', false).rangeslider('update', true);
    },

    onQuestionRendered: function onQuestionRendered() {
      this.setupRangeslider();
      this.setScalePositions();
      this.onScreenSizeChanged();
      this.showScaleMarker(true);
      this.listenTo(Adapt, 'device:resize', this.onScreenSizeChanged);
      this.setReadyStatus();
    },

    // this should make the slider handle, slider marker and slider bar to animate to give position
    animateToPosition: function animateToPosition(newPosition) {
      if (!this.$sliderScaleMarker) return;

      this.$sliderScaleMarker.
      velocity('stop').
      velocity({
        left: newPosition },
      {
        duration: 200,
        easing: "linear",
        mobileHA: false });

    },

    // this shoud give the index of item using given slider value
    getIndexFromValue: function getIndexFromValue(itemValue) {
      var scaleStart = this.model.get('_scaleStart');
      var scaleEnd = this.model.get('_scaleEnd');
      return Math.round(this.mapValue(itemValue, scaleStart, scaleEnd, 0, this.model.get('_items').length - 1));
    },

    mapIndexToPixels: function mapIndexToPixels(value, $widthObject) {
      var numberOfItems = this.model.get('_items').length;
      var width = $widthObject ? $widthObject.width() : this.$('.js-slider-scale').width();

      return Math.round(this.mapValue(value, 0, numberOfItems - 1, 0, width));
    },

    mapPixelsToIndex: function mapPixelsToIndex(value) {
      var numberOfItems = this.model.get('_items').length;
      var width = this.$('.slider-sliderange').width();

      return Math.round(this.mapValue(value, 0, width, 0, numberOfItems - 1));
    },

    normalise: function normalise(value, low, high) {
      var range = high - low;
      return (value - low) / range;
    },

    mapValue: function mapValue(value, inputLow, inputHigh, outputLow, outputHigh) {
      var normal = this.normalise(value, inputLow, inputHigh);
      return normal * (outputHigh - outputLow) + outputLow;
    },

    onHandleFocus: function onHandleFocus(event) {
      event.preventDefault();
      this.$slider.on('keydown', _.bind(this.onKeyDown, this));
    },

    onHandleBlur: function onHandleBlur(event) {
      event.preventDefault();
      this.$slider.off('keydown');
    },

    onKeyDown: function onKeyDown(event) {
      if (event.which === 9) return; // tab key
      event.preventDefault();

      var newItemIndex = this.getIndexFromValue(this.model.get('_selectedItem').value);

      switch (event.which) {
        case 40: //  down
        case 37: //  left
          newItemIndex = Math.max(newItemIndex - 1, 0);
          break;
        case 38: //  up
        case 39: //  right
          newItemIndex = Math.min(newItemIndex + 1, this.model.get('_items').length - 1);
          break;}


      this.selectItem(newItemIndex);
      if (typeof newItemIndex === 'number') this.showScaleMarker(true);
      this.animateToPosition(this.mapIndexToPixels(newItemIndex));
      this.setSliderValue(this.getValueFromIndex(newItemIndex));
    },

    onNumberSelected: function onNumberSelected(event) {
      event.preventDefault();

      if (this.model.get('_isInteractionComplete')) {
        return;
      }

      // when component is not reset, selecting a number should be prevented
      if (this.$slider.prop('disabled')) {
        return;
      }

      var itemValue = parseFloat($(event.currentTarget).attr('data-id'));
      var index = this.getIndexFromValue(itemValue);
      this.selectItem(index);
      this.animateToPosition(this.mapIndexToPixels(index));
      this.setSliderValue(itemValue);
    },

    getValueFromIndex: function getValueFromIndex(index) {
      return this.model.get('_items')[index].value;
    },

    resetControlStyles: function resetControlStyles() {
      this.$('.slider-handle').empty();
      this.showScaleMarker(false);
      this.$('.slider-bar').animate({ width: '0px' });
      this.setSliderValue(this.model.get('_items')[0].value);
    },

    onCannotSubmit: function onCannotSubmit() {},

    setSliderValue: function setSliderValue(value) {
      if (this.$slider) {
        this.$slider.val(value).change();
      }
    },

    showMarking: function showMarking() {
      if (!this.model.get('_canShowMarking')) return;

      this.$('.slider__widget').removeClass('is-correct is-incorrect').
      addClass(this.model.get('_selectedItem').correct ? 'is-correct' : 'is-incorrect');
    },

    resetQuestion: function resetQuestion() {
      this.selectItem(0, true);
      this.animateToPosition(0);
      this.resetControlStyles();
      this.showScaleMarker(true);
    },

    setScalePositions: function setScalePositions() {
      var numberOfItems = this.model.get('_items').length;
      _.each(this.model.get('_items'), function (item, index) {
        var normalisedPosition = this.normalise(index, 0, numberOfItems - 1);
        this.$('.js-slider-number').eq(index).data('normalisedPosition', normalisedPosition);
      }, this);
    },

    showScale: function showScale() {
      var $markers = this.$('.js-slider-scale-notch-container').empty();

      if (this.model.get('_showScale') === false) {
        $markers.eq(0).css({ display: 'none' });
        this.$('.js-slider-number').css(
        this.model.get('_showScaleIndicator') ? { visibility: 'hidden' } : { display: 'none' });

        return;
      }

      var $scaler = this.$('.js-slider-scale');
      for (var i = 1, count = this.model.get('_items').length - 1; i < count; i++) {
        $markers.append("<div class='slider__scale-notch' style='left: " + this.mapIndexToPixels(i, $scaler) + "px'>");
      }
      // Do we show scale numbers
      this.showScaleNumbers();
    },

    showScaleNumbers: function showScaleNumbers() {
      var $scaler = this.$('.js-slider-scale');
      var $numbers = this.$('.js-slider-number');

      if (this.model.get('_showScaleNumbers') === false) {
        $numbers.css('display', 'none');
        return;
      }

      var scaleWidth = $scaler.width();
      this.model.get('_items').forEach(function (item, index) {
        var $number = $numbers.eq(index);
        var newLeft = Math.round($number.data('normalisedPosition') * scaleWidth);
        $number.css({ left: newLeft });
      });
    },

    //Labels are enabled in slider.hbs. Here we manage their containing div.
    showLabels: function showLabels() {
      if (!this.model.get('labelStart') && !this.model.get('labelEnd')) {
        this.$('.js-slider-label-container').eq(0).css({ display: 'none' });
      }
    },

    remapSliderBar: function remapSliderBar() {
      var $scaler = this.$('.js-slider-scale');
      var currentIndex = this.getIndexFromValue(this.model.get('_selectedItem').value);
      var left = this.mapIndexToPixels(currentIndex, $scaler);
      this.$('.slider-handle').css({ left: left + 'px' });
      this.$('.js-slider-number-selection').css({ left: left + 'px' });
      this.$('.slider-bar').width(left);
    },

    onScreenSizeChanged: function onScreenSizeChanged() {
      this.showScale();
      this.showLabels();
      this.remapSliderBar();
      if (this.$('.slider__widget').hasClass('show-user-answer')) {
        this.hideCorrectAnswer();
      } else if (this.$('.slider__widget').hasClass('show-correct-answer')) {
        this.showCorrectAnswer();
      }
    },

    showCorrectAnswer: function showCorrectAnswer() {
      var answers = [];

      if (this.model.has('_correctAnswer')) {
        var correctAnswer = this.model.get('_correctAnswer');
      }

      if (this.model.has('_correctRange')) {
        var bottom = this.model.get('_correctRange')._bottom;
        var top = this.model.get('_correctRange')._top;
        var step = this.model.has('_scaleStep') ? this.model.get('_scaleStep') : 1;
      }

      this.showScaleMarker(false);

      //are we dealing with a single correct answer or a range?
      if (correctAnswer) {
        answers.push(correctAnswer);
      } else if (bottom !== undefined && top !== undefined) {
        var answer = this.model.get('_correctRange')._bottom;
        var topOfRange = this.model.get('_correctRange')._top;
        while (answer <= topOfRange) {
          answers.push(answer);
          answer += step;
        }
      } else {
        console.log("adapt-contrib-slider::WARNING: no correct answer or correct range set in JSON");
      }

      var middleAnswer = answers[Math.floor(answers.length / 2)];
      this.animateToPosition(this.mapIndexToPixels(this.getIndexFromValue(middleAnswer)));

      this.showModelAnswers(answers);

      this.setSliderValue(middleAnswer);
    },

    showModelAnswers: function showModelAnswers(correctAnswerArray) {
      var $parentDiv = this.$('.js-slider-model-range');
      _.each(correctAnswerArray, function (correctAnswer, index) {
        $parentDiv.append($("<div class='slider__number-model-answer'>"));

        var $element = $(this.$('.js-slider-model-range .slider__number-model-answer')[index]);
        var startingLeft = this.mapIndexToPixels(this.getIndexFromValue(this.model.get('_selectedItem').value));

        if (this.model.get('_showNumber')) $element.html(correctAnswer);

        $element.css({ left: startingLeft }).fadeIn(0, _.bind(function () {
          $element.animate({ left: this.mapIndexToPixels(this.getIndexFromValue(correctAnswer)) });
        }, this));
      }, this);
    },

    hideCorrectAnswer: function hideCorrectAnswer() {
      var userAnswerIndex = this.getIndexFromValue(this.model.get('_userAnswer'));
      this.$('.js-slider-model-range').empty();

      this.showScaleMarker(true);
      this.selectItem(userAnswerIndex, true);
      this.animateToPosition(this.mapIndexToPixels(userAnswerIndex));
      this.setSliderValue(this.model.get('_userAnswer'));
    },

    // according to given item index this should make the item as selected
    selectItem: function selectItem(itemIndex, noFocus) {
      _.each(this.model.get('_items'), function (item, index) {
        item.selected = index === itemIndex;
        if (item.selected) {
          this.model.set('_selectedItem', item);
          this.$('.js-slider-item-input').attr({
            "value": item.value,
            "aria-valuenow": item.value });

        }
      }, this);
      this.showNumber(true);
    },

    // this makes the marker visible or hidden
    showScaleMarker: function showScaleMarker(show) {
      var $scaleMarker = this.$('.js-slider-number-selection');
      if (this.model.get('_showScaleIndicator')) {
        this.showNumber(show);
        if (show) {
          $scaleMarker.addClass('display-block');
        } else {
          $scaleMarker.removeClass('display-block');
        }
      }
    },

    // this should add the current slider value to the marker
    showNumber: function showNumber(show) {
      var $scaleMarker = this.$('.js-slider-number-selection');
      if (this.model.get('_showNumber')) {
        if (show) {
          $scaleMarker.html(this.model.get('_selectedItem').value);
        } else {
          $scaleMarker.html = "";
        }
      }
    } });



  return SliderView;

});

define('components/adapt-contrib-slider/js/sliderModel', [
'core/js/adapt',
'core/js/models/questionModel'],
function (Adapt, QuestionModel) {

  var SliderModel = QuestionModel.extend({

    init: function init() {
      QuestionModel.prototype.init.call(this);

      this.setupModelItems();

      this.set('_selectedItem', this.get('_items')[0]);
    },

    /**
        * Returns the number of decimal places in a specified number
        */
    getDecimalPlaces: function getDecimalPlaces(num) {
      return (num.toString().split('.')[1] || []).length;
    },

    setupModelItems: function setupModelItems() {
      var items = [];
      var answer = this.get('_correctAnswer');
      var range = this.get('_correctRange');
      var start = this.get('_scaleStart');
      var end = this.get('_scaleEnd');
      var step = this.get('_scaleStep') || 1;

      var dp = this.getDecimalPlaces(step);

      for (var i = start; i <= end; i += step) {
        if (dp !== 0) {
          // Ensure that steps with decimal places are handled correctly.
          i = parseFloat(i.toFixed(dp));
        }

        items.push({
          value: i,
          selected: false,
          // _correctAnswer/answer is a String - this allows AAT users to assign it no value when _correctRange needs to be used instead
          // we therefore need to convert it to Number when checking the answer (see https://github.com/adaptlearning/adapt_framework/issues/2259)
          correct: answer ? i === Number(answer) : i >= range._bottom && i <= range._top });

      }

      this.set({
        '_items': items,
        '_marginDir': Adapt.config.get('_defaultDirection') === 'rtl' ? 'right' : 'left' });

    },

    /**
       * allow the user to submit immediately; the slider handle may already be in the position they want to choose
       */
    canSubmit: function canSubmit() {
      return true;
    },

    restoreUserAnswers: function restoreUserAnswers() {
      if (!this.get('_isSubmitted')) {
        this.set({
          _selectedItem: {},
          _userAnswer: undefined });

        return;
      }

      var items = this.get('_items');
      var userAnswer = this.get('_userAnswer');
      for (var i = 0, l = items.length; i < l; i++) {
        var item = items[i];
        if (item.value === userAnswer) {
          item.selected = true;
          this.set('_selectedItem', item);
          break;
        }
      }

      this.setQuestionAsSubmitted();
      this.markQuestion();
      this.setScore();
      this.setupFeedback();
    },

    //This preserves the state of the users answers for returning or showing the users answer
    storeUserAnswer: function storeUserAnswer() {
      this.set('_userAnswer', this.get('_selectedItem').value);
    },

    resetUserAnswer: function resetUserAnswer() {
      this.set({
        _isAtLeastOneCorrectSelection: false,
        _selectedItem: {},
        _userAnswer: undefined });

    },

    deselectAllItems: function deselectAllItems() {
      _.each(this.get('_items'), function (item) {
        item.selected = false;
      }, this);
    },

    isCorrect: function isCorrect() {
      var numberOfCorrectAnswers = 0;

      _.each(this.get('_items'), function (item, index) {
        if (item.selected && item.correct) {
          this.set('_isAtLeastOneCorrectSelection', true);
          numberOfCorrectAnswers++;
        }
      }, this);

      this.set('_numberOfCorrectAnswers', numberOfCorrectAnswers);

      return this.get('_isAtLeastOneCorrectSelection') ? true : false;
    },

    isPartlyCorrect: function isPartlyCorrect() {
      return this.get('_isAtLeastOneCorrectSelection');
    },

    // Used to set the score based upon the _questionWeight
    setScore: function setScore() {
      var numberOfCorrectAnswers = this.get('_numberOfCorrectAnswers');
      var questionWeight = this.get('_questionWeight');
      var score = questionWeight * numberOfCorrectAnswers;
      this.set('_score', score);
    },

    /**
       * Used by adapt-contrib-spoor to get the user's answers in the format required by the cmi.interactions.n.student_response data field
       */
    getResponse: function getResponse() {
      return this.get('_userAnswer').toString();
    },

    /**
       * Used by adapt-contrib-spoor to get the type of this question in the format required by the cmi.interactions.n.type data field
       */
    getResponseType: function getResponseType() {
      return "numeric";
    } });



  return SliderModel;

});

define('components/adapt-contrib-slider/js/adapt-contrib-slider', [
'core/js/adapt',
'./sliderView',
'./sliderModel',
'libraries/rangeslider'],
function (Adapt, SliderView, SliderModel) {

  return Adapt.register("slider", {
    view: SliderView,
    model: SliderModel });


});

define('components/adapt-contrib-text/js/adapt-contrib-text', [
'core/js/adapt',
'core/js/views/componentView',
'core/js/models/componentModel'],
function (Adapt, ComponentView, ComponentModel) {var

  TextView = /*#__PURE__*/function (_ComponentView8) {"use strict";_inherits(TextView, _ComponentView8);var _super48 = _createSuper(TextView);function TextView() {_classCallCheck(this, TextView);return _super48.apply(this, arguments);}_createClass(TextView, [{ key: "preRender", value: function preRender()

      {
        this.checkIfResetOnRevisit();
      } }, { key: "postRender", value: function postRender()

      {
        this.setReadyStatus();

        this.setupInview();
      } }, { key: "setupInview", value: function setupInview()

      {
        var selector = this.getInviewElementSelector();
        if (!selector) {
          this.setCompletionStatus();
          return;
        }

        this.setupInviewCompletion(selector);
      }

      /**
         * determines which element should be used for inview logic - body, instruction or title - and returns the selector for that element
         */ }, { key: "getInviewElementSelector", value: function getInviewElementSelector()
      {
        if (this.model.get('body')) return '.component__body';

        if (this.model.get('instruction')) return '.component__instruction';

        if (this.model.get('displayTitle')) return '.component__title';

        return null;
      } }, { key: "checkIfResetOnRevisit", value: function checkIfResetOnRevisit()

      {
        var isResetOnRevisit = this.model.get('_isResetOnRevisit');

        // If reset is enabled set defaults
        if (isResetOnRevisit) {
          this.model.reset(isResetOnRevisit);
        }
      } }]);return TextView;}(ComponentView);


  TextView.template = 'text';

  return Adapt.register('text', {
    model: ComponentModel.extend({}), // create a new class in the inheritance chain so it can be extended per component type if necessary later
    view: TextView });

});

define('components/adapt-contrib-textInput/js/textInputView', [
'core/js/views/questionView'],
function (QuestionView) {

  var TextInputView = QuestionView.extend({

    events: {
      'focus .js-textinput-textbox': 'clearValidationError',
      'change .js-textinput-textbox': 'onInputChanged',
      'keyup .js-textinput-textbox': 'onInputChanged' },


    resetQuestionOnRevisit: function resetQuestionOnRevisit() {
      this.setAllItemsEnabled(false);
      this.resetQuestion();
    },

    setupQuestion: function setupQuestion() {
      this.model.setupRandomisation();
    },

    disableQuestion: function disableQuestion() {
      this.setAllItemsEnabled(false);
    },

    enableQuestion: function enableQuestion() {
      this.setAllItemsEnabled(true);
    },

    setAllItemsEnabled: function setAllItemsEnabled(isEnabled) {
      this.model.get('_items').forEach(function (item, index) {
        var $itemInput = this.$('.js-textinput-textbox').eq(index);

        $itemInput.prop('disabled', !isEnabled);
      }, this);
    },

    onQuestionRendered: function onQuestionRendered() {
      this.setReadyStatus();
    },

    clearValidationError: function clearValidationError() {
      this.$('.js-textinput-textbox').removeClass('has-error');
    },

    // Blank method for question to fill out when the question cannot be submitted
    onCannotSubmit: function onCannotSubmit() {
      this.showValidationError();
    },

    showValidationError: function showValidationError() {
      this.$('.js-textinput-textbox').addClass('has-error');
    },

    // This is important and should give the user feedback on how they answered the question
    // Normally done through ticks and crosses by adding classes
    showMarking: function showMarking() {
      if (!this.model.get('_canShowMarking')) return;

      this.model.get('_items').forEach(function (item, i) {
        var $item = this.$('.js-textinput-item').eq(i);
        $item.removeClass('is-correct is-incorrect').addClass(item._isCorrect ? 'is-correct' : 'is-incorrect');
      }, this);
    },

    // Used by the question view to reset the look and feel of the component.
    resetQuestion: function resetQuestion() {
      this.$('.js-textinput-textbox').prop('disabled', !this.model.get('_isEnabled')).val('');

      this.model.set({
        _isAtLeastOneCorrectSelection: false,
        _isCorrect: undefined });

    },

    showCorrectAnswer: function showCorrectAnswer() {

      if (this.model.get('_answers')) {

        var correctAnswers = this.model.get('_answers');
        this.model.get('_items').forEach(function (item, index) {
          this.$('.js-textinput-textbox').eq(index).val(correctAnswers[index][0]);
        }, this);

      } else {
        this.model.get('_items').forEach(function (item, index) {
          this.$('.js-textinput-textbox').eq(index).val(item._answers[0]);
        }, this);
      }

    },

    hideCorrectAnswer: function hideCorrectAnswer() {
      this.model.get('_items').forEach(function (item, index) {
        this.$('.js-textinput-textbox').eq(index).val(item.userAnswer);
      }, this);
    },

    onInputChanged: function onInputChanged(e) {
      var $input = $(e.target);
      this.model.setItemUserAnswer($input.parents('.js-textinput-item').index(), $input.val());
    } });



  return TextInputView;

});

define('components/adapt-contrib-textInput/js/textInputModel', [
'core/js/models/questionModel'],
function (QuestionModel) {

  var TextInputModel = QuestionModel.extend({

    init: function init() {
      QuestionModel.prototype.init.call(this);

      this.set('_genericAnswerIndexOffset', TextInputModel.genericAnswerIndexOffset);

      this.setupQuestionItemIndexes();
      this.checkCanSubmit();
    },

    setupQuestionItemIndexes: function setupQuestionItemIndexes() {
      this.get('_items').forEach(function (item, index) {

        if (item._index === undefined) item._index = index;
        if (item._answerIndex === undefined) item._answerIndex = -1;

      });
    },

    restoreUserAnswers: function restoreUserAnswers() {
      if (!this.get('_isSubmitted')) return;

      var userAnswer = this.get('_userAnswer');
      var genericAnswers = this.get('_answers');
      this.get('_items').forEach(function (item) {
        var answerIndex = userAnswer[item._index];
        if (answerIndex >= TextInputModel.genericAnswerIndexOffset) {
          item.userAnswer = genericAnswers[answerIndex - TextInputModel.genericAnswerIndexOffset];
          item._answerIndex = answerIndex;
        } else if (answerIndex > -1) {
          item.userAnswer = item._answers[answerIndex];
          item._answerIndex = answerIndex;
        } else {
          if (item.userAnswer === undefined) item.userAnswer = '******';
          item._answerIndex = -1;
        }
        if (item.userAnswer instanceof Array) item.userAnswer = item.userAnswer[0];
      });

      this.setQuestionAsSubmitted();
      this.markQuestion();
      this.setScore();
      this.setupFeedback();
    },

    setupRandomisation: function setupRandomisation() {
      if (!this.get('_isRandom') || !this.get('_isEnabled')) return;

      this.set('_items', _.shuffle(this.get('_items')));
    },

    // Use to check if the user is allowed to submit the question
    canSubmit: function canSubmit() {var _this91 = this;
      // can submit if every item has user input
      return this.get('_items').every(function (_ref6) {_newArrowCheck(this, _this91);var userAnswer = _ref6.userAnswer;return userAnswer;}.bind(this));
    },

    setItemUserAnswer: function setItemUserAnswer(itemIndex, userAnswer) {
      var item = this.get('_items')[itemIndex];
      item.userAnswer = userAnswer;
      this.checkCanSubmit();
    },

    //This preserve the state of the users answers for returning or showing the users answer
    storeUserAnswer: function storeUserAnswer() {
      var items = this.get('_items');

      this.isCorrect();

      var userAnswer = new Array(items.length);
      items.forEach(function (item, index) {
        userAnswer[item._index] = item._answerIndex;
      });
      this.set('_userAnswer', userAnswer);
    },

    isCorrect: function isCorrect() {
      if (this.get('_answers')) {
        this.markGenericAnswers();
      } else {
        this.markSpecificAnswers();
      }
      // do we have any _isCorrect == false?
      return !_.contains(_.pluck(this.get('_items'), '_isCorrect'), false);
    },

    isPartlyCorrect: function isPartlyCorrect() {
      return this.get('_isAtLeastOneCorrectSelection');
    },

    // Allows the learner to give answers into any input, ignoring the order.
    // (this excludes any inputs which have their own specific answers).
    markGenericAnswers: function markGenericAnswers() {
      var numberOfCorrectAnswers = 0;
      var correctAnswers = this.get('_answers').slice();
      var usedAnswerIndexes = [];

      this.get('_items').forEach(function (item) {
        correctAnswers.forEach(function (answerGroup, answerIndex) {
          if (_.indexOf(usedAnswerIndexes, answerIndex) > -1) return;

          if (this.checkAnswerIsCorrect(answerGroup, item.userAnswer) == false) return;

          usedAnswerIndexes.push(answerIndex);
          item._isCorrect = true;
          item._answerIndex = answerIndex + TextInputModel.genericAnswerIndexOffset;

          this.set({
            _numberOfCorrectAnswers: ++numberOfCorrectAnswers,
            _isAtLeastOneCorrectSelection: true });


        }, this);
        if (!item._isCorrect) item._isCorrect = false;
      }, this);
    },

    // Marks any items which have answers specific to it
    // (i.e. item has a _answers array)
    markSpecificAnswers: function markSpecificAnswers() {
      var numberOfCorrectAnswers = 0;
      this.get('_items').forEach(function (item) {
        if (!item._answers) return;
        var userAnswer = item.userAnswer || '';
        if (this.checkAnswerIsCorrect(item._answers, userAnswer)) {
          item._isCorrect = true;
          item._answerIndex = _.indexOf(item._answers, this.cleanupUserAnswer(userAnswer));
          this.set({
            _numberOfCorrectAnswers: ++numberOfCorrectAnswers,
            _isAtLeastOneCorrectSelection: true });

        } else {
          item._isCorrect = false;
          item._answerIndex = -1;
        }
      }, this);
    },

    checkAnswerIsCorrect: function checkAnswerIsCorrect(possibleAnswers, userAnswer) {
      var uAnswer = this.cleanupUserAnswer(userAnswer);
      var matched = possibleAnswers.filter(function (cAnswer) {
        return this.cleanupUserAnswer(cAnswer) == uAnswer;
      }, this);

      var answerIsCorrect = matched && matched.length > 0;
      if (answerIsCorrect) this.set('_hasAtLeastOneCorrectSelection', true);
      return answerIsCorrect;
    },

    cleanupUserAnswer: function cleanupUserAnswer(userAnswer) {
      if (this.get('_allowsAnyCase')) {
        userAnswer = userAnswer.toLowerCase();
      }
      if (this.get('_allowsPunctuation')) {
        userAnswer = userAnswer.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g, '');
        //remove any orphan double spaces and replace with single space (B & Q)->(B  Q)->(B Q)
        userAnswer = userAnswer.replace(/(  +)+/g, ' ');
      }
      // removes whitespace from beginning/end (leave any in the middle)
      return $.trim(userAnswer);
    },

    // Used to set the score based upon the _questionWeight
    setScore: function setScore() {
      var numberOfCorrectAnswers = this.get('_numberOfCorrectAnswers');
      var questionWeight = this.get('_questionWeight');
      var itemLength = this.get('_items').length;

      var score = questionWeight * numberOfCorrectAnswers / itemLength;

      this.set('_score', score);
    },

    resetUserAnswer: function resetUserAnswer() {
      this.get('_items').forEach(function (item) {
        item._isCorrect = false;
        item.userAnswer = '';
      });
    },

    /**
       * used by adapt-contrib-spoor to get the user's answers in the format required by the cmi.interactions.n.student_response data field
       * returns the user's answers as a string in the format 'answer1[,]answer2[,]answer3'
       * the use of [,] as an answer delimiter is from the SCORM 2004 specification for the fill-in interaction type
       */
    getResponse: function getResponse() {
      return _.pluck(this.get('_items'), 'userAnswer').join('[,]');
    },

    /**
       * used by adapt-contrib-spoor to get the type of this question in the format required by the cmi.interactions.n.type data field
       */
    getResponseType: function getResponseType() {
      return 'fill-in';
    } },
  {
    genericAnswerIndexOffset: 65536 });


  return TextInputModel;

});

define('components/adapt-contrib-textInput/js/adapt-contrib-textInput', [
'core/js/adapt',
'./textInputView',
'./textInputModel'],
function (Adapt, TextInputView, TextInputModel) {

  return Adapt.register('textinput', {
    view: TextInputView,
    model: TextInputModel });


});

define('extensions/adapt-contrib-assessment/js/adapt-assessmentArticleView', [
'core/js/adapt',
'core/js/views/articleView'],
function (Adapt, AdaptArticleView) {

  var AssessmentView = {

    postRender: function postRender() {
      AdaptArticleView.prototype.postRender.call(this);
      if (this.model.isAssessmentEnabled()) {
        this._setupEventListeners();

        var config = this.model.getConfig();
        if (config && config._questions && config._questions._canShowMarking === false) {
          this.$el.addClass('has-no-marking');
        }
      }
      this.$el.addClass('is-assessment');
    },

    _setupEventListeners: function _setupEventListeners() {
      this.listenTo(Adapt, {
        'assessments:complete': this._onAssessmentComplete,
        'assessments:reset': this._onAssessmentReset,
        remove: this._onRemove });

    },

    _removeEventListeners: function _removeEventListeners() {
      this.stopListening(Adapt, {
        'assessments:complete': this._onAssessmentComplete,
        'assessments:reset': this._onAssessmentReset });

    },

    _onAssessmentComplete: function _onAssessmentComplete(state, model) {
      if (state.id != this.model.get('_assessment')._id) return;

      console.log('assessment complete', state, model);
    },

    _onAssessmentReset: function _onAssessmentReset(state, model) {
      if (state.id != this.model.get('_assessment')._id) return;

      console.log('assessment reset', state, model);

    },

    _onRemove: function _onRemove() {
      this._removeEventListeners();
    } };



  return AssessmentView;

});

define('extensions/adapt-contrib-assessment/js/adapt-assessmentQuestionBank', ['require'], function (require) {

  var QuestionBank = function QuestionBank(quizBankid, articleId, numQuestionBlocks, uniqueQuestions) {

    this._id = quizBankid;
    this._articleId = articleId;
    this._numQuestionBlocks = numQuestionBlocks;
    this._uniqueQuestions = uniqueQuestions;
    this.questionBlocks = [];
    this.unUsedQuestionBlocks = undefined;
    this.usedQuestionBlocks = [];

  };

  QuestionBank.prototype = {

    getID: function getID() {
      return this._id;
    },

    addBlock: function addBlock(block) {
      this.questionBlocks.push(block);
    },

    getRandomQuestionBlocks: function getRandomQuestionBlocks() {
      this.checkResetUnunsedBlocks();

      var questionBlocks = [];
      var usedQuestionBlocks = this.usedQuestionBlocks.slice(0);

      for (var i = 0; i < this._numQuestionBlocks; i++) {
        var question = this.getRandomQuestion();
        if (question !== undefined) {
          questionBlocks.push(question);
        } else {
          if (usedQuestionBlocks.length === 0) break;
          var index = Math.floor(Math.random() * (usedQuestionBlocks.length - 1));
          question = usedQuestionBlocks.splice(index, 1)[0];
          questionBlocks.push(question);
        }
      }

      return questionBlocks;
    },

    checkResetUnunsedBlocks: function checkResetUnunsedBlocks() {
      if (this.unUsedQuestionBlocks !== undefined && this._uniqueQuestions) return;

      this.unUsedQuestionBlocks = this.questionBlocks.slice(0);
    },

    getRandomQuestion: function getRandomQuestion() {
      if (this.unUsedQuestionBlocks !== undefined && this.unUsedQuestionBlocks.length < 1) {
        console.warn('assessment:' + this._articleId + ' No more unique questions for _assessment._quizBankID ' + this._id);
        return undefined;
      }

      var index = Math.round(Math.random() * (this.unUsedQuestionBlocks.length - 1));
      var questionBlock = this.unUsedQuestionBlocks[index];
      this.usedQuestionBlocks.push(questionBlock);

      this.unUsedQuestionBlocks.splice(index, 1);

      return questionBlock;
    } };



  return QuestionBank;

});

define('extensions/adapt-contrib-assessment/js/adapt-assessmentArticleModel', [
'core/js/adapt',
'./adapt-assessmentQuestionBank'],
function (Adapt, QuestionBank) {


  var givenIdCount = 0;
  var assessmentConfigDefaults = {
    _isEnabled: true,
    _questions: {
      _resetType: 'soft',
      _canShowFeedback: false,
      _canShowMarking: false,
      _canShowModelAnswer: false },

    _suppressMarking: false,
    _isPercentageBased: true,
    _scoreToPass: 100,
    _includeInTotalScore: true,
    _assessmentWeight: 1,
    _isResetOnRevisit: true,
    _reloadPageOnReset: true,
    _attempts: 'infinite',
    _allowResetIfPassed: false };


  var AssessmentModel = {

    // Private functions

    _postInitialize: function _postInitialize() {
      if (!this.isAssessmentEnabled()) return;

      var assessmentConfig = this.getConfig();

      _.extend(this, {
        _currentQuestionComponents: null,
        _originalChildModels: null,
        _questionBanks: null,
        _forceResetOnRevisit: false });


      var attemptsLeft;
      switch (assessmentConfig._attempts) {
        case 'infinite':case 0:case undefined:case -1:case null:
          attemptsLeft = 'infinite';
          break;
        default:
          attemptsLeft = assessmentConfig._attempts;
          break;}


      this.set({
        _currentQuestionComponentIds: [],
        _assessmentCompleteInSession: false,
        _attemptInProgress: false,
        _isAssessmentComplete: false,
        _numberOfQuestionsAnswered: 0,
        _lastAttemptScoreAsPercent: 0,
        _attempts: attemptsLeft,
        _attemptsLeft: attemptsLeft,
        _attemptsSpent: 0 });


      this.listenToOnce(Adapt, 'app:dataReady', this._onDataReady);
      this.listenTo(Adapt, 'remove', this._onRemove);

    },

    init: function init() {
      // save original children
      this._originalChildModels = this.getChildren().models;
      // collect all question components
      this._currentQuestionComponents = this.findDescendantModels('components', { where: { _isQuestionType: true } });
      this.set('_currentQuestionComponentIds', this._currentQuestionComponents.map(function (comp) {
        return comp.get('_id');
      }));

      this._setAssessmentOwnershipOnChildrenModels();

    },

    _setAssessmentOwnershipOnChildrenModels: function _setAssessmentOwnershipOnChildrenModels() {
      // mark all children components as belonging to an assessment
      var assessmentConfig = this.get('_assessment');
      var childConfig = {
        _isPartOfAssessment: true,
        _assessmentId: assessmentConfig._id };

      for (var i = 0, l = this._originalChildModels.length; i < l; i++) {
        var blockModel = this._originalChildModels[i];
        blockModel.set(childConfig);
        //make sure components are set to _isPartOfAssessment for plp checking
        blockModel.setOnChildren(childConfig);
      }
    },


    _onDataReady: function _onDataReady() {
      //register assessment
      Adapt.assessment.register(this);
    },

    _setupAssessmentData: function _setupAssessmentData(force, callback) {
      var assessmentConfig = this.getConfig();
      var state = this.getState();
      var shouldResetAssessment = !this.get('_attemptInProgress') && !state.isPass || force === true;
      var shouldResetQuestions = assessmentConfig._isResetOnRevisit && (state.allowResetIfPassed || !state.isPass) || force === true;

      if (shouldResetAssessment || shouldResetQuestions) {
        Adapt.trigger('assessments:preReset', this.getState(), this);
      }

      var quizModels;
      if (shouldResetAssessment) {
        this.set({
          _numberOfQuestionsAnswered: 0,
          _isAssessmentComplete: false,
          _assessmentCompleteInSession: false,
          _score: 0 });

        this.getChildren().models = this._originalChildModels;
        if (assessmentConfig._banks &&
        assessmentConfig._banks._isEnabled &&
        assessmentConfig._banks._split.length > 1) {

          quizModels = this._setupBankedAssessment();
        } else if (assessmentConfig._randomisation &&
        assessmentConfig._randomisation._isEnabled) {

          quizModels = this._setupRandomisedAssessment();
        }
      }

      if (!quizModels) {
        // leave the order as before, completed or not
        quizModels = this.getChildren().models;
      } else if (quizModels.length === 0) {
        quizModels = this.getChildren().models;
        console.warn('assessment: Not enough unique questions to create a fresh assessment, using last selection');
      }

      this.getChildren().models = quizModels;

      this._currentQuestionComponents = this.findDescendantModels('components', { where: { _isQuestionType: true } });
      this.set('_currentQuestionComponentIds', this._currentQuestionComponents.map(function (comp) {
        return comp.get('_id');
      }));

      if (shouldResetAssessment || shouldResetQuestions) {
        this._resetQuestions(function () {
          this.set('_attemptInProgress', true);
          Adapt.trigger('assessments:reset', this.getState(), this);

          finalise.apply(this);
        }.bind(this));
      } else {
        finalise.apply(this);
      }

      function finalise() {
        if (!state.isComplete) {
          this.set('_attemptInProgress', true);
        }

        this._overrideQuestionComponentSettings();
        this._setupQuestionListeners();
        this._checkNumberOfQuestionsAnswered();
        this._updateQuestionsState();

        Adapt.assessment.saveState();

        if (typeof callback == 'function') callback.apply(this);

        if (shouldResetAssessment || shouldResetQuestions) {
          Adapt.trigger('assessments:postReset', this.getState(), this);
        }
      }
    },

    _setupBankedAssessment: function _setupBankedAssessment() {
      var assessmentConfig = this.getConfig();

      this._setupBanks();

      // get random questions from banks
      var questionModels = [];
      for (var bankId in this._questionBanks) {
        if (this._questionBanks.hasOwnProperty(bankId)) {// skip over properties that were added to Array.prototype by the ES5-shim for IE8
          var questionBank = this._questionBanks[bankId];
          var questions = questionBank.getRandomQuestionBlocks();
          questionModels = questionModels.concat(questions);
        }
      }

      // if overall question order should be randomized
      if (assessmentConfig._banks._randomisation) {
        questionModels = _.shuffle(questionModels);
      }

      return questionModels;
    },

    _setupBanks: function _setupBanks() {
      var assessmentConfig = this.getConfig();
      var banks = assessmentConfig._banks._split.split(',');
      var bankId;

      this._questionBanks = [];

      // build fresh banks
      for (var i = 0, l = banks.length; i < l; i++) {
        var bank = banks[i];
        bankId = i + 1;
        var questionBank = new QuestionBank(bankId, this.get('_id'), bank, true);

        this._questionBanks[bankId] = questionBank;
      }

      //add blocks to banks
      var children = this.getChildren().models;
      for (var j = 0, count = children.length; j < count; j++) {
        var blockModel = children[j];
        var blockAssessmentConfig = blockModel.get('_assessment');
        if (!blockAssessmentConfig) continue;
        bankId = blockAssessmentConfig._quizBankID;
        this._questionBanks[bankId].addBlock(blockModel);
      }

    },

    _setupRandomisedAssessment: function _setupRandomisedAssessment() {
      var assessmentConfig = this.getConfig();

      var randomisationModel = assessmentConfig._randomisation;
      var blockModels = this.getChildren().models;

      var questionModels = _.shuffle(blockModels);

      if (randomisationModel._blockCount > 0) {
        questionModels = questionModels.slice(0, randomisationModel._blockCount);
      }

      return questionModels;
    },

    _overrideQuestionComponentSettings: function _overrideQuestionComponentSettings() {
      var newSettings = this._getMarkingSettings();

      // Add any additional setting overrides here
      var questionConfig = this.getConfig()._questions;
      if (questionConfig.hasOwnProperty('_canShowFeedback')) {
        newSettings._canShowFeedback = questionConfig._canShowFeedback;
      }

      if (!_.isEmpty(newSettings)) {
        for (var i = 0, l = this._currentQuestionComponents.length; i < l; i++) {
          this._currentQuestionComponents[i].set(newSettings, { pluginName: '_assessment' });
        }
      }
    },

    _setupQuestionListeners: function _setupQuestionListeners() {
      var questionComponents = this._currentQuestionComponents;
      for (var i = 0, l = questionComponents.length; i < l; i++) {
        var question = questionComponents[i];
        if (question.get('_isInteractionComplete')) continue;
        this.listenTo(question, 'change:_isInteractionComplete', this._onQuestionCompleted);
      }
    },

    _checkNumberOfQuestionsAnswered: function _checkNumberOfQuestionsAnswered() {
      var questionComponents = this._currentQuestionComponents;
      var numberOfQuestionsAnswered = 0;
      for (var i = 0, l = questionComponents.length; i < l; i++) {
        var question = questionComponents[i];
        if (question.get('_isInteractionComplete')) {
          numberOfQuestionsAnswered++;
        }
      }
      this.set('_numberOfQuestionsAnswered', numberOfQuestionsAnswered);
    },

    _removeQuestionListeners: function _removeQuestionListeners() {
      var questionComponents = this._currentQuestionComponents;
      if (!questionComponents) return;
      for (var i = 0, l = questionComponents.length; i < l; i++) {
        var question = questionComponents[i];
        this.stopListening(question, 'change:_isInteractionComplete', this._onQuestionCompleted);
      }
    },

    _onQuestionCompleted: function _onQuestionCompleted(questionModel, value) {
      if (value === false) return;
      if (!questionModel.get('_isInteractionComplete')) return;

      var numberOfQuestionsAnswered = this.get('_numberOfQuestionsAnswered');
      numberOfQuestionsAnswered++;
      this.set('_numberOfQuestionsAnswered', numberOfQuestionsAnswered);

      this._updateQuestionsState();
      Adapt.assessment.saveState();

      this._checkAssessmentComplete();
    },

    _checkAssessmentComplete: function _checkAssessmentComplete() {
      var numberOfQuestionsAnswered = this.get('_numberOfQuestionsAnswered');

      var allQuestionsAnswered = numberOfQuestionsAnswered >= this._currentQuestionComponents.length;
      if (!allQuestionsAnswered) return;

      this._onAssessmentComplete();
    },

    _onAssessmentComplete: function _onAssessmentComplete() {
      var assessmentConfig = this.getConfig();

      this.set('_attemptInProgress', false);
      this._spendAttempt();

      var scoreAsPercent = this._getScoreAsPercent();
      var score = this._getScore();
      var maxScore = this._getMaxScore();

      this.set({
        _scoreAsPercent: scoreAsPercent,
        _score: score,
        _maxScore: maxScore,
        _lastAttemptScoreAsPercent: scoreAsPercent,
        _assessmentCompleteInSession: true,
        _isAssessmentComplete: true });


      this._updateQuestionsState();

      this._checkIsPass();

      this._removeQuestionListeners();

      if (this._isMarkingSuppressionEnabled() && !this._isAttemptsLeft()) {
        _.defer(function () {
          this._overrideMarkingSettings();
          this._refreshQuestions();
        }.bind(this));
      }

      Adapt.trigger('assessments:complete', this.getState(), this);
    },

    _updateQuestionsState: function _updateQuestionsState() {
      var questions = [];

      var questionComponents = this._currentQuestionComponents;
      for (var i = 0, l = questionComponents.length; i < l; i++) {
        var questionComponent = questionComponents[i];

        var questionModel = {
          _id: questionComponent.get('_id'),
          _isCorrect: questionComponent.get('_isCorrect') === undefined ? null : questionComponent.get('_isCorrect') };


        //build array of questions
        questions.push(questionModel);

      }

      this.set('_questions', questions);
    },

    _checkIsPass: function _checkIsPass() {
      var assessmentConfig = this.getConfig();

      var isPercentageBased = assessmentConfig._isPercentageBased;
      var scoreToPass = assessmentConfig._scoreToPass;

      var scoreAsPercent = this.get('_scoreAsPercent');
      var score = this.get('_score');

      var isPass = isPercentageBased ? scoreAsPercent >= scoreToPass : score >= scoreToPass;

      this.set('_isPass', isPass);
    },

    _getMarkingSettings: function _getMarkingSettings() {
      var markingSettings = {};

      if (this._shouldSuppressMarking()) {
        markingSettings = {
          _canShowMarking: false,
          _canShowModelAnswer: false };

      } else {
        var questionConfig = this.getConfig()._questions;

        if (questionConfig.hasOwnProperty('_canShowModelAnswer')) {
          markingSettings._canShowModelAnswer = questionConfig._canShowModelAnswer;
        }

        if (questionConfig.hasOwnProperty('_canShowMarking')) {
          markingSettings._canShowMarking = questionConfig._canShowMarking;
        }
      }

      return markingSettings;
    },

    _overrideMarkingSettings: function _overrideMarkingSettings() {
      var newMarkingSettings = this._getMarkingSettings();
      for (var i = 0, l = this._currentQuestionComponents.length; i < l; i++) {
        this._currentQuestionComponents[i].set(newMarkingSettings, {
          pluginName: '_assessment' });

      }
    },

    _refreshQuestions: function _refreshQuestions() {
      for (var a = 0, b = this._currentQuestionComponents.length; a < b; a++) {
        var question = this._currentQuestionComponents[a];
        question.refresh();
      }
    },

    _shouldSuppressMarking: function _shouldSuppressMarking() {
      return this._isMarkingSuppressionEnabled() && this._isAttemptsLeft();
    },

    _isMarkingSuppressionEnabled: function _isMarkingSuppressionEnabled() {
      var assessmentConfig = this.getConfig();
      return assessmentConfig._suppressMarking;
    },

    _isAttemptsLeft: function _isAttemptsLeft() {
      if (this.get('_isAssessmentComplete') && this.get('_isPass')) return false;

      if (this.get('_attemptsLeft') === 0) return false;

      return true;
    },

    _spendAttempt: function _spendAttempt() {
      if (!this._isAttemptsLeft()) return false;

      var attemptsSpent = this.get('_attemptsSpent');
      this.set('_attemptsSpent', ++attemptsSpent);

      if (this.get('_attempts') == 'infinite') return true;

      var attemptsLeft = this.get('_attemptsLeft');
      this.set('_attemptsLeft', --attemptsLeft);

      return true;
    },

    _getScore: function _getScore() {
      var score = 0;
      var questionComponents = this._currentQuestionComponents;
      for (var i = 0, l = questionComponents.length; i < l; i++) {
        var question = questionComponents[i];
        if (question.get('_isCorrect') &&
        question.get('_questionWeight')) {
          score += question.get('_questionWeight');
        }
      }
      return score;
    },

    _getMaxScore: function _getMaxScore() {
      var maxScore = 0;
      var questionComponents = this._currentQuestionComponents;
      for (var i = 0, l = questionComponents.length; i < l; i++) {
        var question = questionComponents[i];
        if (question.get('_questionWeight')) {
          maxScore += question.get('_questionWeight');
        }
      }
      return maxScore;
    },

    _getScoreAsPercent: function _getScoreAsPercent() {
      if (this._getMaxScore() === 0) return 0;
      return Math.round(this._getScore() / this._getMaxScore() * 100);
    },

    _getLastAttemptScoreAsPercent: function _getLastAttemptScoreAsPercent() {
      return this.get('_lastAttemptScoreAsPercent');
    },

    _checkReloadPage: function _checkReloadPage() {
      if (!this.canResetInPage()) return false;

      var parentId = this.getParent().get('_id');
      var currentLocation = Adapt.location._currentId;

      //check if on assessment page and should rerender page
      if (currentLocation != parentId) return false;
      if (!this.get('_isReady')) return false;

      return true;
    },

    _reloadPage: function _reloadPage(callback) {
      this._forceResetOnRevisit = true;

      this.listenToOnce(Adapt, 'pageView:ready', callback);

      _.delay(function () {
        Backbone.history.navigate('#/id/' + Adapt.location._currentId, { replace: true, trigger: true });
      }, 250);
    },

    _resetQuestions: function _resetQuestions(callback) {
      var assessmentConfig = this.getConfig();
      var syncIterations = 1; // number of synchronous iterations to perform
      var i = 0,qs = this._currentQuestionComponents,len = qs.length;

      function step() {
        for (var j = 0, count = Math.min(syncIterations, len - i); j < count; i++, j++) {
          var question = qs[i];
          question.reset(assessmentConfig._questions._resetType, true);
        }

        i == len ? callback() : setTimeout(step);
      }

      step();
    },

    _onRemove: function _onRemove() {
      this._removeQuestionListeners();
    },

    _setCompletionStatus: function _setCompletionStatus() {
      this.set({
        _isComplete: true,
        _isInteractionComplete: true });

    },

    _checkIfQuestionsWereRestored: function _checkIfQuestionsWereRestored() {
      if (this.get('_assessmentCompleteInSession')) return;
      if (!this.get('_isAssessmentComplete')) return;

      //fix for courses that do not remember the user selections
      //force assessment to reset if user revisits an assessment page in a new session which is completed
      var wereQuestionsRestored = true;

      var questions = this.get('_questions');
      for (var i = 0, l = questions.length; i < l; i++) {
        var question = questions[i];
        var questionModel = Adapt.findById(question._id);
        if (!questionModel.get('_isSubmitted')) {
          wereQuestionsRestored = false;
          break;
        }
      }

      if (!wereQuestionsRestored) {
        this.set('_assessmentCompleteInSession', true);
        return true;
      }

      return false;
    },


    // Public Functions

    isAssessmentEnabled: function isAssessmentEnabled() {
      if (this.get('_assessment') &&
      this.get('_assessment')._isEnabled) return true;
      return false;
    },

    canResetInPage: function canResetInPage() {
      var assessmentConfig = this.getConfig();
      if (assessmentConfig._reloadPageOnReset === false) return false;
      return true;
    },

    reset: function reset(force, callback) {

      if (this._isResetInProgress) {
        // prevent multiple resets from executing.
        // keep callbacks in queue for when current reset is finished
        this.once('reset', function () {
          this._isResetInProgress = false;
          if (typeof callback == 'function') {
            callback(true);
          }
        });
        return;
      }

      var assessmentConfig = this.getConfig();

      //check if forcing reset via page revisit or force parameter
      force = this._forceResetOnRevisit || force === true;
      this._forceResetOnRevisit = false;

      var isPageReload = this._checkReloadPage();

      //stop resetting if not complete or not allowed
      if (this.get('_assessmentCompleteInSession') &&
      !assessmentConfig._isResetOnRevisit &&
      !isPageReload &&
      !force) {
        if (typeof callback == 'function') {
          callback(false);
        }
        return false;
      }

      //check if new session and questions not restored
      var wereQuestionsRestored = this._checkIfQuestionsWereRestored();
      force = force || wereQuestionsRestored;
      // the assessment is going to be reset so we must reset attempts
      // otherwise assessment may not be set up properly in next session
      if (force && !this._isAttemptsLeft()) {
        this.set({
          _attemptsLeft: this.get('_attempts'),
          _attemptsSpent: 0 });

      }

      var allowResetIfPassed = this.get('_assessment')._allowResetIfPassed;
      //stop resetting if no attempts left and allowResetIfPassed is false
      if (!this._isAttemptsLeft() && !force && !allowResetIfPassed) {
        if (typeof callback == 'function') callback(false);
        return false;
      }

      if (!isPageReload) {
        // only perform this section when not attempting to reload the page
        // wait for reset to trigger
        this.once('reset', function () {
          this._isResetInProgress = false;
          if (typeof callback == 'function') {
            callback(true);
          }
        });
        this._isResetInProgress = true;
        // perform asynchronous reset
        this._setupAssessmentData(force, function () {
          this.trigger('reset');
        });
      } else {
        this._reloadPage(function () {
          if (typeof callback == 'function') {
            callback(true);
          }
        });
      }

      return true;
    },

    getSaveState: function getSaveState() {var _this92 = this;
      var state = this.getState();
      var blocks;
      var cfg = this.getConfig();
      var banksActive = cfg._banks && cfg._banks._isEnabled && cfg._banks._split.length > 1;
      var randomisationActive = cfg._randomisation && cfg._randomisation._isEnabled;

      if (!banksActive && !randomisationActive) {
        // include presentation blocks in save state so that blocks without questions aren't removed
        blocks = this.findDescendantModels('block');
      } else {
        blocks = state.questions.map(function (question) {_newArrowCheck(this, _this92);return Adapt.findById(question._id).getParent();}.bind(this));
      }
      blocks = blocks.filter(function (block) {_newArrowCheck(this, _this92);
        var trackingId = block.get('_trackingId');
        return Number.isInteger(trackingId) && trackingId >= 0;
      }.bind(this));
      var blockTrackingIds = blocks.map(function (block) {_newArrowCheck(this, _this92);return block.get('_trackingId');}.bind(this));
      var blockCompletion = blocks.map(function (block) {var _this93 = this;_newArrowCheck(this, _this92);
        var questions = block.findDescendantModels('question');
        return questions.map(function (question) {_newArrowCheck(this, _this93);return question.get('_isCorrect') || false;}.bind(this));
      }.bind(this));
      var blockData = [blockTrackingIds, blockCompletion];

      var saveState = [
      state.isComplete ? 1 : 0,
      state.attemptsSpent,
      state.maxScore || 0,
      state.score,
      state.attemptInProgress ? 1 : 0];


      var dataPackage = [saveState, blockData];

      return dataPackage;
    },

    setRestoreState: function setRestoreState(dataPackage) {var _this94 = this;
      var restoreState = dataPackage[0];
      var blockData = dataPackage[1];
      var id;
      var isComplete = restoreState[0] == 1 ? true : false;
      var attempts = this.get('_attempts');
      var attemptsSpent = restoreState[1];
      var maxScore = restoreState[2];
      var score = restoreState[3];
      var attemptInProgress = restoreState[4] == 1 ? true : false;
      var scoreAsPercent;

      var blocks = blockData[0].map(function (trackingId) {_newArrowCheck(this, _this94);return Adapt.data.findWhere({ _trackingId: trackingId });}.bind(this));

      if (blocks.length) {
        this.getChildren().models = blocks;
      }

      this.set({
        _isAssessmentComplete: isComplete,
        _assessmentCompleteInSession: false,
        _attemptsSpent: attemptsSpent,
        _attemptInProgress: attemptInProgress,
        _attemptsLeft: attempts === 'infinite' ? attempts : attempts - attemptsSpent,
        _maxScore: maxScore || this._getMaxScore(),
        _score: score || 0 });


      if (score) {
        scoreAsPercent = Math.round(score / maxScore * 100);
      } else {
        scoreAsPercent = 0;
      }

      this.set({
        _scoreAsPercent: scoreAsPercent,
        _lastAttemptScoreAsPercent: scoreAsPercent });


      var questions = [];
      blocks.forEach(function (block, blockIndex) {var _this95 = this;_newArrowCheck(this, _this94);
        var blockQuestions = block.findDescendantModels('question');
        blockQuestions.forEach(function (question, questionIndex) {_newArrowCheck(this, _this95);
          questions.push({
            _id: question.get('_id'),
            _isCorrect: blockData[1][blockIndex][questionIndex] });

        }.bind(this));
      }.bind(this));
      this.set('_questions', questions);

      if (isComplete) this._checkIsPass();

      Adapt.trigger('assessments:restored', this.getState(), this);

    },

    getState: function getState() {
      //return the current state of the assessment
      //create snapshot of values so as not to create memory leaks
      var assessmentConfig = this.getConfig();

      var state = {
        id: assessmentConfig._id,
        type: 'article-assessment',
        pageId: this.getParent().get('_id'),
        articleId: this.get('_id'),
        isEnabled: assessmentConfig._isEnabled,
        isComplete: this.get('_isAssessmentComplete'),
        isPercentageBased: assessmentConfig._isPercentageBased,
        scoreToPass: assessmentConfig._scoreToPass,
        score: this.get('_score'),
        scoreAsPercent: this.get('_scoreAsPercent'),
        maxScore: this.get('_maxScore'),
        isPass: this.get('_isPass'),
        includeInTotalScore: assessmentConfig._includeInTotalScore,
        assessmentWeight: assessmentConfig._assessmentWeight,
        attempts: this.get('_attempts'),
        attemptsSpent: this.get('_attemptsSpent'),
        attemptsLeft: this.get('_attemptsLeft'),
        attemptInProgress: this.get('_attemptInProgress'),
        lastAttemptScoreAsPercent: this.get('_lastAttemptScoreAsPercent'),
        questions: this.get('_questions'),
        resetType: assessmentConfig._questions._resetType,
        allowResetIfPassed: assessmentConfig._allowResetIfPassed,
        questionModels: new Backbone.Collection(this._currentQuestionComponents) };


      return state;
    },

    getConfig: function getConfig() {
      var assessmentConfig = this.get('_assessment');

      if (!assessmentConfig) {
        assessmentConfig = $.extend(true, {}, assessmentConfigDefaults);
      } else {
        assessmentConfig = $.extend(true, {}, assessmentConfigDefaults, assessmentConfig);
      }

      if (assessmentConfig._id === undefined) {
        assessmentConfig._id = 'givenId' + givenIdCount++;
      }

      this.set('_assessment', assessmentConfig);

      return assessmentConfig;
    } };



  return AssessmentModel;

});

define('extensions/adapt-contrib-assessment/js/assessment', [
'core/js/adapt'],
function (Adapt) {

  /*
                   * Here we setup a registry for all assessments
                   */
  var assessmentsConfigDefaults = {
    _isPercentageBased: true,
    _scoreToPass: 100,
    _isDefaultsLoaded: true };


  Adapt.assessment = _.extend({

    // Private functions

    _assessments: _.extend([], {
      _byPageId: {},
      _byAssessmentId: {} }),


    initialize: function initialize() {
      this.listenTo(Adapt, {
        'assessments:complete': this._onAssessmentsComplete,
        'router:location': this._checkResetAssessmentsOnRevisit,
        'router:plugin': this._handleRoute,
        'app:dataReady': this._onDataReady });

    },

    _onAssessmentsComplete: function _onAssessmentsComplete(state) {
      var assessmentId = state.id;

      state.isComplete = true;

      if (assessmentId === undefined) return;

      if (!this._getStateByAssessmentId(assessmentId)) {
        Adapt.log.warn('assessments: state was not registered when assessment was created');
      }

      this.saveState();

      this._setPageProgress();

      this._checkAssessmentsComplete();

    },

    _restoreModelState: function _restoreModelState(assessmentModel) {

      if (!this._saveStateModel) {
        this._saveStateModel = Adapt.offlineStorage.get('a');
      }
      if (this._saveStateModel) {
        var state = assessmentModel.getState();
        if (this._saveStateModel[state.id]) {
          assessmentModel.setRestoreState(Adapt.offlineStorage.deserialize(this._saveStateModel[state.id]));
        }
      }

    },

    /*
        * Allow navigating to an assessment via the URL.
        */
    _handleRoute: function _handleRoute(plugin, id) {
      if (plugin !== 'assessment' && plugin !== 'article-assessment' || id === undefined) {
        return;
      }

      // Check the 'id' passed is that of an article.
      if (!Adapt.findById(id)) {
        // The 'id' passed may have been the assessment _id/name, not the article _id.
        var assessment = Adapt.assessment._assessments._byAssessmentId[id];
        if (assessment) {
          // Set 'id' to the article _id.
          id = assessment.get('_id');
        } else {
          Adapt.log.warn('Assessment not found with _id: ' + id);
          return;
        }
      }

      _.defer(function () {
        // Defer this call so that the router's _canNavigate flag is true.
        Backbone.history.navigate('#/id/' + id, { trigger: true, replace: true });
      });
    },

    _checkResetAssessmentsOnRevisit: function _checkResetAssessmentsOnRevisit(toObject) {
      /*
                                                                                          * Here we hijack router:location to reorganise the assessment blocks
                                                                                          * this must happen before trickle listens to block completion
                                                                                          */
      if (toObject._contentType !== 'page') return;

      // initialize assessment on page visit before pageView:preRender (and trickle)
      var pageAssessmentModels = this._getAssessmentByPageId(toObject._currentId);
      if (pageAssessmentModels === undefined) return;

      /*
                                                       * Here we further hijack the router to ensure the asynchronous assessment
                                                       * reset completes before routing completes
                                                       */
      Adapt.wait.for(function resetAllAssessments(allAssessmentHaveReset) {

        var numberOfAssessments = pageAssessmentModels.length;
        var numberOfResetAssessments = 0;
        var forceAssessmentReset = false;

        pageAssessmentModels.forEach(function (model) {

          model.reset(forceAssessmentReset, function () {

            numberOfResetAssessments++;
            var haveAllModelsReset = numberOfResetAssessments === numberOfAssessments;
            if (!haveAllModelsReset) {
              return;
            }

            allAssessmentHaveReset();

          });

        });

      });

      this._setPageProgress();
    },

    _onDataReady: function _onDataReady() {
      this._assessments = _.extend([], {
        _byPageId: {},
        _byAssessmentId: {} });


      this._restoredCount = 0;
    },


    _checkAssessmentsComplete: function _checkAssessmentsComplete() {
      var allAssessmentsComplete = true;
      var assessmentToPostBack = 0;
      var states = this._getStatesByAssessmentId();

      var assessmentStates = [];

      for (var id in states) {
        var state = states[id];
        if (!state.includeInTotalScore) continue;
        if (!state.isComplete) {
          allAssessmentsComplete = false;
          break;
        }
        assessmentToPostBack++;
        assessmentStates.push(state);
      }

      if (!allAssessmentsComplete || assessmentToPostBack === 0) return false;

      if (assessmentToPostBack === 1) {
        this._setupSingleAssessmentConfiguration(assessmentStates[0]);
      }

      _.defer(function () {
        Adapt.trigger('assessment:complete', this.getState());
      }.bind(this));

      return true;
    },

    _setupSingleAssessmentConfiguration: function _setupSingleAssessmentConfiguration(assessmentState) {
      var assessmentsConfig = Adapt.course.get('_assessment');
      $.extend(true, assessmentsConfig, {
        _isPercentageBased: assessmentState.isPercentageBased,
        _scoreToPass: assessmentState.scoreToPass });

      Adapt.course.set('_assessment', assessmentsConfig);
    },

    _getAssessmentByPageId: function _getAssessmentByPageId(pageId) {
      return this._assessments._byPageId[pageId];
    },

    _getStateByAssessmentId: function _getStateByAssessmentId(assessmentId) {
      if (assessmentId === undefined) {
        return null;
      }

      return this._assessments._byAssessmentId[assessmentId].getState();
    },

    _getStatesByAssessmentId: function _getStatesByAssessmentId() {
      var states = {};
      for (var i = 0, l = this._assessments.length; i < l; i++) {
        var assessmentModel = this._assessments[i];
        if (!assessmentModel.get('_isAvailable')) continue;
        var state = assessmentModel.getState();
        states[state.id] = state;
      }
      return states;
    },

    _setPageProgress: function _setPageProgress() {
      // set _subProgressTotal and _subProgressComplete on pages that have assessment progress indicator requirements

      for (var k in this._assessments._byPageId) {

        var assessments = this._assessments._byPageId[k];

        var assessmentsTotal = assessments.length;
        var assessmentsPassed = 0;

        for (var i = 0, l = assessments.length; i < l; i++) {
          var assessmentState = assessments[i].getState();

          if (assessmentState.includeInTotalScore && !assessmentState.isPass) continue;

          if (assessmentState.isComplete) {
            assessmentsPassed++;
          }
        }

        try {
          var pageModel = Adapt.findById(k);
          pageModel.set({
            _subProgressTotal: assessmentsTotal,
            _subProgressComplete: assessmentsPassed });

        } catch (e) {

        }

      }
    },

    _addToAssessmentIdMap: function _addToAssessmentIdMap(id, model) {
      if (id === undefined) {
        Adapt.log.warn('An assessment has been registered with an undefined value for "_id"');
        return;
      }

      if (id === '') {
        Adapt.log.warn('An assessment has been registered with an empty value for "_id"');
      }

      if (!this._assessments._byAssessmentId[id]) {
        this._assessments._byAssessmentId[id] = model;
      } else {
        Adapt.log.warn('An assessment with an _id of "' + id + '" already exists!');
      }
    },

    _setupQuestionNumbering: function _setupQuestionNumbering() {
      var getRelatedQuestions = function getRelatedQuestions(data) {
        var currentAssessmentId = data._assessmentId;
        var currentAssessment = Adapt.assessment.get(currentAssessmentId);
        return currentAssessment.getState().questions;
      };

      Handlebars.registerHelper('questionNumber', function getQuestionNumber() {
        var data = this.view ? this.view.model.toJSON() : this;
        if (!data._isPartOfAssessment) return;

        var related = _.pluck(getRelatedQuestions(data), '_id');

        return related.indexOf(data._id) + 1;
      });

      Handlebars.registerHelper('questionCount', function getTotalQuestions() {
        var data = this.view ? this.view.model.toJSON() : this;
        if (!data._isPartOfAssessment) return;
        return getRelatedQuestions(data).length;
      });
    },

    // Public functions

    register: function register(assessmentModel) {
      var state = assessmentModel.getState();
      var assessmentId = state.id;
      var pageId = state.pageId;

      if (this._assessments._byPageId[pageId] === undefined) {
        this._assessments._byPageId[pageId] = [];
      }

      this._assessments._byPageId[pageId].push(assessmentModel);

      this._addToAssessmentIdMap(assessmentId, assessmentModel);

      this._assessments.push(assessmentModel);

      this._restoreModelState(assessmentModel);
      this._restoredCount++;

      Adapt.trigger('assessments:register', state, assessmentModel);

      this._setPageProgress();

      this._setupQuestionNumbering();

      if (this._restoredCount === this._assessments.length) {
        // Since all assessments have been stored, broadcast an
        // event which has the collated state.
        Adapt.trigger('assessment:restored', this.getState());
      }
    },

    get: function get(id) {
      if (id === undefined) {
        return this._assessments.slice(0);
      } else {
        return this._assessments._byAssessmentId[id];
      }
    },

    saveState: function saveState() {

      this._saveStateModel = {};
      for (var i = 0, assessmentModel; assessmentModel = this._assessments[i++];) {
        var state = assessmentModel.getState();
        this._saveStateModel[state.id] = Adapt.offlineStorage.serialize(assessmentModel.getSaveState());
      }

      Adapt.offlineStorage.set('a', this._saveStateModel);
    },

    getConfig: function getConfig() {
      var assessmentsConfig = Adapt.course.get('_assessment');

      if (assessmentsConfig && assessmentsConfig._isDefaultsLoaded) {
        return assessmentsConfig;
      }

      if (assessmentsConfig === undefined) {
        assessmentsConfig = $.extend(true, {}, assessmentsConfigDefaults);
      } else {
        assessmentsConfig = $.extend(true, {}, assessmentsConfigDefaults, assessmentsConfig);
      }

      Adapt.course.set('_assessment', assessmentsConfig);

      return assessmentsConfig;
    },

    getState: function getState() {
      var assessmentsConfig = this.getConfig();

      var score = 0;
      var maxScore = 0;
      var isPass = false;
      var totalAssessments = 0;

      var states = this._getStatesByAssessmentId();

      var assessmentsComplete = 0;

      for (var id in states) {
        var state = states[id];
        if (!state.includeInTotalScore) continue;
        if (state.isComplete) assessmentsComplete++;
        totalAssessments++;
        maxScore += state.maxScore / state.assessmentWeight;
        score += state.score / state.assessmentWeight;
      }

      var isComplete = assessmentsComplete == totalAssessments;

      var scoreAsPercent = Math.round(score / maxScore * 100);

      if ((assessmentsConfig._scoreToPass || 100) && isComplete) {
        if (assessmentsConfig._isPercentageBased !== false) {
          if (scoreAsPercent >= assessmentsConfig._scoreToPass) isPass = true;
        } else {
          if (score >= assessmentsConfig._scoreToPass) isPass = true;
        }
      }

      return {
        isComplete: isComplete,
        isPercentageBased: assessmentsConfig._isPercentageBased,
        isPass: isPass,
        scoreAsPercent: scoreAsPercent,
        maxScore: maxScore,
        score: score,
        scoreToPass: assessmentsConfig._scoreToPass,
        assessmentsComplete: assessmentsComplete,
        assessments: totalAssessments };

    } },

  Backbone.Events);

  Adapt.assessment.initialize();

});

define('extensions/adapt-contrib-assessment/js/adapt-assessmentArticleExtension', [
'core/js/views/articleView',
'core/js/models/articleModel',
'./adapt-assessmentArticleView',
'./adapt-assessmentArticleModel',
'./assessment'],
function (ArticleView, ArticleModel, AdaptAssessmentArticleView, AdaptAssessmentArticleModel) {

  /*
                                                                                                * Here we are extending the articleView and articleModel in Adapt.
                                                                                                * This is to accomodate the assessment functionality on the article.
                                                                                                * The advantage of this method is that the assessment behaviour can utilize all of the predefined article behaviour in both the view and the model.
                                                                                                */

  //Extends core/js/views/articleView.js
  var ArticleViewInitialize = ArticleView.prototype.initialize;
  ArticleView.prototype.initialize = function (options) {
    if (this.model.get('_assessment') && this.model.get('_assessment')._isEnabled === true) {
      //extend the articleView with new functionality
      _.extend(this, AdaptAssessmentArticleView);
    }
    //initialize the article in the normal manner
    return ArticleViewInitialize.apply(this, arguments);
  };

  //Extends core/js/models/articleModel.js
  var ArticleModelInitialize = ArticleModel.prototype.initialize;
  ArticleModel.prototype.initialize = function (options) {
    if (this.get('_assessment') && this.get('_assessment')._isEnabled === true) {
      //extend the articleModel with new functionality
      _.extend(this, AdaptAssessmentArticleModel);

      //initialize the article in the normal manner
      var returnValue = ArticleModelInitialize.apply(this, arguments);

      //initialize assessment article
      this._postInitialize();

      return returnValue;
    }

    //initialize the article in the normal manner if no assessment
    return ArticleModelInitialize.apply(this, arguments);
  };

});

define('extensions/adapt-contrib-bookmarking/js/adapt-contrib-bookmarking', [
'core/js/adapt'],
function (Adapt) {

  var Bookmarking = Backbone.Controller.extend({

    bookmarkLevel: null,
    watchViewIds: null,
    watchViews: [],
    restoredLocationID: null,
    currentLocationID: null,

    initialize: function initialize() {
      this.listenToOnce(Adapt, 'router:location', this.onAdaptInitialize);
    },

    onAdaptInitialize: function onAdaptInitialize() {
      if (!this.checkIsEnabled()) return;
      this.setupEventListeners();
      this.checkRestoreLocation();
    },

    checkIsEnabled: function checkIsEnabled() {
      var courseBookmarkModel = Adapt.course.get('_bookmarking');
      if (!courseBookmarkModel || !courseBookmarkModel._isEnabled) return false;
      if (!Adapt.offlineStorage) return false;
      return true;
    },

    setupEventListeners: function setupEventListeners() {
      this._onScroll = _.debounce(this.checkLocation.bind(this), 1000);
      this.listenTo(Adapt, {
        'menuView:ready': this.setupMenu,
        'pageView:preRender': this.setupPage });

    },

    checkRestoreLocation: function checkRestoreLocation() {
      this.restoredLocationID = Adapt.offlineStorage.get('location');

      if (!this.restoredLocationID || this.restoredLocationID === 'undefined') return;

      this.listenToOnce(Adapt, 'pageView:ready menuView:ready', this.restoreLocation);
    },

    restoreLocation: function restoreLocation() {
      _.defer(function () {
        this.stopListening(Adapt, 'pageView:ready menuView:ready', this.restoreLocation);

        if (this.restoredLocationID === Adapt.location._currentId || !Adapt.findById(this.restoredLocationID)) {
          return;
        }
        var locationOnscreen = $('.' + this.restoredLocationID).onscreen();
        var isLocationOnscreen = locationOnscreen && locationOnscreen.percentInview > 0;
        var isLocationFullyInview = locationOnscreen && locationOnscreen.percentInview === 100;
        if (isLocationOnscreen && isLocationFullyInview) {
          return;
        }

        if (Adapt.course.get('_bookmarking')._showPrompt === false) {
          this.navigateToPrevious();
          return;
        }
        this.showPrompt();

      }.bind(this));
    },

    showPrompt: function showPrompt() {
      var courseBookmarkModel = Adapt.course.get('_bookmarking');
      var buttons = courseBookmarkModel._buttons || { yes: 'Yes', no: 'No' };

      this.listenToOnce(Adapt, {
        'bookmarking:continue': this.navigateToPrevious,
        'bookmarking:cancel': this.navigateCancel });


      var promptObject = {
        title: courseBookmarkModel.title,
        body: courseBookmarkModel.body,
        _classes: 'is-bookmarking',
        _prompts: [
        {
          promptText: buttons.yes || 'Yes',
          _callbackEvent: 'bookmarking:continue' },

        {
          promptText: buttons.no || 'No',
          _callbackEvent: 'bookmarking:cancel' }],


        _showIcon: true };


      var accessibility = Adapt.config.get('_accessibility');
      if (!accessibility || !accessibility._isActive) {
        Adapt.trigger('notify:prompt', promptObject);
        return;
      }

      $('.js-loading').show();
      $('#a11y-focuser').focus();
      $('body').attr('aria-hidden', true);
      _.delay(function () {
        $('.js-loading').hide();
        $('body').removeAttr('aria-hidden');
        Adapt.trigger('notify:prompt', promptObject);
      }, 3000);
    },

    navigateToPrevious: function navigateToPrevious() {
      _.defer( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee22() {var isSinglePage;return regeneratorRuntime.wrap(function _callee22$(_context22) {while (1) {switch (_context22.prev = _context22.next) {case 0:
                isSinglePage = Adapt.contentObjects.models.length == 1;_context22.next = 3;return (
                  Adapt.navigateToElement('.' + this.restoredLocationID, { trigger: true, replace: isSinglePage, duration: 400 }));case 3:case "end":return _context22.stop();}}}, _callee22, this);})).
      bind(this));

      this.stopListening(Adapt, 'bookmarking:cancel');
    },

    navigateCancel: function navigateCancel() {
      this.stopListening(Adapt, 'bookmarking:continue');
    },

    resetLocationID: function resetLocationID() {
      this.setLocationID('');
    },

    /**
        * if the learner navigates to the top-level menu, clear the stored bookmark
        * if it's a sub-menu, store the menu's id as the bookmark
        */
    setupMenu: function setupMenu(menuView) {
      var menuModel = menuView.model;

      if (!menuModel.get('_parentId')) {
        this.resetLocationID();
        return;
      }

      this.setLocationID(menuModel.get('_id'));
    },

    /**
        * Calculates what the bookmarking 'level' will be for any given page.
        * First sets a default using the course-level setting (or 'component' if that's not been set)
        * then checks to see if that's being overridden at page level or not
        * @param {Backbone.Model} pageModel The model for the current page view
        * @return {String} Either 'page', 'block', or 'component' - with 'component' being the default
        */
    getBookmarkLevel: function getBookmarkLevel(pageModel) {
      var defaultLevel = Adapt.course.get('_bookmarking')._level || 'component';
      var bookmarkModel = pageModel.get('_bookmarking');
      var isInherit = !bookmarkModel || !bookmarkModel._level || bookmarkModel._level === 'inherit';
      return isInherit ? defaultLevel : bookmarkModel._level;
    },

    /**
        * Sets up bookmarking for the page the learner just navigated to
        * If bookmarking is disabled for the current page, clear the stored bookmark and return.
        * Otherwise, bookmark the page then - if necessary - set up to calculate which block or component
        * should be bookmarked as the learner scrolls up/down the page
        * @param {Backbone.View} pageView The current page view
        */
    setupPage: function setupPage(pageView) {
      var pageBookmarkModel = pageView.model.get('_bookmarking');
      if (pageBookmarkModel && pageBookmarkModel._isEnabled === false) {
        this.resetLocationID();
        return;
      }

      this.setLocationID(pageView.model.get('_id'));

      this.bookmarkLevel = this.getBookmarkLevel(pageView.model);
      if (this.bookmarkLevel === 'page') {
        return;
      }

      this.watchViewIds = pageView.model.findDescendantModels(this.bookmarkLevel + 's').map(function (desc) {
        return desc.get('_id');
      });

      this.listenTo(Adapt, this.bookmarkLevel + 'View:postRender', this.captureViews);
      this.listenToOnce(Adapt, 'remove', this.releaseViews);

      $(window).on('scroll', this._onScroll);
    },

    captureViews: function captureViews(view) {
      this.watchViews.push(view);
    },

    setLocationID: function setLocationID(id) {
      if (!Adapt.offlineStorage) return;
      if (this.currentLocationID == id) return;
      Adapt.offlineStorage.set('location', id);
      this.currentLocationID = id;
    },

    releaseViews: function releaseViews() {
      this.watchViews.length = 0;
      this.watchViewIds.length = 0;
      this.stopListening(Adapt, 'remove', this.releaseViews);
      this.stopListening(Adapt, this.bookmarkLevel + 'View:postRender', this.captureViews);
      $(window).off('scroll', this._onScroll);
    },

    checkLocation: function checkLocation() {
      var highestOnscreen = 0;
      var highestOnscreenLocation = '';

      for (var i = 0, l = this.watchViews.length; i < l; i++) {
        var view = this.watchViews[i];

        var isViewAPageChild = this.watchViewIds.indexOf(view.model.get('_id')) > -1;

        if (!isViewAPageChild) continue;

        var element = $('.' + view.model.get('_id'));
        var measurements = element.onscreen();

        if (!measurements.onscreen) continue;
        if (measurements.percentInview > highestOnscreen) {
          highestOnscreen = measurements.percentInview;
          highestOnscreenLocation = view.model.get('_id');
        }
      }

      // set location as most inview component
      if (highestOnscreenLocation) this.setLocationID(highestOnscreenLocation);
    } });



  return new Bookmarking();

});

define('extensions/adapt-contrib-languagePicker/js/languagePickerNavigationView', [
'core/js/adapt'],
function (Adapt) {

  var NavigationView = Backbone.View.extend({

    className: 'nav',

    attributes: {
      role: 'navigation' },


    initialize: function initialize() {
      this.template = 'languagePickerNavigation';
      this.setupHelpers();
      this.preRender();
    },

    preRender: function preRender() {
      Adapt.trigger('navigationView:preRender', this);
      this.render();
    },

    render: function render() {var _this96 = this;
      var template = Handlebars.templates[this.template];
      this.$el.html(template({
        _config: this.model.get('_accessibility'),
        _accessibility: Adapt.config.get('_accessibility') })).
      insertBefore('#app');

      _.defer(function () {_newArrowCheck(this, _this96);return Adapt.trigger('navigationView:postRender', this);}.bind(this));

      return this;
    },

    setupHelpers: function setupHelpers() {
      Handlebars.registerHelper('a11y_aria_label', function (text) {
        return "<div class=\"aria-label\">".concat(text, "</div>");
      });
    } });



  return NavigationView;

});

define('extensions/adapt-contrib-languagePicker/js/languagePickerView', [
'core/js/adapt',
'./languagePickerNavigationView'],
function (Adapt, NavigationView) {

  var LanguagePickerView = Backbone.View.extend({

    events: {
      'click .js-languagepicker-btn-click': 'onLanguageClick' },


    className: 'languagepicker',

    initialize: function initialize() {
      this.initializeNavigation();
      $('html').addClass('in-languagepicker');
      this.listenTo(Adapt, 'remove', this.remove);
      this.render();
    },

    render: function render() {
      var data = this.model.toJSON();
      var template = Handlebars.templates[this.constructor.template];
      this.$el.html(template(data));
      this.$el.addClass(data._classes);

      document.title = this.model.get('title') || '';

      _.defer(this.postRender.bind(this));
    },

    postRender: function postRender() {
      $('.js-loading').hide();
    },

    onLanguageClick: function onLanguageClick(event) {
      this.destroyNavigation();
      this.model.setLanguage($(event.target).val());
    },

    initializeNavigation: function initializeNavigation() {
      this.navigationView = new NavigationView({ model: this.model });
    },

    destroyNavigation: function destroyNavigation() {
      this.navigationView.remove();
    },

    remove: function remove() {
      $('html').removeClass('in-languagepicker');

      Backbone.View.prototype.remove.apply(this, arguments);
    } },

  {
    template: 'languagePickerView' });


  return LanguagePickerView;

});

define('extensions/adapt-contrib-languagePicker/js/languagePickerDrawerView', [
'core/js/adapt'],
function (Adapt) {

  var LanguagePickerDrawerView = Backbone.View.extend({

    events: {
      'click .js-languagepicker-item-btn': 'onButtonClick' },


    initialize: function initialize() {
      this.listenTo(Adapt, {
        remove: this.remove,
        'languagepicker:changelanguage:yes': this.onDoChangeLanguage,
        'languagepicker:changelanguage:no': this.onDontChangeLanguage });

      this.render();
    },

    render: function render() {
      var data = this.model.toJSON();
      var template = Handlebars.templates[this.constructor.template];
      this.$el.html(template(data));
    },

    onButtonClick: function onButtonClick(event) {var _this97 = this;
      var newLanguage = $(event.currentTarget).attr('data-language');
      this.model.set('newLanguage', newLanguage);
      var data = this.model.getLanguageDetails(newLanguage);

      var promptObject = {
        _attributes: { lang: newLanguage },
        _classes: "is-lang-".concat(newLanguage, " ").concat(data._direction === 'rtl' ? 'is-rtl' : 'is-ltr'),
        title: data.warningTitle,
        body: data.warningMessage,
        _prompts: [
        {
          promptText: data._buttons.yes,
          _callbackEvent: 'languagepicker:changelanguage:yes' },

        {
          promptText: data._buttons.no,
          _callbackEvent: 'languagepicker:changelanguage:no' }],


        _showIcon: true };


      // keep active element incase the user cancels - usually navigation bar icon
      // move drawer close focus to #focuser
      this.$finishFocus = Adapt.a11y._popup._focusStack.pop();
      Adapt.a11y._popup._focusStack.push($('#a11y-focuser'));

      Adapt.once('drawer:closed', function () {var _this98 = this;_newArrowCheck(this, _this97);
        // wait for drawer to fully close
        _.delay(function () {var _this99 = this;_newArrowCheck(this, _this98);
          Adapt.once('popup:opened', function () {_newArrowCheck(this, _this99);
            // move popup close focus to #focuser
            Adapt.a11y._popup._focusStack.pop();
            Adapt.a11y._popup._focusStack.push($('#a11y-focuser'));
          }.bind(this));
          // show yes/no popup
          Adapt.notify.prompt(promptObject);
        }.bind(this), 250);
      }.bind(this));

      Adapt.trigger('drawer:closeDrawer');
    },

    onDoChangeLanguage: function onDoChangeLanguage() {
      var newLanguage = this.model.get('newLanguage');
      this.model.setTrackedData();
      this.model.setLanguage(newLanguage);
      this.remove();
    },

    /**
        * If the learner selects 'no' in the 'confirm language change' prompt,
        * wait for notify to close completely then send focus to the
        * navigation bar icon
        */
    onDontChangeLanguage: function onDontChangeLanguage() {var _this100 = this;
      this.remove();

      _.delay(function () {_newArrowCheck(this, _this100);return Adapt.a11y.focusFirst(this.$finishFocus);}.bind(this), 500);

    } },

  {
    template: 'languagePickerDrawerView' });


  return LanguagePickerDrawerView;

});

define('extensions/adapt-contrib-languagePicker/js/languagePickerNavView', [
'core/js/adapt',
'./languagePickerDrawerView'],
function (Adapt, LanguagePickerDrawerView) {

  var LanguagePickerNavView = Backbone.View.extend({

    tagName: 'button',

    className: function className() {
      var classNames = 'btn-icon nav__btn nav__languagepicker-btn js-languagepicker-nav-btn icon';
      var customClass = this.model.get('_languagePickerIconClass') || 'icon-language-2';

      return classNames + ' ' + customClass;
    },

    events: {
      'click': 'onClick' },


    initialize: function initialize() {
      this.listenTo(Adapt, 'remove', this.remove);
    },

    onClick: function onClick(event) {
      Adapt.drawer.triggerCustomView(new LanguagePickerDrawerView({ model: this.model }).$el, false);
    } });



  return LanguagePickerNavView;

});

define('extensions/adapt-contrib-languagePicker/js/languagePickerModel', [
'core/js/adapt'],
function (Adapt) {

  var LanguagePickerModel = Backbone.Model.extend({

    defaults: {
      _isEnabled: false,
      displayTitle: '',
      body: '',
      _languages: [] },


    trackedData: {
      components: [],
      blocks: [] },


    locationId: null,

    initialize: function initialize() {
      this.listenTo(Adapt.config, 'change:_activeLanguage', this.markLanguageAsSelected);
      this.listenTo(Adapt, 'app:dataLoaded', this.onDataLoaded);
    },

    getLanguageDetails: function getLanguageDetails(language) {var _this101 = this;
      var _languages = this.get('_languages');
      return _.find(_languages, function (item) {_newArrowCheck(this, _this101);return item._language === language;}.bind(this));
    },

    setLanguage: function setLanguage(language) {
      Adapt.config.set({
        _activeLanguage: language,
        _defaultDirection: this.getLanguageDetails(language)._direction });

    },

    markLanguageAsSelected: function markLanguageAsSelected(model, language) {var _this102 = this;
      this.get('_languages').forEach(function (item) {_newArrowCheck(this, _this102);
        item._isSelected = item._language === language;
      }.bind(this));
    },

    onDataLoaded: function onDataLoaded() {var _this103 = this;
      if (!this.get('_restoreStateOnLanguageChange')) {
        return;
      }
      _.defer(function () {_newArrowCheck(this, _this103);
        this.locationId = Adapt.offlineStorage.get('location') || null;
        this.restoreState();
      }.bind(this));

    },

    restoreLocation: function restoreLocation() {var _this104 = this;
      if (!Adapt.findById(this.locationId)) return;

      _.defer(function () {_newArrowCheck(this, _this104);return Adapt.navigateToElement('.' + this.locationId);}.bind(this));
    },

    /**
        * Restore course progress on language change.
        */
    restoreState: function restoreState() {

      if (this.isTrackedDataEmpty()) return;

      if (this.trackedData.components) {
        this.trackedData.components.forEach(this.setTrackableState);
      }

      if (this.trackedData.blocks) {
        this.trackedData.blocks.forEach(this.setTrackableState);
      }
    },

    isTrackedDataEmpty: function isTrackedDataEmpty() {
      return _.isEqual(this.trackedData, {
        components: [],
        blocks: [] });

    },

    getTrackableState: function getTrackableState() {
      var components = this.getState(Adapt.components.models);
      var blocks = this.getState(Adapt.blocks.models);
      return {
        components: _.compact(components),
        blocks: _.compact(blocks) };

    },

    getState: function getState(models) {var _this105 = this;
      return models.map(function (model) {_newArrowCheck(this, _this105);
        if (model.get('_isComplete')) {
          return model.getTrackableState();
        }
      }.bind(this));
    },

    setTrackedData: function setTrackedData() {
      if (!this.get('_restoreStateOnLanguageChange')) {
        return;
      }
      this.listenToOnce(Adapt, 'menuView:ready', this.restoreLocation);
      this.trackedData = this.getTrackableState();
    },

    setTrackableState: function setTrackableState(stateObject) {
      var restoreModel = Adapt.findById(stateObject._id);
      if (!restoreModel) {
        Adapt.log.warn('LanguagePicker unable to restore state for: ' + stateObject._id);
        return;
      }

      restoreModel.setTrackableState(stateObject);
    } });



  return LanguagePickerModel;

});

define('extensions/adapt-contrib-languagePicker/js/adapt-languagePicker', [
'core/js/adapt',
'./languagePickerView',
'./languagePickerNavView',
'./languagePickerModel'],
function (Adapt, LanguagePickerView, LanguagePickerNavView, LanguagePickerModel) {

  var languagePickerModel;

  Adapt.once('configModel:dataLoaded', onConfigLoaded);

  /**
                                                         * Once the Adapt config has loaded, check to see if the language picker is enabled. If it is:
                                                         * - stop the rest of the .json from loading
                                                         * - set up the language picker model
                                                         * - register for events to allow us to display the language picker icon in the navbar on pages and menus
                                                         * - wait for offline storage to be ready so that we can check to see if there's a stored language choice or not
                                                         */
  function onConfigLoaded() {
    if (!Adapt.config.has('_languagePicker')) return;
    if (!Adapt.config.get('_languagePicker')._isEnabled) return;

    Adapt.config.set('_canLoadData', false);

    languagePickerModel = new LanguagePickerModel(Adapt.config.get('_languagePicker'));

    Adapt.on('router:menu router:page', setupNavigationView);

    if (Adapt.offlineStorage.ready) {// on the offchance that it may already be ready...
      onOfflineStorageReady();
      return;
    }
    Adapt.once('offlineStorage:ready', onOfflineStorageReady);
  }

  /**
     * Once offline storage is ready, check to see if a language was previously selected by the user
     * If it was, load it. If it wasn't, show the language picker
     */
  function onOfflineStorageReady() {
    var storedLanguage = Adapt.offlineStorage.get('lang');

    if (storedLanguage) {
      languagePickerModel.setLanguage(storedLanguage);
      return;
    }

    if (languagePickerModel.get('_showOnCourseLoad') === false) {
      languagePickerModel.setLanguage(Adapt.config.get('_defaultLanguage'));
      return;
    }

    showLanguagePickerView();
  }

  function showLanguagePickerView() {
    var languagePickerView = new LanguagePickerView({
      model: languagePickerModel });


    languagePickerView.$el.appendTo('#wrapper');
  }

  function setupNavigationView() {
    /*
                                   * On the framework this isn't an issue, but courses built in the authoring tool before the ARIA label
                                   * was added will break unless the extension is removed then added again.
                                   */
    var courseGlobals = Adapt.course.get('_globals')._extensions;
    var navigationBarLabel = '';
    if (courseGlobals._languagePicker) {
      navigationBarLabel = courseGlobals._languagePicker.navigationBarLabel;
    }

    var languagePickerNavView = new LanguagePickerNavView({
      model: languagePickerModel,
      attributes: {
        'aria-label': navigationBarLabel } });



    languagePickerNavView.$el.appendTo('.nav__inner');
  }

});

define('extensions/adapt-contrib-pageLevelProgress/js/completionCalculations', [
'core/js/adapt'],
function (Adapt) {

  var Completion = Backbone.Controller.extend({

    subProgressCompleted: 0,
    subProgressTotal: 0,
    nonAssessmentCompleted: 0,
    nonAssessmentTotal: 0,
    assessmentCompleted: 0,
    assessmentTotal: 0 });



  // Calculate completion of a contentObject
  function calculateCompletion(contentObjectModel) {

    var completion = new Completion();

    var viewType = contentObjectModel.get('_type');
    var isComplete = contentObjectModel.get('_isComplete') ? 1 : 0;
    var children;

    switch (viewType) {
      case 'page':
        // If it's a page
        children = contentObjectModel.getAllDescendantModels().filter(function (model) {
          return model.get('_isAvailable') && !model.get('_isOptional');
        });

        var availableChildren = filterAvailableChildren(children);
        var components = getPageLevelProgressEnabledModels(availableChildren);

        var nonAssessmentComponents = getNonAssessmentComponents(components);

        completion.nonAssessmentTotal = nonAssessmentComponents.length;
        completion.nonAssessmentCompleted = getComponentsCompleted(nonAssessmentComponents).length;

        var assessmentComponents = getAssessmentComponents(components);

        completion.assessmentTotal = assessmentComponents.length;
        completion.assessmentCompleted = getComponentsInteractionCompleted(assessmentComponents).length;

        if (contentObjectModel.get('_pageLevelProgress')._excludeAssessments !== true) {
          completion.subProgressCompleted = contentObjectModel.get('_subProgressComplete') || 0;
          completion.subProgressTotal = contentObjectModel.get('_subProgressTotal') || 0;
        }

        var showPageCompletionCourse = Adapt.course.get('_pageLevelProgress') && Adapt.course.get('_pageLevelProgress')._showPageCompletion !== false;
        var showPageCompletionPage = contentObjectModel.get('_pageLevelProgress') && contentObjectModel.get('_pageLevelProgress')._showPageCompletion !== false;

        if (showPageCompletionCourse && showPageCompletionPage) {
          // optionally add one point extra for page completion to eliminate incomplete pages and full progress bars
          // if _showPageCompletion is true then the progress bar should also consider it so add 1 to nonAssessmentTotal
          completion.nonAssessmentCompleted += isComplete;
          completion.nonAssessmentTotal += 1;
        }

        break;
      case 'menu':case 'course':
        // If it's a sub-menu
        children = contentObjectModel.get('_children').models;
        children.forEach(function (contentObject) {
          var completionObject = calculateCompletion(contentObject);
          completion.subProgressCompleted += completionObject.subProgressCompleted || 0;
          completion.subProgressTotal += completionObject.subProgressTotal || 0;
          completion.nonAssessmentTotal += completionObject.nonAssessmentTotal;
          completion.nonAssessmentCompleted += completionObject.nonAssessmentCompleted;
          completion.assessmentTotal += completionObject.assessmentTotal;
          completion.assessmentCompleted += completionObject.assessmentCompleted;
        });
        break;}



    return completion;
  }

  function getNonAssessmentComponents(models) {
    return models.filter(function (model) {
      return !model.get('_isPartOfAssessment');
    });
  }

  function getAssessmentComponents(models) {
    return models.filter(function (model) {
      return model.get('_isPartOfAssessment');
    });
  }

  function getComponentsCompleted(models) {
    return models.filter(function (item) {
      return item.get('_isComplete');
    });
  }

  function getComponentsInteractionCompleted(models) {
    return models.filter(function (item) {
      return item.get('_isComplete');
    });
  }

  //Get only those models who were enabled for pageLevelProgress
  function getPageLevelProgressEnabledModels(models) {
    return models.filter(function (model) {
      var config = model.get('_pageLevelProgress');
      return config && config._isEnabled;
    });
  }

  function unavailableInHierarchy(parents) {
    if (!parents) return;
    return parents.some(function (parent) {
      return !parent.get('_isAvailable');
    });
  }

  function filterAvailableChildren(children) {
    var availableChildren = [];

    for (var i = 0, count = children.length; i < count; i++) {
      var parents = children[i].getAncestorModels();
      if (unavailableInHierarchy(parents)) continue;
      availableChildren.push(children[i]);
    }

    return availableChildren;
  }

  function calculatePercentageComplete(model) {
    var completionObject = calculateCompletion(model);
    // take all assessment, nonassessment and subprogress into percentage
    // this allows the user to see if assessments have been passed, if assessment components can be retaken, and all other component's completion
    var completed = completionObject.nonAssessmentCompleted + completionObject.assessmentCompleted + completionObject.subProgressCompleted;
    var total = completionObject.nonAssessmentTotal + completionObject.assessmentTotal + completionObject.subProgressTotal;
    var percentageComplete = Math.floor(completed / total * 100);
    return percentageComplete;
  }

  return {
    calculateCompletion: calculateCompletion,
    calculatePercentageComplete: calculatePercentageComplete,
    getPageLevelProgressEnabledModels: getPageLevelProgressEnabledModels,
    filterAvailableChildren: filterAvailableChildren };


});

define('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressIndicatorView', [
'core/js/adapt'],
function (Adapt) {

  var PageLevelProgressIndicatorView = Backbone.View.extend({

    initialize: function initialize(options) {
      options = options || {};
      this.parent = options.parent;
      this.calculatePercentage = options.calculatePercentage || this.calculatePercentage;
      this.ariaLabel = options.ariaLabel || '';
      this.type = options.type || this.model.get('_type');
      this.addClasses();
      this.setUpEventListeners();
      this.setPercentageComplete();
      this.render();
      this.refresh();
    },

    addClasses: function addClasses() {
      this.$el.addClass([
      'pagelevelprogress__indicator',
      'is-' + this.type].
      join(' '));
    },

    checkAria: function checkAria() {
      if (!this.ariaLabel) {
        this.$el.attr('aria-hidden', true);
        return;
      }
      var data = this.getRenderData();
      this.$('.js-indicator-aria-label').html(Handlebars.compile(this.ariaLabel)(data));
    },

    setUpEventListeners: function setUpEventListeners() {
      if (this.parent) {
        this.listenToOnce(this.parent, 'postRemove', this.remove);
      } else {
        this.listenTo(Adapt, 'remove', this.remove);
      }
      this.listenTo(this.model, 'change:_isComplete', this.refresh);
      if (!this.collection) return;
      this.listenTo(this.collection, 'change:_isComplete', this.refresh);
    },

    setPercentageComplete: function setPercentageComplete() {
      var percentage = this.calculatePercentage();
      this.model.set('percentageComplete', percentage);
      return percentage;
    },

    calculatePercentage: function calculatePercentage() {
      return this.model.get('_isComplete') ? 100 : 0;
    },

    render: function render() {
      var data = this.getRenderData();
      var template = Handlebars.templates[this.constructor.template];
      this.$el.html(template(data));
    },

    getRenderData: function getRenderData() {
      var data = this.model.toJSON();
      data.ariaLabel = this.ariaLabel;
      data.type = this.type;
      return data;
    },

    refresh: function refresh() {
      this.checkCompletion();
      this.checkAria();
      this.$('.js-indicator-bar').css({
        width: this.calculatePercentage() + '%' });

    },

    checkCompletion: function checkCompletion() {
      var percentage = this.setPercentageComplete();
      this.$el.
      toggleClass('is-complete', percentage === 100).
      toggleClass('is-incomplete', percentage !== 100);
    } },

  {
    template: 'pageLevelProgressIndicator' });


  return PageLevelProgressIndicatorView;

});

define('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressItemView', [
'core/js/adapt',
'./PageLevelProgressIndicatorView'],
function (Adapt, PageLevelProgressIndicatorView) {

  var PageLevelProgressItemView = Backbone.View.extend({

    className: function className() {
      return [
      'pagelevelprogress__item drawer__item',
      this.model.get('_type') + '__indicator'].
      join(' ');
    },

    attributes: {
      'role': 'listitem' },


    initialize: function initialize() {
      this.listenTo(Adapt, 'remove', this.remove);
      this.render();
      this.addIndicator();
    },

    render: function render() {
      var data = this.model.toJSON();
      var template = Handlebars.templates[this.constructor.template];
      this.$el.html(template(data));
    },

    addIndicator: function addIndicator() {
      if (this.model.get('_isOptional')) return;
      var item = new PageLevelProgressIndicatorView({
        model: this.model });

      this.$('.js-indicator').append(item.$el);
    } },

  {
    template: 'pageLevelProgressItem' });


  return PageLevelProgressItemView;

});

define('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressView', [
'core/js/adapt',
'./PageLevelProgressItemView'],
function (Adapt, PageLevelProgressItemView) {

  var PageLevelProgressView = Backbone.View.extend({

    className: 'pagelevelprogress',

    events: {
      'click .js-pagelevelprogress-item-click': 'scrollToPageElement' },


    initialize: function initialize() {
      this.listenTo(Adapt, 'remove', this.remove);
      this.render();
      this.addChildren();
    },

    scrollToPageElement: function () {var _scrollToPageElement = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee23(event) {var $target, id, model, currentComponentSelector;return regeneratorRuntime.wrap(function _callee23$(_context23) {while (1) {switch (_context23.prev = _context23.next) {case 0:
                if (event && event.preventDefault) event.preventDefault();

                $target = $(event.currentTarget);if (!
                $target.is('.is-disabled')) {_context23.next = 4;break;}return _context23.abrupt("return");case 4:

                id = $target.attr('data-pagelevelprogress-id');
                model = Adapt.findById(id);if (

                model.get('_isRendered')) {_context23.next = 15;break;}_context23.prev = 7;_context23.next = 10;return (

                  Adapt.parentView.renderTo(id));case 10:_context23.next = 15;break;case 12:_context23.prev = 12;_context23.t0 = _context23["catch"](7);return _context23.abrupt("return");case 15:





                currentComponentSelector = '.' + id;

                Adapt.once('drawer:closed', function () {
                  Adapt.scrollTo(currentComponentSelector, { duration: 400 });
                }).trigger('drawer:closeDrawer', $(currentComponentSelector));case 17:case "end":return _context23.stop();}}}, _callee23, null, [[7, 12]]);}));function scrollToPageElement(_x15) {return _scrollToPageElement.apply(this, arguments);}return scrollToPageElement;}(),


    render: function render() {
      var template = Handlebars.templates['pageLevelProgress'];
      this.$el.html(template({}));
    },

    addChildren: function addChildren() {
      var $children = this.$('.js-children');
      this.collection.each(function (model) {
        $children.append(new PageLevelProgressItemView({
          model: model }).
        $el);
      }.bind(this));
    } });



  return PageLevelProgressView;

});

define('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressNavigationView', [
'core/js/adapt',
'./completionCalculations',
'./PageLevelProgressView',
'./PageLevelProgressIndicatorView'],
function (Adapt, completionCalculations, PageLevelProgressView, PageLevelProgressIndicatorView) {

  var PageLevelProgressNavigationView = Backbone.View.extend({

    tagName: 'button',

    className: 'btn-icon nav__btn nav__pagelevelprogress-btn pagelevelprogress__nav-btn',

    events: {
      'click': 'onProgressClicked' },


    initialize: function initialize() {
      _.bindAll(this, 'updateProgressBar');
      this.setUpEventListeners();
      this.render();
      this.addIndicator();
      this.deferredUpdate();
    },

    setUpEventListeners: function setUpEventListeners() {
      this.listenTo(Adapt, {
        'remove': this.remove,
        'router:location': this.updateProgressBar,
        'view:childAdded pageLevelProgress:update': this.refreshProgressBar });

    },

    render: function render() {
      var template = Handlebars.templates['pageLevelProgressNavigation'];
      this.$el.html(template({}));
    },

    addIndicator: function addIndicator() {
      this.indicatorView = new PageLevelProgressIndicatorView({
        model: this.model,
        collection: this.collection,
        calculatePercentage: this._getPageCompletionPercentage,
        ariaLabel: Adapt.course.get('_globals')._extensions._pageLevelProgress.pageLevelProgressIndicatorBar });

      this.$el.prepend(this.indicatorView.$el);
    },

    _getPageCompletionPercentage: function _getPageCompletionPercentage() {
      return completionCalculations.calculatePercentageComplete(this.model);
    },

    deferredUpdate: function deferredUpdate() {
      _.defer(this.updateProgressBar);
    },

    updateProgressBar: function updateProgressBar() {
      this.indicatorView.refresh();
    },

    refreshProgressBar: function refreshProgressBar() {
      this.collection.repopulate();
      this.updateProgressBar();
    },

    onProgressClicked: function onProgressClicked(event) {
      if (event && event.preventDefault) event.preventDefault();
      Adapt.drawer.triggerCustomView(new PageLevelProgressView({
        collection: this.collection }).
      $el, false);
    },

    remove: function remove() {
      Backbone.View.prototype.remove.call(this);
      this.collection.reset();
    } });



  return PageLevelProgressNavigationView;

});

define('extensions/adapt-contrib-pageLevelProgress/js/PageLevelProgressCollection', [
'core/js/adapt',
'./completionCalculations'],
function (Adapt, completionCalculations) {

  var PageLevelProgressCollection = Backbone.Collection.extend({

    initialize: function initialize(models, options) {
      this.listenTo(Adapt, 'remove', this.reset);
      if (!options || !options.pageModel) return;
      this._pageModel = options.pageModel;
      this.repopulate();
    },

    repopulate: function repopulate() {
      this.reset();
      if (!this._pageModel) return;

      var allDescendants = this._pageModel.getAllDescendantModels(true);
      var currentPageItems = allDescendants.filter(function (item) {
        return item.get('_isAvailable') === true;
      });
      var availableItems = completionCalculations.filterAvailableChildren(currentPageItems);
      var enabledProgressItems = completionCalculations.getPageLevelProgressEnabledModels(availableItems);

      this.add(enabledProgressItems);
    } });



  return PageLevelProgressCollection;

});

define('extensions/adapt-contrib-pageLevelProgress/js/adapt-contrib-pageLevelProgress', [
'core/js/adapt',
'./completionCalculations',
'./PageLevelProgressNavigationView',
'./PageLevelProgressIndicatorView',
'./PageLevelProgressCollection'],
function (Adapt, completionCalculations, PageLevelProgressNavigationView, PageLevelProgressIndicatorView, PageLevelProgressCollection) {

  var PageLevelProgress = Backbone.Controller.extend({

    initialize: function initialize() {
      Adapt.on({
        'app:dataReady': this.onDataReady.bind(this),
        'app:languageChanged': function () {
          // Remove events created by setUpEventListeners
          this.stopListening();
        }.bind(this) });

    },

    getCourseConfig: function getCourseConfig() {
      return Adapt.course.get('_pageLevelProgress');
    },

    onDataReady: function onDataReady() {
      // Do not proceed if pageLevelProgress is not enabled in course.json
      var coursePLPConfig = this.getCourseConfig();
      if (!coursePLPConfig || !coursePLPConfig._isEnabled) {
        return;
      }
      this.setUpEventListeners();
    },

    setUpEventListeners: function setUpEventListeners() {
      var headerIndicatorTypes = [
      'menu',
      'menuItem',
      'page',
      'article',
      'block',
      'component'];


      var headerIndicatorEventNames = headerIndicatorTypes.
      concat(['']).join('View:render ');

      this.listenTo(Adapt, headerIndicatorEventNames, this.renderHeaderIndicatorView);

      this.listenTo(Adapt, {
        'menuItemView:postRender': this.renderMenuItemIndicatorView,
        'router:page': this.renderNavigationView });


      this.listenTo(Adapt.course, 'bubble:change:_isComplete', this.onCompletionChange);
    },

    onCompletionChange: function onCompletionChange(event) {
      if (!Adapt.location._currentId) return;

      var currentModel = Adapt.findById(Adapt.location._currentId);
      var completionState = {
        currentLocation: completionCalculations.calculatePercentageComplete(currentModel),
        course: completionCalculations.calculatePercentageComplete(Adapt.course) };

      var hasChanged = !_.isMatch(this._previousCompletionState, completionState);
      if (!hasChanged) return;

      this._previousCompletionState = completionState;
      Adapt.trigger('pageLevelProgress:percentageCompleteChange', completionState);
    },

    renderHeaderIndicatorView: function renderHeaderIndicatorView(view) {
      var model = view.model;

      var config = model.get('_pageLevelProgress');
      if (!config || !config._isEnabled || !config._isCompletionIndicatorEnabled) {
        return;
      }

      var pageModel = model.findAncestor('contentObjects');
      var pageConfig = pageModel && pageModel.get('_pageLevelProgress');
      if (pageConfig && !pageConfig._isEnabled) {
        return;
      }

      var $headings = view.$('.js-heading');
      $headings.each(function (index, el) {
        var $el = $(el);
        var indicatorView = new PageLevelProgressIndicatorView({
          parent: view,
          model: model });

        indicatorView.$el.insertAfter($el);
      });
    },

    // This should add/update progress on menuView
    renderMenuItemIndicatorView: function renderMenuItemIndicatorView(view) {
      // Do not render on menu, only render on menu items
      if (view.model.get('_id') === Adapt.location._currentId) {
        return;
      }

      // Progress bar should not render for course viewType
      var viewType = view.model.get('_type');
      if (viewType === 'course') {
        return;
      }

      // Do not proceed if pageLevelProgress is not enabled for the content object
      var pageLevelProgress = view.model.get('_pageLevelProgress');
      if (!pageLevelProgress || !pageLevelProgress._isEnabled) {
        return;
      }

      view.$el.find('.js-menu-item-progress').append(new PageLevelProgressIndicatorView({
        parent: view,
        model: view.model,
        type: 'menu-item',
        calculatePercentage: this._getMenuItemCompletionPercentage.bind(view),
        ariaLabel: Adapt.course.get('_globals')._extensions._pageLevelProgress.pageLevelProgressMenuBar }).
      $el);
    },

    _getMenuItemCompletionPercentage: function _getMenuItemCompletionPercentage() {
      return completionCalculations.calculatePercentageComplete(this.model);
    },

    // This should add/update progress on page navigation bar
    renderNavigationView: function renderNavigationView(pageModel) {
      // Do not render if turned off at course level
      var coursePLPConfig = this.getCourseConfig();
      if (coursePLPConfig && coursePLPConfig._isShownInNavigationBar === false) {
        return;
      }

      // Do not proceed if pageLevelProgress is not enabled for the content object
      var pagePLPConfig = pageModel.get('_pageLevelProgress');
      if (!pagePLPConfig || !pagePLPConfig._isEnabled) {
        return;
      }

      var collection = new PageLevelProgressCollection(null, {
        pageModel: pageModel });


      if (collection.length === 0) {
        return;
      }

      $('.nav__drawer-btn').after(new PageLevelProgressNavigationView({
        model: pageModel,
        collection: collection }).
      $el);
    } });



  Adapt.pageLevelProgress = new PageLevelProgress();

});

define('extensions/adapt-contrib-resources/js/adapt-contrib-resourcesView', [
'core/js/adapt'],
function (Adapt) {

  var ResourcesView = Backbone.View.extend({

    className: 'resources',

    initialize: function initialize() {
      this.listenTo(Adapt, 'remove', this.remove);
      this.render();
    },

    events: {
      'click .js-resources-filter-btn-click': 'onFilterClicked' },


    render: function render() {
      this.$el.html(Handlebars.templates.resources({
        model: this.model.toJSON(),
        resources: this.collection.toJSON() }));


      _.defer(function () {
        this.listenTo(Adapt, 'drawer:triggerCustomView', this.remove);
      }.bind(this));

      return this;
    },

    onFilterClicked: function onFilterClicked(e) {
      if (e && e.preventDefault) e.preventDefault();

      this.$('.js-resources-filter-btn-click').removeClass('is-selected');

      var items;
      var filter = $(e.currentTarget).addClass('is-selected').attr('data-filter');
      if (filter === 'all') {
        items = this.$('.js-resources-item').removeClass('u-display-none');
      } else {
        this.$('.js-resources-item').removeClass('u-display-none').not('.is-' + filter).addClass('u-display-none');
        items = this.$('.js-resources-item.is-' + filter);
      }

      if (items.length > 0) $(items[0]).a11y_focus();
    } });


  return ResourcesView;
});

define('extensions/adapt-contrib-resources/js/adapt-contrib-resourcesHelpers', [
'handlebars',
'core/js/adapt'],
function (Handlebars, Adapt) {

  var helpers = {

    resources_has_type: function resources_has_type(resources, type, block) {
      var hasType = _.some(resources, _.matcher({ _type: type }));
      return hasType ? block.fn(this) : block.inverse(this);
    },

    resources_has_multiple_types: function resources_has_multiple_types(resources, block) {
      if (resources.length === 1) return block.inverse(this);

      var allSameType = _.every(resources, _.matcher({ _type: resources[0]._type }));
      return allSameType ? block.inverse(this) : block.fn(this);
    },

    resources_get_column_count: function resources_get_column_count(resources) {
      return _.uniq(_.pluck(resources, '_type')).length + 1; // add 1 for the 'All' button column
    },

    /**
        * IE doesn't support the 'download' attribute
        * https://github.com/adaptlearning/adapt_framework/issues/1559
        * and iOS just opens links with that attribute in the same window
        * https://github.com/adaptlearning/adapt_framework/issues/1852
        */
    resources_force_download: function resources_force_download(resource, block) {
      if (Adapt.device.browser === 'internet explorer' || Adapt.device.OS === 'ios') {
        return block.inverse(this);
      }

      return resource._forceDownload || resource.filename ? block.fn(this) : block.inverse(this);
    } };



  for (var name in helpers) {
    if (helpers.hasOwnProperty(name)) {
      Handlebars.registerHelper(name, helpers[name]);
    }
  }

});

define('extensions/adapt-contrib-resources/js/adapt-contrib-resources', [
'core/js/adapt',
'./adapt-contrib-resourcesView',
'./adapt-contrib-resourcesHelpers'],
function (Adapt, ResourcesView, ResourcesHelpers) {

  function setupResources(resourcesData) {

    var resourcesModel = new Backbone.Model(resourcesData);
    var resourcesCollection = new Backbone.Collection(resourcesModel.get('_resourcesItems'));

    Adapt.on('resources:showResources', function () {
      Adapt.drawer.triggerCustomView(new ResourcesView({
        model: resourcesModel,
        collection: resourcesCollection }).
      $el);
    });

  }

  function initResources() {

    var courseResources = Adapt.course.get('_resources');

    // do not proceed until resource set on course.json
    if (!courseResources || courseResources._isEnabled === false) return;

    var drawerObject = {
      title: courseResources.title,
      description: courseResources.description,
      className: 'is-resources',
      drawerOrder: courseResources._drawerOrder || 0 };


    Adapt.drawer.addItem(drawerObject, 'resources:showResources');

    setupResources(courseResources);

  }

  Adapt.on('adapt:start', initResources);

});

define('extensions/adapt-contrib-trickle/js/trickleView', [
'core/js/adapt'],
function (Adapt) {

  var TrickleView = Backbone.View.extend({

    isSteplocked: false,

    completionAttribute: null,

    initialize: function initialize(options) {
      this.setupEventListeners();
    },

    setupEventListeners: function setupEventListeners() {
      var AdaptEvents = {
        "trickle:kill": this.onKill,
        "remove": this.onRemove };


      this.onPreRender(this);

      AdaptEvents[this.model.get("_type") + "View:postRender"] = this.onPostRender;
      this.listenTo(Adapt, AdaptEvents);

      this.on("steplock", this.onStepLock);
      this.on("stepunlock", this.onStepUnlock);
    },

    onPreRender: function onPreRender(view) {
      this.completionAttribute = Adapt.trickle.getCompletionAttribute();
      if (!this.isElementEnabled()) return;

      Adapt.trigger("trickle:preRender", this);
    },

    onPostRender: function onPostRender(view) {
      if (view.model.get("_id") !== this.model.get("_id")) return;
      if (!this.isElementEnabled()) return;

      Adapt.trigger("trickle:postRender", this);
    },

    isElementEnabled: function isElementEnabled() {
      var trickle = Adapt.trickle.getModelConfig(this.model);
      if (!trickle) return false;

      if (this.model.get(this.completionAttribute)) return false;

      var isArticleWithOnChildren = this.model.get("_type") === "article" && trickle._onChildren;
      if (isArticleWithOnChildren) {
        return false;
      }

      if (trickle._isEnabled === true) return true;
      return false;
    },

    onStepLock: function onStepLock() {
      if (!this.isElementEnabled()) {
        this.continueToNext();
        return;
      }

      var trickle = Adapt.trickle.getModelConfig(this.model);
      var isSteplocking = trickle._stepLocking && trickle._stepLocking._isEnabled;
      if (!isSteplocking) {
        this.continueToNext();
        return;
      }

      Adapt.trigger("trickle:steplock", this);
      this.isSteplocked = true;
    },

    continueToNext: function continueToNext() {
      Adapt.trigger("trickle:continue", this);
    },


    onStepUnlock: function onStepUnlock() {
      if (!this.isSteplocked) return;
      this.isSteplocked = false;
      Adapt.trigger("trickle:stepunlock", this);
    },

    onKill: function onKill() {
      this.detachFromElement();
    },

    onRemove: function onRemove() {
      this.detachFromElement();
    },

    detachFromElement: function detachFromElement() {
      this.undelegateEvents();
      this.stopListening();
      this.model = null;
      this.articleModel = null;
      this.$el = null;
      this.el = null;
    } });



  return TrickleView;

});

define('extensions/adapt-contrib-trickle/js/pageView', [
'core/js/adapt',
'./trickleView'],
function (Adapt, TrickleView) {

  var PageView = Backbone.View.extend({

    currentDescendantIndex: 0,
    currentLocksOnDescendant: 0,
    currentDescendant: null,

    initialize: function initialize(options) {
      if (!this.isPageEnabled()) {
        return this.detachFromPage();
      }
      this.setupDescendants();
      if (!this.haveDescendantsGotTrickle()) {
        return this.detachFromPage();
      }
      this.addClassToHtml();
      this.setupEventListeners();
    },

    isPageEnabled: function isPageEnabled() {
      var trickleConfig = Adapt.trickle.getModelConfig(this.model);
      if (trickleConfig && trickleConfig._isEnabled === false) return false;
      return true;
    },

    setupDescendants: function setupDescendants() {
      this.currentDescendant = null;
      this.descendantViews = {};
      this.getDescendants();
      Adapt.trigger("trickle:descendants", this);
    },

    descendantsChildFirst: null,
    descendantsParentFirst: null,
    descendantViews: null,

    getDescendants: function getDescendants() {
      this.descendantsChildFirst = this.model.getAllDescendantModels();
      this.descendantsParentFirst = this.model.getAllDescendantModels(true);

      // if some descendants flip between _isAvailable true/false they
      // must have their defaults set before the filter is applied
      this.setDescendantsTrickleDefaults();

      this.descendantsChildFirst = this.filterComponents(this.descendantsChildFirst);
      this.descendantsParentFirst = this.filterComponents(this.descendantsParentFirst);

    },

    filterComponents: function filterComponents(descendants) {
      return descendants.filter(function (descendant) {
        if (descendant.get("_type") === "component") return false;
        if (!descendant.get("_isAvailable")) return false;
        return true;
      });
    },

    setDescendantsTrickleDefaults: function setDescendantsTrickleDefaults() {
      // use parent first as likely to get to article
      this.descendantsParentFirst.forEach(function (descendant) {
        var trickle = Adapt.trickle.getModelConfig(descendant);
        if (!trickle) {
          return;
        }

        // check if trickle is configures on descendant
        // NOTE: Removed for banked assessments
        // var isTrickleConfigured = descendant.get("_isTrickleConfigured");
        // if (isTrickleConfigured) return;

        // setup steplocking defaults
        trickle._stepLocking = _.extend({
          "_isEnabled": true, //(default=true)
          "_isCompletionRequired": true, //(default=true)
          "_isLockedOnRevisit": false //(default=false)
        }, trickle._stepLocking);

        // setup main trickle defaults
        trickle = _.extend({
          "_isEnabled": true, //(default=true)
          "_autoScroll": true, //(default=true)
          "_scrollDuration": 500, //(default=500)
          "_onChildren": true, //(default=true)
          "_scrollTo": "@block +1" //(default="@block +1")
        }, trickle);

        Adapt.trickle.setModelConfig(descendant, trickle);

        //check article "onChildren" rule
        if (trickle._onChildren &&
        descendant.get("_type") === "article") {
          this.setupArticleOnChildren(descendant, trickle);
        }

        // set descendant trickle as configured
        descendant.set("_isTrickleConfigured", true);

      }.bind(this));
    },

    setupArticleOnChildren: function setupArticleOnChildren(articleModel, articleTrickleConfig) {
      // set trickle on all blocks, using article config with block overrides
      var articleBlocks = articleModel.getChildren();

      articleBlocks.each(function (blockModel, index) {
        var blockTrickleConfig = Adapt.trickle.getModelConfig(blockModel);

        // overlay block trickle on article trickle
        // this allows values to carry through from the article to the block
        // retains any value overriden in the block
        for (var k in blockTrickleConfig) {
          //handle nested objects to one level
          if (_typeof(blockTrickleConfig[k]) === "object") {
            blockTrickleConfig[k] = _.extend({}, articleTrickleConfig[k], blockTrickleConfig[k]);
          }
        }

        blockTrickleConfig = _.extend({}, articleTrickleConfig, blockTrickleConfig);


        // setup start/final config
        if (articleBlocks.length === index + 1) {
          blockTrickleConfig._isFinal = true;
        }
        if (index === 0) {
          blockTrickleConfig._isStart = true;
        }

        Adapt.trickle.setModelConfig(blockModel, blockTrickleConfig);
      });

    },

    haveDescendantsGotTrickle: function haveDescendantsGotTrickle() {
      return this.descendantsChildFirst.some(function (descendant) {
        var trickle = Adapt.trickle.getModelConfig(descendant);
        return trickle && trickle._isEnabled === true;
      });
    },

    addClassToHtml: function addClassToHtml() {
      $("html").addClass("trickle");
    },

    setupEventListeners: function setupEventListeners() {
      this.listenTo(Adapt, {
        "remove": this.onRemove,

        "articleView:preRender": this.onDescendantPreRender,
        "blockView:preRender": this.onDescendantPreRender,

        "trickle:unwait": this.onUnwait,
        "trickle:wait": this.onWait,
        "trickle:continue": this.onContinue,
        "trickle:skip": this.onSkip,

        "trickle:kill": this.onKill });

      this.listenToOnce(this.model, "change:_isReady", this.onPageReady);
    },

    onDescendantPreRender: function onDescendantPreRender(view) {
      // ignore components
      if (view.model.get("_type") === "component") return;

      var descendantView = new TrickleView({
        model: view.model,
        el: view.el });

      this.descendantViews[view.model.get("_id")] = descendantView;
    },

    // trickle lifecycle

    onPageReady: function onPageReady(model, value) {
      if (!value) return;

      this.currentDescendant = null;

      Adapt.trigger("trickle:started");
      this.gotoNextDescendant();
    },

    gotoNextDescendant: function gotoNextDescendant() {
      this.getDescendants();

      if (this.currentDescendant) {
        this.currentDescendant.trigger("stepunlock");
        this.currentDescendant = null;
      }

      for (var index = this.currentDescendantIndex || 0, l = this.descendantsChildFirst.length; index < l; index++) {
        var descendant = this.descendantsChildFirst[index];
        switch (descendant.get("_type")) {
          case "block":
          case "article":
            this.currentLocksOnDescendant = 0;
            this.currentDescendantIndex = index;
            var currentId = descendant.get("_id");
            this.currentDescendant = this.descendantViews[currentId];
            this.currentDescendant.trigger("steplock");
            return;}

      }
      this.finished();
    },

    onContinue: function onContinue(view) {
      if (!this.currentDescendant) return;
      if (view.model.get("_id") !== this.currentDescendant.model.get("_id")) return;

      this.onSkip();
    },

    onWait: function onWait() {
      this.currentLocksOnDescendant++;
    },

    onUnwait: function onUnwait() {
      this.currentLocksOnDescendant--;
      if (this.currentLocksOnDescendant > 0) return;

      var lastDescendant = this.currentDescendant.model;

      this.currentDescendantIndex++;
      this.gotoNextDescendant();

      Adapt.trickle.scroll(lastDescendant);

    },

    onSkip: function onSkip() {
      // wait for all handlers to accept skip
      this.currentDescendantIndex++;
      this.gotoNextDescendant();
    },

    onKill: function onKill() {
      this.finished();
      this.detachFromPage();
    },

    finished: function finished() {
      Adapt.trigger("trickle:finished");
      this.detachFromPage();
    },

    // end of trickle lifecycle

    onRemove: function onRemove() {
      this.finished();
    },

    detachFromPage: function detachFromPage() {
      $("html").removeClass("trickle");
      this.undelegateEvents();
      this.stopListening();
      this.model = null;
      this.$el = null;
      this.el = null;
      this.currentDescendant = null;
      this.descendantViews = null;
      this.descendantsChildFirst = null;
      this.descendantsParentFirst = null;
      Adapt.trickle.pageView = null;
    } });



  return PageView;

});

define('extensions/adapt-contrib-trickle/js/handlers/buttonView', [
'core/js/adapt',
'core/js/views/componentView'],
function (Adapt, ComponentView) {

  var completionAttribute = "_isComplete";

  var TrickleButtonView = Backbone.View.extend({

    isStepLocking: false,
    hasStepLocked: false,
    isStepLocked: false,
    isStepLockFinished: false,
    hasStepPreCompleted: false,
    isWaitingForClick: false,
    allowVisible: false,
    allowEnabled: true,
    overlayShownCount: 0,

    el: function el() {

      this.setupPreRender();

      return Handlebars.templates['trickle-button'](this.model.toJSON());
    },

    setupPreRender: function setupPreRender() {

      this.setupButtonVisible();
      this.setupButtonEnabled();
    },

    setupButtonVisible: function setupButtonVisible() {
      var trickle = Adapt.trickle.getModelConfig(this.model);
      this.allowVisible = false;
      trickle._button._isVisible = false;

      if (trickle._button._styleBeforeCompletion === "visible") {
        this.allowVisible = true;
        if (trickle._button._autoHide && trickle._button._isFullWidth) {
          trickle._button._isVisible = false;
        } else {
          trickle._button._isVisible = true;
        }
      }
    },

    setupButtonEnabled: function setupButtonEnabled() {
      var trickle = Adapt.trickle.getModelConfig(this.model);

      if (trickle._stepLocking._isCompletionRequired === false) {
        this.allowEnabled = true;
        trickle._button._isDisabled = false;
      } else if (trickle._button._styleBeforeCompletion === "visible") {
        this.allowEnabled = false;
        trickle._button._isDisabled = true;
      } else {
        trickle._button._isDisabled = false;
        this.allowEnabled = true;
      }

    },

    events: {
      "click .js-trickle-btn": "onButtonClick" },


    initialize: function initialize(options) {
      this.getCompletionAttribute();
      this.debounceCheckAutoHide();
      this.setupStepLocking();
      this.setupEventListeners();
    },

    getCompletionAttribute: function getCompletionAttribute() {
      var trickle = Adapt.trickle.getModelConfig(Adapt.config);
      if (!trickle) return;
      if (!trickle._completionAttribute) return;
      completionAttribute = trickle._completionAttribute;
    },

    setupStepLocking: function setupStepLocking() {
      var trickle = Adapt.trickle.getModelConfig(this.model);
      this.isStepLocked = Boolean(trickle._stepLocking._isEnabled);
    },

    setupEventListeners: function setupEventListeners() {
      this.listenTo(Adapt, {
        "trickle:overlay": this.onOverlay,
        "trickle:unoverlay": this.onUnoverlay,
        "trickle:steplock": this.onStepLock,
        "trickle:stepunlock": this.onStepUnlock,
        "trickle:skip": this.onSkip,
        "trickle:kill": this.onKill,
        "trickle:update": this.onUpdate,
        "remove": this.onRemove });


      this.listenTo(this.model, "change:" + completionAttribute, this.onCompletion);
    },

    debounceCheckAutoHide: function debounceCheckAutoHide() {
      this.checkButtonAutoHideSync = this.checkButtonAutoHide.bind(this);
      this.checkButtonAutoHide = _.debounce(this.checkButtonAutoHideSync, 100);
    },

    checkButtonAutoHide: function checkButtonAutoHide() {
      if (!this.allowVisible) {
        this.setButtonVisible(false);
        return;
      }

      var trickle = Adapt.trickle.getModelConfig(this.model);
      if (!trickle._button._autoHide) {
        this.setButtonVisible(true);
        return;
      } else if (this.overlayShownCount > 0) {
        this.setButtonVisible(false);
        return;
      }

      var measurements = this.$el.onscreen();

      // This is to fix common miscalculation issues
      var isJustOffscreen = measurements.bottom > -100;

      // add show/hide animation here if needed
      if (measurements.onscreen || isJustOffscreen) {
        this.setButtonVisible(true);
      } else {
        this.setButtonVisible(false);
      }
    },

    setButtonVisible: function setButtonVisible(isVisible) {
      var trickle = Adapt.trickle.getModelConfig(this.model);
      trickle._button._isVisible = Boolean(isVisible);
      this.$(".js-trickle-btn-container").toggleClass("u-display-none", !trickle._button._isVisible);
    },

    checkButtonEnabled: function checkButtonEnabled() {
      this.setButtonEnabled(this.allowEnabled);
    },

    setButtonEnabled: function setButtonEnabled(isEnabled) {
      var trickle = Adapt.trickle.getModelConfig(this.model);
      var $button = this.$(".js-trickle-btn");
      if (isEnabled) {
        $button.removeClass("is-disabled").removeAttr("disabled");
        trickle._button._isDisabled = true;
        // move focus forward if it's on the aria-label
        if (document.activeElement instanceof HTMLElement && document.activeElement.isSameNode(this.$('.aria-label')[0])) {
          this.$('.aria-label').focusNext();
        }
        // make label unfocusable as it is no longer needed
        this.$('.aria-label').a11y_cntrl(false);
      } else {
        $button.addClass("is-disabled").attr("disabled", "disabled");
        trickle._button._isDisabled = false;
      }
    },

    onStepLock: function onStepLock(view) {
      if (!this.isViewMatch(view)) return;

      this.hasStepLocked = true;
      this.isStepLocking = true;
      this.overlayShownCount = 0;

      var trickle = Adapt.trickle.getModelConfig(this.model);

      if (!this.isButtonEnabled()) return;
      var isCompleteAndShouldRelock = trickle._stepLocking._isLockedOnRevisit &&
      this.model.get(completionAttribute);

      if (isCompleteAndShouldRelock) {
        this.isStepLocked = true;
        this.model.set("_isTrickleAutoScrollComplete", false);
        Adapt.trigger("trickle:wait");
        this.allowVisible = true;
        this.checkButtonAutoHide();
      } else if (this.hasStepPreCompleted) {
        // force the button to show if section completed before it was steplocked
        this.isStepLocked = true;
        this.model.set("_isTrickleAutoScrollComplete", false);
        this.allowVisible = true;
        this.stepCompleted();
      }
      this.setupOnScreenListener();
    },

    onOverlay: function onOverlay() {
      this.overlayShownCount++;
    },

    onUnoverlay: function onUnoverlay() {
      this.overlayShownCount--;
      this.checkButtonAutoHide();
    },

    setupOnScreenListener: function setupOnScreenListener() {
      var trickle = Adapt.trickle.getModelConfig(this.model);

      if (!trickle._button._autoHide) return;
      this.$el.on("onscreen", this.checkButtonAutoHideSync);

    },

    isViewMatch: function isViewMatch(view) {
      return view.model.get("_id") === this.model.get("_id");
    },

    isButtonEnabled: function isButtonEnabled() {
      var trickle = Adapt.trickle.getModelConfig(this.model);

      if (!trickle._isEnabled || !trickle._button._isEnabled) return false;
      return true;
    },

    onCompletion: function onCompletion(model, value) {
      if (value === false) return;

      this.hasStepPreCompleted = true;

      if (!this.hasStepLocked) return;

      this.stepCompleted();
    },

    stepCompleted: function stepCompleted() {

      if (this.isStepLockFinished) return;

      this.isStepLocked = false;
      this.allowVisible = false;
      this.allowEnabled = false;

      if (this.isButtonEnabled()) {
        if (this.isStepLocking) {

          this.isStepLocked = true;
          this.isWaitingForClick = true;
          Adapt.trigger("trickle:wait");

        } else {

          this.isStepLockFinished = true;
        }

        this.allowVisible = true;
        this.allowEnabled = true;
      }

      this.model.set("_isTrickleAutoScrollComplete", false);
      this.checkButtonAutoHideSync();
      this.checkButtonEnabled();

    },

    onButtonClick: function onButtonClick() {
      if (this.isStepLocked) {
        Adapt.trigger("trickle:unwait");
        this.isStepLocked = false;
        this.isStepLockFinished = true;
      } else {
        this.model.set("_isTrickleAutoScrollComplete", false);
        Adapt.trickle.scroll(this.model);
      }

      var trickle = this.model.get("_trickle");
      switch (trickle._button._styleAfterClick) {
        case "hidden":
          this.allowVisible = false;
          this.checkButtonAutoHideSync();
          break;
        case "disabled":
          this.allowEnabled = false;
          this.checkButtonAutoHideSync();}

    },

    onUpdate: function onUpdate() {
      var trickle = Adapt.trickle.getModelConfig(this.model);

      if (trickle._button._autoHide && this.isStepLocking) {
        this.$el.off("onscreen", this.checkButtonAutoHideSync);
      }

      var $original = this.$el;
      var $newEl = $(Handlebars.templates['trickle-button'](this.model.toJSON()));
      $original.replaceWith($newEl);

      this.setElement($newEl);

      if (trickle._button._autoHide && this.isStepLocking) {
        this.$el.on("onscreen", this.checkButtonAutoHideSync);
      }
    },

    onStepUnlock: function onStepUnlock(view) {
      if (!this.isViewMatch(view)) return;
      this.$el.off("onscreen", this.checkButtonAutoHideSync);
      this.isStepLocking = false;
      this.overlayShownCount = 0;
      // move focus forward if it's on the aria-label
      if (document.activeElement instanceof HTMLElement && document.activeElement.isSameNode(this.$('.aria-label')[0])) {
        this.$('.aria-label').focusNext();
      }
      // make label unfocusable as it is no longer needed
      this.$('.aria-label').a11y_cntrl(false);
    },

    onSkip: function onSkip() {
      if (!this.isStepLocking) return;

      this.onKill();
    },

    onKill: function onKill() {
      this.$el.off("onscreen", this.checkButtonAutoHideSync);
      if (this.isWaitingForClick) {
        this.model.set("_isTrickleAutoScrollComplete", true);
      }
      this.isWaitingForClick = false;
      this.isStepLocked = false;
      this.isStepLocking = false;
      this.allowVisible = false;
      this.allowEnabled = false;
      this.isStepLockFinished = true;
      this.model.set("_isTrickleAutoScrollComplete", false);
      this.checkButtonAutoHide();
      this.checkButtonEnabled();
    },

    onRemove: function onRemove() {
      if (this.isWaitingForClick) {
        this.model.set("_isTrickleAutoScrollComplete", true);
      }
      this.isWaitingForClick = false;
      this.$el.off("onscreen", this.checkButtonAutoHideSync);
      this.isStepLocking = true;
      this.remove();
    } });



  return TrickleButtonView;

});

define('extensions/adapt-contrib-trickle/js/handlers/button', [
'core/js/adapt',
'./buttonView'],
function (Adapt, ButtonView) {

  var TrickleButtonHandler = Backbone.Controller.extend({

    buttonViews: null,

    initialize: function initialize() {
      this.listenToOnce(Adapt, {
        'app:dataReady': this.onAppDataReady,
        remove: this.onRemove });

    },

    onAppDataReady: function onAppDataReady() {
      this.buttonViews = {};
      this.setupEventListeners();
    },

    setupEventListeners: function setupEventListeners() {
      this.listenTo(Adapt, {
        'trickle:preRender': this.onPreRender,
        'trickle:postRender': this.onPostRender });

    },

    onPreRender: function onPreRender(view) {
      // setup button on prerender to allow it to control the steplocking process
      if (!this.isTrickleEnabled(view.model)) return;

      this.setupConfigDefaults(view.model);

      this.buttonViews[view.model.get('_id')] = new ButtonView({
        model: view.model });

    },

    onPostRender: function onPostRender(view) {
      // inject the button at post render
      if (!this.isTrickleEnabled(view.model)) return;

      view.$el.append(this.buttonViews[view.model.get('_id')].$el);
    },

    isTrickleEnabled: function isTrickleEnabled(model) {
      var trickle = Adapt.trickle.getModelConfig(model);
      if (!trickle || !trickle._isEnabled) return false;

      if (trickle._onChildren && model.get('_type') === 'article') return false;

      return true;
    },

    setupConfigDefaults: function setupConfigDefaults(model) {
      if (model.get('_isTrickleButtonConfigured')) return;

      var defaults = {
        _isEnabled: true,
        _styleBeforeCompletion: 'hidden',
        _styleAfterClick: 'hidden',
        _isFullWidth: true,
        _autoHide: false,
        _className: '',
        _hasIcon: false,
        text: 'Continue',
        startText: 'Begin',
        finalText: 'Finish',
        _component: 'trickle-button',
        _isLocking: true,
        _isVisible: false,
        _isDisabled: false };


      var trickle = Adapt.trickle.getModelConfig(model);
      trickle._button = _.extend(defaults, trickle._button);

      if (trickle._button._isFullWidth) {
        trickle._stepLocking._isEnabled = true;
        trickle._button._styleAfterClick = 'hidden';
      } else {
        trickle._button._autoHide = false;
      }

      Adapt.trickle.setModelConfig(model, trickle);
      model.set('_isTrickleButtonConfigured', true);

    },

    onRemove: function onRemove() {
      this.buttonViews = {};
    } });



  return new TrickleButtonHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/completion', [
'core/js/adapt'],
function (Adapt) {

  var completionAttribute = "_isComplete";

  var TrickleCompletionHandler = Backbone.Controller.extend({

    isStepLocking: false,
    isCompleted: false,

    stepModel: null,

    initialize: function initialize() {
      this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
    },

    onAppDataReady: function onAppDataReady() {
      this.getCompletionAttribute();
      this.setupEventListeners();
    },

    getCompletionAttribute: function getCompletionAttribute() {
      var trickle = Adapt.trickle.getModelConfig(Adapt.config);
      if (!trickle) return;
      if (!trickle._completionAttribute) return;
      completionAttribute = trickle._completionAttribute;
    },

    setupEventListeners: function setupEventListeners() {
      this.listenTo(Adapt, {
        "trickle:descendants": this.onDescendants,
        "trickle:steplock": this.onStepLock,
        "trickle:stepunlock": this.onStepUnlock,
        "trickle:kill": this.onKill,
        "remove": this.onRemove });

    },

    onDescendants: function onDescendants(view) {
      // save the original completion state of the component before steplocking
      view.descendantsParentFirst.forEach(function (descendant) {
        var trickle = Adapt.trickle.getModelConfig(descendant);
        if (!trickle) return;
        trickle._wasCompletedPreRender = descendant.get(completionAttribute);
      });
    },

    onStepLock: function onStepLock(view) {
      var isModelComplete = view.model.get(completionAttribute);

      var trickle = Adapt.trickle.getModelConfig(view.model);
      if (!trickle._stepLocking._isCompletionRequired &&
      !trickle._stepLocking._isLockedOnRevisit) {
        if (!isModelComplete) return;
        // skip any components that do not require completion but that are already complete
        // this is needed for a second visit to a page with 'inview'
        // components that aren't reset and don't require completion and are not relocked on revisit
        Adapt.trigger("trickle:continue", view);
        return;
      }

      if (trickle._stepLocking._isCompletionRequired &&
      isModelComplete &&
      trickle._wasCompletedPreRender) {
        // skip any components that are complete, have require completion
        // and we completed before the page rendered
        Adapt.trigger("trickle:continue", view);
        return;
      }

      Adapt.trigger("trickle:wait");

      if (isModelComplete) {
        Adapt.trigger("trickle:unwait");
        return;
      }

      view.model.set("_isTrickleAutoScrollComplete", false);
      this.isCompleted = false;
      this.isStepLocking = true;
      this.stepModel = view.model;

      this.listenTo(this.stepModel, "change:" + completionAttribute, this.onCompletion);
    },

    onCompletion: function onCompletion(model, value) {
      if (value === false) return;
      this.stepCompleted();
    },

    stepCompleted: function stepCompleted() {

      if (!this.isStepLocking) return;

      if (this.isCompleted) return;
      this.isCompleted = true;

      this.stopListening(this.stepModel, "change:" + completionAttribute, this.onCompletion);

      Adapt.trigger("trickle:unwait");
    },

    onKill: function onKill() {
      this.onStepUnlock();
    },

    onRemove: function onRemove() {
      this.onStepUnlock();
    },

    onStepUnlock: function onStepUnlock() {
      this.stopListening(this.stepModel, "change:" + completionAttribute, this.onCompletion);
      this.isStepLocking = false;
      this.stepModel = null;
      this.isCompleted = false;
    } });



  return new TrickleCompletionHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/notify', [
'core/js/adapt'],
function (Adapt) {

  var TrickleNotifyHandler = Backbone.Controller.extend({

    isStepLocking: false,
    isNotifyOpen: false,

    initialize: function initialize() {
      this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
    },

    onAppDataReady: function onAppDataReady() {
      this.setupEventListeners();
    },

    setupEventListeners: function setupEventListeners() {
      this.listenTo(Adapt, {
        "trickle:steplock": this.onStepLock,
        "notify:opened": this.onNotifyOpened,
        "notify:closed": this.onNotifyClosed,
        "trickle:stepunlock": this.onStepUnlock,
        "remove": this.onRemove });

    },

    onStepLock: function onStepLock(view) {
      this.isStepLocking = true;
    },

    onNotifyOpened: function onNotifyOpened() {
      if (!this.isStepLocking) return;

      this.isNotifyOpen = true;
      Adapt.trigger("trickle:overlay");
      Adapt.trigger("trickle:wait");
    },

    onNotifyClosed: function onNotifyClosed() {
      if (!this.isStepLocking) return;
      if (!this.isNotifyOpen) return;

      this.isNotifyOpen = false;
      Adapt.trigger("trickle:unoverlay");
      Adapt.trigger("trickle:unwait");
    },

    onStepUnlock: function onStepUnlock() {
      this.isStepLocking = false;
    },

    onRemove: function onRemove() {
      this.onStepUnlock();
    } });



  return new TrickleNotifyHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/resize', [
'core/js/adapt'],
function (Adapt) {

  var TrickleBodyResizeHandler = Backbone.Controller.extend({

    isStepLocking: false,

    stepView: null,

    initialize: function initialize() {
      this.listenToOnce(Adapt, {
        "app:dataReady": this.onAppDataReady,
        "adapt:initialize": this.onAdaptInitialized });

    },

    onAppDataReady: function onAppDataReady() {
      this.onResize = this.onResize.bind(this);
      this.preventWrapperScroll = this.preventWrapperScroll.bind(this);
      this.setupEventListeners();
    },

    setupEventListeners: function setupEventListeners() {
      this.listenTo(Adapt, {
        "trickle:steplock": this.onStepLock,
        "trickle:resize": this.onTrickleResize,
        "trickle:stepunlock": this.onStepUnlock,
        "trickle:kill": this.onKill,
        "trickle:finished": this.onFinished,
        "remove": this.onRemove });

    },

    onAdaptInitialized: function onAdaptInitialized() {
      this.wrapper = document.getElementById('wrapper');
      this.wrapper.addEventListener("scroll", this.preventWrapperScroll);
    },

    onStepLock: function onStepLock(view) {
      this.isStepLocking = true;
      this.stepView = view;
      $(window).on("resize", this.onResize);
      $(".page").on("resize", this.onResize);

      // wait for height / visibility to adjust
      Adapt.trigger("trickle:resize");
    },

    preventWrapperScroll: function preventWrapperScroll(event) {
      if (!this.isStepLocking) return;
      // Screen reader can scroll the #wrapper instead of the window.
      // This code overcomes that behaviour.
      var top = this.wrapper.scrollTop;
      if (top === 0) return;
      this.wrapper.scrollTop = 0;
      window.scrollTo(0, window.pageYOffset + top);
    },

    onResize: function onResize() {
      if (!this.isStepLocking) return;
      Adapt.trigger("trickle:resize");
    },

    onTrickleResize: function onTrickleResize() {
      if (!this.isStepLocking) return;
      var offset = this.stepView.$el.offset();
      var height = this.stepView.$el.height();

      var $wrapper = $(this.wrapper);

      var bottom = offset['top'] + height;

      $wrapper.css("height", bottom);
    },

    onStepUnlock: function onStepUnlock(view) {
      this.isStepLocking = false;
      this.stepView = null;
      $(window).off("resize", this.onResize);
      $(".page").off("resize", this.onResize);
    },

    onKill: function onKill() {
      this.onFinished();
      this.onStepUnlock();
    },

    onFinished: function onFinished() {
      this.wrapper.removeEventListener("scroll", this.preventWrapperScroll);
      $(this.wrapper).css("height", "");
    },

    onRemove: function onRemove() {
      this.onStepUnlock();
      this.stepView = null;
    } });



  return new TrickleBodyResizeHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/tutor', [
'core/js/adapt'],
function (Adapt) {

  var TrickleTutorHandler = Backbone.Controller.extend({

    stepLockedId: null,
    isStepLocking: false,
    isTutorOpen: false,

    initialize: function initialize() {
      this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
    },

    onAppDataReady: function onAppDataReady() {
      this.setupEventListeners();
    },

    setupEventListeners: function setupEventListeners() {
      this.listenTo(Adapt, {
        "trickle:steplock": this.onStepLock,
        "tutor:opened": this.onTutorOpened,
        "tutor:closed": this.onTutorClosed,
        "trickle:stepunlock": this.onStepUnlock,
        "remove": this.onRemove });

    },

    onStepLock: function onStepLock(view) {
      if (view) {
        this.stepLockedId = view.model.get("_id");
      }
      this.isStepLocking = true;
    },

    onTutorOpened: function onTutorOpened(view, alertObject) {
      if (!this.isStepLocking) return;
      if (!this.isOriginStepLocked(view)) return;

      this.isTutorOpen = true;
      Adapt.trigger("trickle:overlay");
      Adapt.trigger("trickle:wait");
    },

    isOriginStepLocked: function isOriginStepLocked(view) {
      if (!view || !this.stepLockedId) return true;

      var parents = view.model.getAncestorModels();
      var hasStepLockedParent = _.find(parents, function (ancestor) {
        return ancestor.get('_id') === this.stepLockedId;
      }, this);
      if (!hasStepLockedParent) return false;
      return true;
    },

    onTutorClosed: function onTutorClosed(view, alertObject) {
      if (!this.isStepLocking) return;
      if (!this.isTutorOpen) return;
      if (!this.isOriginStepLocked(view)) return;

      this.isTutorOpen = false;
      Adapt.trigger("trickle:unoverlay");
      Adapt.trigger("trickle:unwait");
    },

    onStepUnlock: function onStepUnlock() {
      this.isStepLocking = false;
      this.stepLockedId = null;
    },

    onRemove: function onRemove() {
      this.onStepUnlock();
    } });



  return new TrickleTutorHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/visibility', [
'core/js/adapt'],
function (Adapt) {

  var TrickleVisibilityHandler = Backbone.Controller.extend({

    isStepLocking: false,

    trickleModel: null,

    initialize: function initialize() {
      this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
    },

    onAppDataReady: function onAppDataReady() {
      this.setupEventListeners();
    },

    setupEventListeners: function setupEventListeners() {
      this.listenTo(Adapt, {
        "trickle:steplock": this.onStepLock,
        "trickle:visibility": this.onVisibility,
        "trickle:stepunlock": this.onStepUnlock,
        "trickle:kill": this.onKill,
        "trickle:finished": this.onFinished,
        "remove": this.onRemove });


    },

    onStepLock: function onStepLock(view) {
      this.isStepLocking = true;
      this.trickleModel = view.model;
      Adapt.trigger("trickle:visibility");
    },

    onVisibility: function onVisibility() {
      if (!this.isStepLocking) return;

      if (!Adapt.trickle.pageView) return;

      var descendantsParentFirst = Adapt.trickle.pageView.descendantsParentFirst;

      var trickleModelId = this.trickleModel.get("_id");
      var trickleType = this.trickleModel.get("_type");

      var atIndex = _.findIndex(descendantsParentFirst, function (descendant) {
        if (descendant.get("_id") === trickleModelId) return true;
      });

      descendantsParentFirst.forEach(function (descendant, index) {
        var components = descendant.findDescendantModels("components");
        if (index <= atIndex) {
          descendant.set("_isVisible", true, { pluginName: "trickle" });
          components.forEach(function (componentModel) {
            componentModel.set("_isVisible", true, { pluginName: "trickle" });
          });
          return;
        }

        if (trickleType === "article" && descendant.get("_type") === "block") {
          // make sure article blocks are shown
          if (descendant.get("_parentId") === trickleModelId) {
            descendant.set("_isVisible", true, { pluginName: "trickle" });
            components.forEach(function (componentModel) {
              componentModel.set("_isVisible", true, { pluginName: "trickle" });
            });
            return;
          }
        }

        descendant.set("_isVisible", false, { pluginName: "trickle" });
        components.forEach(function (componentModel) {
          componentModel.set("_isVisible", false, { pluginName: "trickle" });
        });

      });

    },

    onStepUnlock: function onStepUnlock(view) {
      this.isStepLocking = false;
      this.trickleModel = null;
    },

    onKill: function onKill() {
      this.onFinished();
      this.onStepUnlock();
    },

    onFinished: function onFinished() {

      var descendantsParentFirst = Adapt.trickle.pageView.descendantsParentFirst;
      descendantsParentFirst.forEach(function (descendant) {
        descendant.set("_isVisible", true, { pluginName: "trickle" });
        var components = descendant.findDescendantModels("components");
        components.forEach(function (componentModel) {
          componentModel.set("_isVisible", true, { pluginName: "trickle" });
        });
      });

    },

    onRemove: function onRemove() {
      this.onStepUnlock();
    } });



  return new TrickleVisibilityHandler();

});

define('extensions/adapt-contrib-trickle/js/handlers/done', [
'core/js/adapt'],
function (Adapt) {

  var TrickleDone = Backbone.Controller.extend({

    initialize: function initialize() {
      this.listenToOnce(Adapt, "app:dataReady", this.onAppDataReady);
    },

    onAppDataReady: function onAppDataReady() {
      this.setupEventListeners();
    },

    setupEventListeners: function setupEventListeners() {
      this.onDone = _.debounce(this.onDone.bind(this), 50);
      this.listenTo(Adapt, {
        "trickle:steplock": this.onDone,
        "trickle:stepunlock": this.onDone,
        "trickle:continue": this.onDone,
        "trickle:finished": this.onDone });

    },

    onDone: function onDone() {
      Adapt.trigger("trickle:done");
    } });



  return new TrickleDone();

});

define('extensions/adapt-contrib-trickle/js/adapt-contrib-trickle', [
'core/js/adapt',
'./pageView',
'./handlers/button',
'./handlers/completion',
'./handlers/notify',
'./handlers/resize',
'./handlers/tutor',
'./handlers/visibility',
'./handlers/done'],
function (Adapt, PageView) {

  var Trickle = Backbone.Controller.extend({

    model: null,
    pageView: null,

    initialize: function initialize() {
      this.listenToOnce(Adapt, {
        'app:dataReady': this.onAppDataReady });

    },

    onAppDataReady: function onAppDataReady() {
      this.getCourseModel();
      if (!this.isCourseEnabled()) return;
      this.setupListeners();
    },

    getCourseModel: function getCourseModel() {
      this.model = Adapt.course;
    },

    isCourseEnabled: function isCourseEnabled() {
      var trickleConfig = this.getModelConfig(this.model);
      if (trickleConfig && trickleConfig._isEnabled === false) return false;
      return true;
    },

    getModelConfig: function getModelConfig(model) {
      return model.get('_trickle');
    },

    getCompletionAttribute: function getCompletionAttribute() {
      var trickle = this.getModelConfig(Adapt.config);
      if (!trickle) return '_isComplete';
      return trickle._completionAttribute || '_isComplete';
    },

    setModelConfig: function setModelConfig(model, config) {
      return model.set('_trickle', config);
    },

    setupListeners: function setupListeners() {
      this.listenTo(Adapt, 'pageView:preRender', this.onPagePreRender);
    },

    onPagePreRender: function onPagePreRender(view) {
      this.pageView = new PageView({
        model: view.model,
        el: view.el });

    },

    scroll: function scroll(fromModel) {
      // Wait for model visibility to handle

      if (!this.shouldScrollPage(fromModel)) return;

      fromModel.set('_isTrickleAutoScrollComplete', true);

      var trickle = Adapt.trickle.getModelConfig(fromModel);
      var isAutoScrollOff = !trickle._autoScroll;
      var hasTrickleButton = trickle._button._isEnabled;
      if (isAutoScrollOff && !hasTrickleButton) {
        return;
      }

      var scrollTo = trickle._scrollTo;
      if (scrollTo === undefined) scrollTo = '@block +1';

      var scrollToId = '';
      switch (scrollTo.substr(0, 1)) {
        case '@':
          // NAVIGATE BY RELATIVE TYPE

          // Allows trickle to scroll to a sibling / cousin component
          // relative to the current trickle item
          var relativeModel = fromModel.findRelativeModel(scrollTo, {
            filter: function filter(model) {
              return model.get('_isAvailable');
            } });


          if (relativeModel === undefined) return;
          scrollToId = relativeModel.get('_id');
          break;
        case '.':
          // NAVIGATE BY CLASS
          scrollToId = scrollTo.substr(1, scrollTo.length - 1);
          break;
        default:
          scrollToId = scrollTo;}


      if (scrollToId === '') return;

      if (hasTrickleButton) {// only set focus if there's a trickle button - see https://github.com/adaptlearning/adapt_framework/issues/2813
        Adapt.a11y.focusFirst($('.' + scrollToId));
      }

      if (isAutoScrollOff) return;

      var duration = fromModel.get('_trickle')._scrollDuration || 500;
      Adapt.scrollTo('.' + scrollToId, { duration: duration });
    },

    shouldScrollPage: function shouldScrollPage(fromModel) {
      var trickle = Adapt.trickle.getModelConfig(fromModel);
      if (!trickle || !trickle._isEnabled) return false;

      var hasScrolled = fromModel.get('_isTrickleAutoScrollComplete');
      if (hasScrolled) return false;

      var isArticleWithOnChildren = fromModel.get('_type') === 'article' && trickle._onChildren;
      if (isArticleWithOnChildren) return false;

      return true;
    } });



  return Adapt.trickle = new Trickle();

});

define('extensions/adapt-contrib-tutor/js/adapt-contrib-tutor', [
'core/js/adapt'],
function (Adapt) {

  Adapt.on('questionView:showFeedback', function (view) {

    var alertObject = {
      title: view.model.get('feedbackTitle'),
      body: view.model.get('feedbackMessage') };


    var attributes = {};
    var classes = [];

    if (view.model.has('_isCorrect')) {
      // Attach specific classes so that feedback can be styled.
      if (view.model.get('_isCorrect')) {
        classes.push('is-correct');
      } else {
        if (view.model.has('_isAtLeastOneCorrectSelection')) {
          // Partially correct feedback is an option.
          if (view.model.get('_isAtLeastOneCorrectSelection')) {
            classes.push('is-partially-correct');
          } else {
            classes.push('is-incorrect');
          }
        } else {
          classes.push('is-incorrect');
        }
      }
    }

    // Add the extension/component type which triggered this.
    if (view.model.has('_component')) {
      classes.push('is-component is-' + view.model.get('_component').toLowerCase());
    } else if (view.model.has('_extension')) {
      classes.push('is-extension is-' + view.model.get('_extension').toLowerCase());
    }

    // Add the _id property as attribute.
    attributes['data-adapt-id'] = view.model.get('_id');

    alertObject._classes = classes.join(' ');
    alertObject._attributes = attributes;

    Adapt.once('notify:closed', function () {
      Adapt.trigger('tutor:closed', view, alertObject);
    });

    Adapt.trigger('notify:popup', alertObject);

    Adapt.trigger('tutor:opened', view, alertObject);

  });

});

define('core/js/views/menuItemView', [
'core/js/views/adaptView'],
function (AdaptView) {var

  MenuItemView = /*#__PURE__*/function (_AdaptView5) {"use strict";_inherits(MenuItemView, _AdaptView5);var _super49 = _createSuper(MenuItemView);function MenuItemView() {_classCallCheck(this, MenuItemView);return _super49.apply(this, arguments);}_createClass(MenuItemView, [{ key: "attributes", value: function attributes()

      {
        return AdaptView.resultExtend('attributes', {
          'role': 'listitem',
          'aria-labelledby': this.model.get('_id') + '-heading' },
        this);
      } }, { key: "className", value: function className()

      {
        return [
        'menu-item',
        this.constructor.className,
        this.model.get('_id'),
        this.model.get('_classes'),
        this.setVisibility(),
        this.setHidden(),
        this.model.get('_isVisited') ? 'is-visited' : '',
        this.model.get('_isComplete') ? 'is-complete' : '',
        this.model.get('_isLocked') ? 'is-locked' : '',
        this.model.get('_isOptional') ? 'is-optional' : ''].
        join(' ');
      } }, { key: "preRender", value: function preRender()

      {
        this.model.checkCompletionStatus();
        this.model.checkInteractionCompletionStatus();
      } }, { key: "postRender", value: function postRender()

      {
        this.$el.imageready(this.setReadyStatus.bind(this));
      } }]);return MenuItemView;}(AdaptView);



  MenuItemView.type = 'menuItem';

  return MenuItemView;

});

define('core/js/views/menuView', [
'core/js/views/contentObjectView',
'core/js/views/menuItemView'],
function (ContentObjectView, MenuItemView) {var

  MenuView = /*#__PURE__*/function (_ContentObjectView2) {"use strict";_inherits(MenuView, _ContentObjectView2);var _super50 = _createSuper(MenuView);function MenuView() {_classCallCheck(this, MenuView);return _super50.apply(this, arguments);}return MenuView;}(ContentObjectView);

  Object.assign(MenuView, {
    /**
                             * TODO:
                             * child view here should not be fixed to the MenuItemView
                             * menus may currently rely on this
                             */
    childContainer: '.js-children',
    childView: MenuItemView,
    type: 'menu',
    template: 'menu' });


  return MenuView;

});

define('menu/adapt-contrib-boxMenu/js/adapt-contrib-boxMenuItemView', [
'core/js/views/menuItemView'],
function (MenuItemView) {

  var BoxMenuItemView = MenuItemView.extend({

    events: {
      'click .js-btn-click': 'onClickMenuItemButton' },


    onClickMenuItemButton: function onClickMenuItemButton(event) {
      if (event && event.preventDefault) event.preventDefault();
      if (this.model.get('_isLocked')) return;
      Backbone.history.navigate('#/id/' + this.model.get('_id'), { trigger: true });
    } },

  {
    className: 'boxmenu-item',
    template: 'boxMenuItem' });


  return BoxMenuItemView;

});

define('menu/adapt-contrib-boxMenu/js/adapt-contrib-boxMenuGroupView', [
'core/js/views/menuItemView',
'./adapt-contrib-boxMenuItemView'],
function (MenuItemView, BoxMenuItemView) {

  var BoxMenuGroupView = MenuItemView.extend({

    postRender: function postRender() {
      _.defer(this.addChildren.bind(this));
      this.$el.imageready(this.setReadyStatus.bind(this));
      this.$el.parents('.boxmenu__item-container').addClass('has-groups');
    } },

  {
    childContainer: '.js-group-children',
    childView: BoxMenuItemView,
    className: 'boxmenu-group',
    template: 'boxMenuGroup' });


  return BoxMenuGroupView;

});

define('menu/adapt-contrib-boxMenu/js/adapt-contrib-boxMenu', [
'core/js/adapt',
'core/js/models/menuModel',
'core/js/views/menuView',
'./adapt-contrib-boxMenuItemView',
'./adapt-contrib-boxMenuGroupView'],
function (Adapt, MenuModel, MenuView, BoxMenuItemView, BoxMenuGroupView) {

  var BoxMenuView = MenuView.extend({

    initialize: function initialize() {
      MenuView.prototype.initialize.apply(this);
      this.setStyles();

      this.listenTo(Adapt, {
        'device:changed': this.onDeviceResize });

    },

    onDeviceResize: function onDeviceResize() {
      this.setStyles();
    },

    addChildren: function addChildren() {
      var nthChild = 0;
      var models = this.model.getChildren().models;
      var childViews = [];
      models.forEach(function (model) {
        if (!model.get('_isAvailable')) return;

        nthChild++;
        model.set('_nthChild', nthChild);

        var ChildView = model.get('_type') === 'menu' && model.get('_boxMenu') && model.get('_boxMenu')._renderAsGroup ?
        BoxMenuGroupView :
        BoxMenuItemView;

        var $parentContainer = this.$(this.constructor.childContainer);
        var childView = new ChildView({ model: model });

        childViews.push(childView);

        $parentContainer.append(childView.$el);

      }.bind(this));

      this.setChildViews(childViews);

    },

    setStyles: function setStyles() {
      this.setBackgroundImage();
      this.setBackgroundStyles();
      this.processHeader();
    },

    setBackgroundImage: function setBackgroundImage() {
      var config = this.model.get('_boxMenu');
      var backgroundImages = config && config._backgroundImage;

      if (!backgroundImages) return;

      var backgroundImage;

      switch (Adapt.device.screenSize) {
        case 'large':
          backgroundImage = backgroundImages._large;
          break;
        case 'medium':
          backgroundImage = backgroundImages._medium;
          break;
        default:
          backgroundImage = backgroundImages._small;}


      if (backgroundImage) {
        this.$el.
        addClass('has-bg-image').
        css('background-image', 'url(' + backgroundImage + ')');
      } else {
        this.$el.
        removeClass('has-bg-image').
        css('background-image', '');
      }
    },

    setBackgroundStyles: function setBackgroundStyles() {
      var config = this.model.get('_boxMenu');
      var styles = config && config._backgroundStyles;

      if (!styles) return;

      this.$el.css({
        'background-repeat': styles._backgroundRepeat,
        'background-size': styles._backgroundSize,
        'background-position': styles._backgroundPosition });

    },

    processHeader: function processHeader() {
      var config = this.model.get('_boxMenu');
      var header = config && config._menuHeader;

      if (!header) return;

      var $header = this.$('.menu__header');

      this.setHeaderBackgroundImage(header, $header);
      this.setHeaderBackgroundStyles(header, $header);
      this.setHeaderMinimumHeight(header, $header);
    },

    setHeaderBackgroundImage: function setHeaderBackgroundImage(config, $header) {
      var backgroundImages = config._backgroundImage;

      if (!backgroundImages) return;

      var backgroundImage;

      switch (Adapt.device.screenSize) {
        case 'large':
          backgroundImage = backgroundImages._large;
          break;
        case 'medium':
          backgroundImage = backgroundImages._medium;
          break;
        default:
          backgroundImage = backgroundImages._small;}


      if (backgroundImage) {
        $header.
        addClass('has-bg-image').
        css('background-image', 'url(' + backgroundImage + ')');
      } else {
        $header.
        removeClass('has-bg-image').
        css('background-image', '');
      }
    },

    setHeaderBackgroundStyles: function setHeaderBackgroundStyles(config, $header) {
      var styles = config._backgroundStyles;

      if (!styles) return;

      $header.css({
        'background-repeat': styles._backgroundRepeat,
        'background-size': styles._backgroundSize,
        'background-position': styles._backgroundPosition });

    },

    setHeaderMinimumHeight: function setHeaderMinimumHeight(config, $header) {
      var minimumHeights = config._minimumHeights;

      if (!minimumHeights) return;

      var minimumHeight;

      switch (Adapt.device.screenSize) {
        case 'large':
          minimumHeight = minimumHeights._large;
          break;
        case 'medium':
          minimumHeight = minimumHeights._medium;
          break;
        default:
          minimumHeight = minimumHeights._small;}


      if (minimumHeight) {
        $header.
        addClass('has-min-height').
        css('min-height', minimumHeight + 'px');
      } else {
        $header.
        removeClass('has-min-height').
        css('min-height', '');
      }
    } },

  {
    className: 'boxmenu',
    template: 'boxMenu' });


  // Use as default "_type": "course" or "_type": "menu" view.
  // Note: This is necessary to maintain legacy behaviour in the AAT where
  // only one menu is usable per course and the course / menu is assumed to be
  // a core model and use the only installed MenuView.
  Adapt.register('course menu', {
    view: BoxMenuView });


  // Use for "_component": "boxMenu", or "_view": "boxMenu" and "_model": "boxMenu"
  Adapt.register('boxMenu', {
    view: BoxMenuView,
    model: MenuModel.extend({}) });


});

define('theme/adapt-contrib-vanilla/js/themeView', [
'core/js/adapt'],
function (Adapt) {

  var ThemeView = Backbone.View.extend({

    className: function className() {},

    initialize: function initialize() {
      this.setStyles();

      this.listenTo(Adapt, {
        'device:changed': this.onDeviceResize,
        'remove': this.remove });

    },

    onDeviceResize: function onDeviceResize() {
      this.setStyles();
    },

    remove: function remove() {
      Backbone.View.prototype.remove.call(this);

      this.onRemove();
    },

    setStyles: function setStyles() {
      this.setClasses();
      this.setBackgroundImage();
      this.setBackgroundStyles();
      this.setMinimumHeight();
      this.setCustomStyles();
    },

    setClasses: function setClasses() {
      this.$el.addClass(this.className());
    },

    setBackgroundImage: function setBackgroundImage() {
      var backgroundImages = this.model.get('_backgroundImage');

      if (!backgroundImages) return;

      var backgroundImage;

      switch (Adapt.device.screenSize) {
        case 'large':
          backgroundImage = backgroundImages._large;
          break;
        case 'medium':
          backgroundImage = backgroundImages._medium;
          break;
        default:
          backgroundImage = backgroundImages._small;}


      if (backgroundImage) {
        this.$el.
        addClass('has-bg-image').
        css('background-image', 'url(' + backgroundImage + ')');
      } else {
        this.$el.
        removeClass('has-bg-image').
        css('background-image', '');
      }
    },

    setBackgroundStyles: function setBackgroundStyles() {
      var styles = this.model.get('_backgroundStyles');

      if (!styles) return;

      this.$el.css({
        'background-repeat': styles._backgroundRepeat,
        'background-size': styles._backgroundSize,
        'background-position': styles._backgroundPosition });

    },

    setMinimumHeight: function setMinimumHeight() {
      var minimumHeights = this.model.get('_minimumHeights');

      if (!minimumHeights) return;

      var minimumHeight;

      switch (Adapt.device.screenSize) {
        case 'large':
          minimumHeight = minimumHeights._large;
          break;
        case 'medium':
          minimumHeight = minimumHeights._medium;
          break;
        default:
          minimumHeight = minimumHeights._small;}


      if (minimumHeight) {
        this.$el.
        addClass('has-min-height').
        css('min-height', minimumHeight + 'px');
      } else {
        this.$el.
        removeClass('has-min-height').
        css('min-height', '');
      }
    },

    setCustomStyles: function setCustomStyles() {},

    onRemove: function onRemove() {} });



  return ThemeView;

});

define('theme/adapt-contrib-vanilla/js/themePageView', [
'./themeView',
'core/js/adapt'],
function (ThemeView, Adapt) {

  var ThemePageView = ThemeView.extend({

    className: function className() {},

    setCustomStyles: function setCustomStyles() {
      this.processHeader();
    },

    processHeader: function processHeader() {
      var header = this.model.get('_pageHeader');

      if (!header) return;

      var $header = this.$('.page__header');

      this.setHeaderBackgroundImage(header, $header);
      this.setHeaderBackgroundStyles(header, $header);
      this.setHeaderMinimumHeight(header, $header);
    },

    setHeaderBackgroundImage: function setHeaderBackgroundImage(config, $header) {
      var backgroundImages = config._backgroundImage;

      if (!backgroundImages) return;

      var backgroundImage;

      switch (Adapt.device.screenSize) {
        case 'large':
          backgroundImage = backgroundImages._large;
          break;
        case 'medium':
          backgroundImage = backgroundImages._medium;
          break;
        default:
          backgroundImage = backgroundImages._small;}


      if (backgroundImage) {
        $header.
        addClass('has-bg-image').
        css('background-image', 'url(' + backgroundImage + ')');
      } else {
        $header.
        removeClass('has-bg-image').
        css('background-image', '');
      }
    },

    setHeaderBackgroundStyles: function setHeaderBackgroundStyles(config, $header) {
      var styles = config._backgroundStyles;

      if (!styles) return;

      $header.css({
        'background-repeat': styles._backgroundRepeat,
        'background-size': styles._backgroundSize,
        'background-position': styles._backgroundPosition });

    },

    setHeaderMinimumHeight: function setHeaderMinimumHeight(config, $header) {
      var minimumHeights = config._minimumHeights;

      if (!minimumHeights) return;

      var minimumHeight;

      switch (Adapt.device.screenSize) {
        case 'large':
          minimumHeight = minimumHeights._large;
          break;
        case 'medium':
          minimumHeight = minimumHeights._medium;
          break;
        default:
          minimumHeight = minimumHeights._small;}


      if (minimumHeight) {
        $header.
        addClass('has-min-height').
        css('min-height', minimumHeight + 'px');
      } else {
        $header.
        removeClass('has-min-height').
        css('min-height', '');
      }
    },

    onRemove: function onRemove() {} });



  return ThemePageView;

});

define('theme/adapt-contrib-vanilla/js/themeArticleView', [
'./themeView'],
function (ThemeView) {

  var ThemeArticleView = ThemeView.extend({

    className: function className() {},

    setCustomStyles: function setCustomStyles() {},

    onRemove: function onRemove() {} });



  return ThemeArticleView;

});

define('theme/adapt-contrib-vanilla/js/themeBlockView', [
'./themeView'],
function (ThemeView) {

  var ThemeBlockView = ThemeView.extend({

    className: function className() {
      return this.model.get('_isDividerBlock') ? 'is-divider-block' : '';
    },

    setCustomStyles: function setCustomStyles() {},

    onRemove: function onRemove() {} });



  return ThemeBlockView;

});

define('theme/adapt-contrib-vanilla/js/theme', [
'core/js/adapt',
'./themePageView',
'./themeArticleView',
'./themeBlockView',
'./themeView'],
function (Adapt, ThemePageView, ThemeArticleView, ThemeBlockView, ThemeView) {

  function onDataReady() {
    $('html').addClass(Adapt.course.get('_courseStyle'));
  }

  function onPostRender(view) {
    var model = view.model;
    var theme = model.get('_vanilla');

    if (!theme) return;

    switch (model.get('_type')) {
      case 'page':
        new ThemePageView({ model: new Backbone.Model(theme), el: view.$el });
        break;
      case 'article':
        new ThemeArticleView({ model: new Backbone.Model(theme), el: view.$el });
        break;
      case 'block':
        new ThemeBlockView({ model: new Backbone.Model(theme), el: view.$el });
        break;
      default:
        new ThemeView({ model: new Backbone.Model(theme), el: view.$el });}

  }

  Adapt.on({
    'app:dataReady': onDataReady,
    'pageView:postRender articleView:postRender blockView:postRender': onPostRender });

});

;
define("plugins", ["components/adapt-contrib-accordion/js/adapt-contrib-accordion", "components/adapt-contrib-assessmentResults/js/adapt-contrib-assessmentResults", "components/adapt-contrib-blank/js/adapt-contrib-blank", "components/adapt-contrib-gmcq/js/adapt-contrib-gmcq", "components/adapt-contrib-graphic/js/adapt-contrib-graphic", "components/adapt-contrib-hotgraphic/js/adapt-contrib-hotgraphic", "components/adapt-contrib-matching/js/adapt-contrib-matching", "components/adapt-contrib-mcq/js/adapt-contrib-mcq", "components/adapt-contrib-media/js/adapt-contrib-media", "components/adapt-contrib-narrative/js/adapt-contrib-narrative", "components/adapt-contrib-slider/js/adapt-contrib-slider", "components/adapt-contrib-text/js/adapt-contrib-text", "components/adapt-contrib-textInput/js/adapt-contrib-textInput", "extensions/adapt-contrib-assessment/js/adapt-assessmentArticleExtension", "extensions/adapt-contrib-bookmarking/js/adapt-contrib-bookmarking", "extensions/adapt-contrib-languagePicker/js/adapt-languagePicker", "extensions/adapt-contrib-pageLevelProgress/js/adapt-contrib-pageLevelProgress", "extensions/adapt-contrib-resources/js/adapt-contrib-resources", "extensions/adapt-contrib-trickle/js/adapt-contrib-trickle", "extensions/adapt-contrib-tutor/js/adapt-contrib-tutor", "menu/adapt-contrib-boxMenu/js/adapt-contrib-boxMenu", "theme/adapt-contrib-vanilla/js/theme"], function () {});

require([
'core/js/adapt',
'core/js/templates',
'core/js/fixes',
'core/js/accessibility',
'core/js/data',
'core/js/offlineStorage',
'core/js/logging',
'core/js/tracking',
'core/js/device',
'core/js/drawer',
'core/js/notify',
'core/js/router',
'core/js/models/lockingModel',
'core/js/mpabc',
'core/js/helpers',
'core/js/scrolling',
'core/js/headings',
'core/js/navigation',
'plugins'],
function (Adapt) {

  $('body').append(Handlebars.templates.loading());

  Adapt.data.on('ready', function triggerInit() {
    Adapt.log.debug('Calling Adapt.init');

    Adapt.init();

    Adapt.off('adaptCollection:dataLoaded courseModel:dataLoaded');
  }).init();

});

define("core/js/app", function () {});
//# sourceMappingURL=adapt.min.js.map
